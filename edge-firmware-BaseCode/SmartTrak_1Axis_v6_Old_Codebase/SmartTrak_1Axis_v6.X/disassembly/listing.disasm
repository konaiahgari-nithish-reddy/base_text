Disassembly Listing for SmartTrak_Ctrl
Generated From:
F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/SmartTrak_Ctrl.X/dist/default/debug/SmartTrak_Ctrl.X.debug.elf
Mar 18, 2013 7:05:06 PM

---  c:/program files/microchip/xc32/v1.20/pic32mx/include/peripheral/uart.h  ---------------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: Constants & Data Types
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  //DOM-IGNORE-BEGIN
74:                  /****
75:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
76:                         the device file.  Also the UART register set could also be placed there
77:                  *****/
78:                  typedef struct
79:                  {
80:                  	volatile UINT	reg;
81:                  	volatile UINT	clr;
82:                  	volatile UINT	set;
83:                  	volatile UINT	inv;
84:                  }REG_SET;
85:                  
86:                  typedef struct
87:                  {
88:                  	volatile REG_SET	mode;
89:                  	volatile REG_SET	sta;
90:                  	volatile REG_SET    tx;
91:                  	volatile REG_SET	rx;
92:                  	volatile REG_SET	brg;
93:                  }UART_REGS;
94:                  
95:                  extern UART_REGS * const uartReg[];
96:                  //DOM-IGNORE-END
97:                  
98:                  // *****************************************************************************
99:                  /* UART Module
100:                 
101:                   Summary:
102:                     UART modules supported.
103:                 
104:                   Description:
105:                     This enumeration identifies the available UART modules.
106:                 */
107:                 
108:                 typedef enum
109:                 {
110:                 #if defined _UART1
111:                     // UART1 Module ID.
112:                     UART1 = 0,
113:                 #endif
114:                 #if defined _UART2
115:                     // UART2 Module ID.
116:                     UART2,
117:                 #endif
118:                 #ifdef _UART3
119:                     // UART3 Module ID.
120:                     UART3,
121:                 #endif
122:                 #ifdef _UART4
123:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
124:                     UART4,
125:                 #endif
126:                 #ifdef _UART5
127:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
128:                     UART5,
129:                 #endif
130:                 #ifdef _UART6
131:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
132:                     UART6,
133:                 #endif
134:                     // Number of available UART modules.
135:                     UART_NUMBER_OF_MODULES
136:                 
137:                 } UART_MODULE;
138:                 
139:                 
140:                 // *****************************************************************************
141:                 /* UART Enable Modes
142:                 
143:                   Summary:
144:                     Operating modes of UART.
145:                 
146:                   Description:
147:                     This enumeration defines the supported modes in which the UART may be
148:                     enabled or disbled.
149:                 
150:                   Remarks:
151:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
152:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
153:                     has been pre-loaded with data.
154:                 
155:                     The caller should not rely on the specific numbers assigned to any of these
156:                     values as they may change from one processor to the next.
157:                 */
158:                 
159:                 typedef enum
160:                 {
161:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
162:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
163:                 
164:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
165:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
166:                 
167:                 
168:                     // UART Module, receiver and transmitter functionality is not.
169:                     // enabled or disabled
170:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
171:                 
172:                     // UART Module receiver.
173:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
174:                 
175:                     // UART Module transmitter.
176:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
177:                 
178:                 
179:                 } UART_ENABLE_MODE;
180:                 
181:                 // *****************************************************************************
182:                 /* UART Enable Helper Macro
183:                 
184:                   Summary:
185:                     Macro for enabling module operating modes.
186:                 
187:                   Description:
188:                     This macro creates the proper flags for enabling operating modes of the UART module.
189:                 
190:                   Example:
191:                     <code>
192:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
193:                     </code>
194:                 
195:                   Remarks:
196:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
197:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
198:                     has been pre-loaded with data.
199:                 */
200:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
201:                 
202:                 // *****************************************************************************
203:                 /* UART Disable Helper Macro
204:                 
205:                   Summary:
206:                     Macro for disabling module operating modes.
207:                 
208:                   Description:
209:                     This macro creates the proper flags for disabling operating modes of the UART module.
210:                 
211:                   Example:
212:                     <code>
213:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
214:                     </code>
215:                 
216:                 */
217:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
218:                 
219:                 // *****************************************************************************
220:                 /* UART Configuration Settings
221:                 
222:                   Summary:
223:                     Supported configuration flags for the UART module.
224:                 
225:                   Description:
226:                     This enumeration defines the various configuration options for the UART
227:                     module.  These values can be OR'd together to create a configuration mask
228:                     passed to the UARTConfigure routine.
229:                 
230:                   Remarks:
231:                     Several of the configuration options are mutually exclusive:
232:                     * Only one of the "ENABLE_PINS" modes can be used at a time
233:                     * Only one of the "RTS_WHEN" modes can be used at a time
234:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
235:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
236:                 
237:                     The caller should not rely on the specific numbers assigned to any of these
238:                     values as they may change from one processor ot the next.
239:                 */
240:                 
241:                 typedef enum
242:                 {
243:                     // Enables high-speed range of the UART (see UARTSetBitRate).
244:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
245:                 
246:                     // Inverts polarity of data interpretation the received (RX) pin.
247:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
248:                 
249:                     // Enables UART TX-to-RX Loop-back mode.
250:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
251:                 
252:                     // Enables Wake-up of the part when a start bit is received.
253:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
254:                 
255:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
256:                     // cannot be used in bit-clock/IrDA mode).
257:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
258:                 
259:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
260:                     // cannot be used in CTS/RTS mode).
261:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
262:                 
263:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
264:                     // be used in RTS-Only mode).
265:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
266:                 
267:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
268:                     // the default mode and this parameter can be left out if it is desired).
269:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
270:                 
271:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
272:                     // is not full (i.e., the UART is ready to receive data).  This is also known
273:                     // as "RTS Flow-Control Mode".
274:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
275:                 
276:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
277:                     // is not empty (i.e., when the UART has data ready to send).  This is also
278:                     // known as "RTS Simplex Mode".
279:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
280:                 
281:                     // Enable the IrDA encoder/decoder.
282:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
283:                 
284:                     // Enables stopping of the UART operation to save power when the core has
285:                     // been put in idle mode.
286:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
287:                 
288:                     // Inverts the polarity of data sent on the transmit (TX) pin.
289:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
290:                 
291:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
292:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
293:                     // Note:  The address must still be set using UARTEnableAddressDetect
294:                     // to support IEEE-485 protocol.
295:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
296:                 
297:                 } UART_CONFIGURATION;
298:                 
299:                 
300:                 // *****************************************************************************
301:                 /* UART FIFO Modes
302:                 
303:                   Summary:
304:                     Supported FIFO modes for the UART module.
305:                 
306:                   Description:
307:                     This enumeration defines supported FIFO modes that determine when the Tx
308:                     and Rx interrupts will occur.
309:                 
310:                   Remarks:
311:                     These modes consist of two sets of mutially exclusive modes:
312:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
313:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
314:                 
315:                     The caller should not rely on the specific numbers assigned to any of these
316:                     values as they may change from one processor ot the next.
317:                 
318:                 */
319:                 
320:                 typedef enum
321:                 {
322:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
323:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
324:                 
325:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
326:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
327:                 
328:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
329:                     // full (i.e. there is space available for more data)  This is the default.
330:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
331:                 
332:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
333:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
334:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
337:                     // (three-quarter) full.
338:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
339:                 
340:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
341:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
342:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
343:                 
344:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
345:                     // data.
346:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
347:                 
348:                 } UART_FIFO_MODE;
349:                 
350:                 
351:                 // *****************************************************************************
352:                 /* UART Line Control Mode
353:                 
354:                   Summary:
355:                     UART line control mode.
356:                 
357:                   Description:
358:                     This data type defines the supported line control modes for the UART.
359:                 
360:                   Remarks:
361:                     Some of the line-control options are mutually exclusive:
362:                     * Only one of the "DATA_SIZE" options can be used at a time
363:                     * Only one of the "PARITY" options can be used at a time
364:                     * Only one of the "STOP_BITS" options can be used at a time
365:                 
366:                     The caller should not rely on the specific numbers assigned to any of these
367:                     values as they may change from one processor ot the next.
368:                 */
369:                 
370:                 typedef enum
371:                 {
372:                     // Sets the data transfer size to 8-bits per frame.
373:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
374:                 
375:                     // Sets the data transfer size to 9-bits per frame.
376:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
377:                 
378:                     // Enables parity bit generation for odd parity.
379:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
380:                 
381:                     // Enables parity bit generation for even parity.
382:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
383:                 
384:                     // Disables parity bit generation.
385:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
386:                 
387:                     // Enables generation of 2 stop bits per frame.
388:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
389:                 
390:                     // Enables generation of 1 stop bit per frame (default).
391:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
392:                 
393:                 } UART_LINE_CONTROL_MODE;
394:                 
395:                 
396:                 // *****************************************************************************
397:                 /* UART Line Status Flags
398:                 
399:                   Summary:
400:                     UART line-status bitmask flags.
401:                 
402:                   Description:
403:                     This enumeration defines the UART line-status bits.  These values are
404:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
405:                 
406:                   Remarks:
407:                     The caller should not rely on the specific numbers assigned to any of these
408:                     values as they may change from one processor ot the next.
409:                 */
410:                 
411:                 typedef enum
412:                 {
413:                     // The transmitter is able to accept data to transmit.
414:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
415:                 
416:                     // The transmitter is empty (no data is available to transmit).
417:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
418:                 
419:                     // The receiver is currently idle.
420:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
421:                 
422:                     // A received data parity error was detected.
423:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
424:                 
425:                     // Data was received that violated the framing protocol (the data word did
426:                     // not start or stop at the appropriate place).  Note:  A break condition
427:                     // will always indicate a framing error.
428:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
429:                 
430:                     // The UART has received more data than it can buffer.  Data has been lost.
431:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
432:                 
433:                     // UART data has been received and is avaiable in the FIFO.
434:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
435:                 
436:                 } UART_LINE_STATUS;
437:                 
438:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
439:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
440:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
441:                 
442:                 
443:                 
444:                 // *****************************************************************************
445:                 /* UART Data
446:                 
447:                   Summary:
448:                     UART data.
449:                 
450:                   Description:
451:                     This data type defines the supported data sizes for the UART.
452:                 */
453:                 
454:                 typedef union
455:                 {
456:                     // 8-bit data
457:                     struct
458:                     {
459:                         UINT16  data8bit    : 8;
460:                     };
461:                 
462:                     // 9-bit data
463:                     struct
464:                     {
465:                         UINT16  data9bit    : 9;
466:                     };
467:                 
468:                     UINT16 __data;
469:                 } UART_DATA;
470:                 
471:                 
472:                 // *****************************************************************************
473:                 // *****************************************************************************
474:                 // Section: UART Peripheral Library Interface Routines
475:                 // *****************************************************************************
476:                 // *****************************************************************************
477:                 
478:                 
479:                 /*******************************************************************************
480:                   Function:
481:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
482:                 
483:                   Summary:
484:                     Enables or disables the given UART module in the desired mode.
485:                 
486:                   Description:
487:                     This routine enables or disables the given UART module in the desired mode.
488:                 
489:                   Precondition:
490:                     The UART module should be appropriately configured before being enabled.
491:                 
492:                   Parameters:
493:                     id    - Identifies the desired UART module.
494:                 
495:                     mode  - Identifies the desired mode of UART operation.
496:                 
497:                   Returns:
498:                     None
499:                 
500:                   Example:
501:                     <code>
502:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
503:                     </code>
504:                 
505:                   Remarks:
506:                     Enabling UART transmissions will immediately cause a TX interrupt to
507:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
508:                     was pre-loaded with data.
509:                   *****************************************************************************/
510:                 
511:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
512:                 
513:                 
514:                 /*******************************************************************************
515:                   Function:
516:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
517:                 
518:                   Summary:
519:                     UART module configuration routine.
520:                 
521:                   Description:
522:                     This routine allows the caller to configure various features of the UART
523:                     module for desired operation.
524:                 
525:                   Precondition:
526:                     None
527:                 
528:                   Parameters:
529:                     id      - Identifies the desired UART module.
530:                 
531:                     flags   - Bit-wise OR of the desired module configuration settings.
532:                 
533:                   Returns:
534:                     None
535:                 
536:                   Example:
537:                     <code>
538:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
539:                     </code>
540:                 
541:                   Remarks:
542:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
543:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
544:                     of these values will result in a value that is not explicitly defined in
545:                     the enumeration.
546:                   *****************************************************************************/
547:                 
548:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
549:                 
550:                 
551:                 /*******************************************************************************
552:                   Function:
553:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
554:                 
555:                   Summary:
556:                     Controls UART module TX and RX FIFO operation.
557:                 
558:                   Description:
559:                     This routine allows the caller to configure when interrupts occur relative
560:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
561:                     or empty the FIFOs are).
562:                 
563:                   Precondition:
564:                     None
565:                 
566:                   Parameters:
567:                     id      - Identifies the desired UART module.
568:                 
569:                     mode    - Bit-wise OR of the desired FIFO mode values.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Example:
575:                     <code>
576:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
577:                     </code>
578:                 
579:                   Remarks:
580:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
581:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
582:                     of these values will result in a value that is not explicitly defined in
583:                     the enumeration.
584:                   *****************************************************************************/
585:                 
586:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
587:                 
588:                 
589:                 /*******************************************************************************
590:                   Function:
591:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
592:                 
593:                   Summary:
594:                     Routine to set the UART module's desired data data rate.
595:                 
596:                   Description:
597:                     This routine allows the caller to set the desired data rate for the UART.
598:                 
599:                   Precondition:
600:                     The source clock's frequency must be operating at the frequency passed in the
601:                     "sourceClock" parameter.
602:                 
603:                   Parameters:
604:                     id          - Identifies the desired UART module.
605:                 
606:                     sourceClock - Frequency (Hz) of the source clock being provided to the
607:                                   UART module.
608:                 
609:                     dataRate     - Desired data rate (bits per second).
610:                 
611:                   Returns:
612:                     Actual bit rate selected
613:                 
614:                   Example:
615:                     <code>
616:                 	#define PERIPHERAL_CLOCK    10000000
617:                 	#define DESIRED_DATA_RATE   19200
618:                 	
619:                 	UINT32    actualDataRate;
620:                 
621:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
622:                     </code>
623:                 
624:                   Remarks:
625:                     Actual data rate selected may be slightly different than the data rate
626:                     requested due to truncation error.
627:                 
628:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
629:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
630:                     the maximum data rate is sourceClock/4.
631:                   *****************************************************************************/
632:                 
633:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
634:                 
635:                 
636:                 /*******************************************************************************
637:                   Function:
638:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
639:                 
640:                   Summary:
641:                     Routine to get the UART module's current data data rate.
642:                 
643:                   Description:
644:                     This routine allows the caller to get the current data rate for the UART module.
645:                 
646:                   Precondition:
647:                     The source clock's frequency must be operating at the frequency passed in the
648:                     "sourceClock" parameter.
649:                 
650:                   Parameters:
651:                     id          - Identifies the desired UART module.
652:                 
653:                     sourceClock - Frequency (Hz) of the source clock being provided to the
654:                                   UART module.
655:                 
656:                   Returns:
657:                     The UART's current data rate (bits per second).
658:                 
659:                   Example:
660:                     <code>
661:                 	#define PERIPHERAL_CLOCK    10000000
662:                 	
663:                 	UINT32    currentDataRate;
664:                 
665:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
666:                     </code>
667:                 
668:                   Remarks:
669:                     The current (actual) data rate returned may be slightly different than bit
670:                     rate requested due to truncation error.
671:                   *****************************************************************************/
672:                 
673:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
674:                 
675:                 
676:                 /*******************************************************************************
677:                   Function:
678:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
679:                 
680:                   Summary:
681:                     Routine to set the UART module's desired line control parameters.
682:                 
683:                   Description:
684:                     This routine allows the caller to select the desired size of the UART data
685:                     frame, the generation of parity and framing parameters (collectively
686:                     referred to as the "line control" mode).
687:                 
688:                   Precondition:
689:                 
690:                   Parameters:
691:                     id      - Identifies the desired UART module.
692:                 
693:                     mode    - This is a bit-wise OR of the desired line control mode flags.
694:                 
695:                   Returns:
696:                     None
697:                 
698:                   Example:
699:                     <code>
700:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
701:                     </code>
702:                 
703:                   Remarks:
704:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
705:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
706:                     of these values will result in a value that is not explicitly defined in
707:                     the enumeration.
708:                   *****************************************************************************/
709:                 
710:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
711:                 
712:                 
713:                 /*******************************************************************************
714:                   Function:
715:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
716:                 
717:                   Summary:
718:                     Provides current UART line status.
719:                 
720:                   Description:
721:                     This routine allows the caller to get the current line status of the UART,
722:                     indicating the current state of the transmitter and receiver buffers, and
723:                     if any errors have occurred.
724:                 
725:                   Precondition:
726:                     None
727:                 
728:                   Parameters:
729:                     id      - Identifies the desired UART module.
730:                 
731:                   Returns:
732:                     A bit-wise OR of the current line status flags.
733:                 
734:                   Example:
735:                     <code>
736:                     UART_LINE_STATUS lineStatus;
737:                 	
738:                 	lineStatus = UARTGetLineStatus(UART1);
739:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
740:                     {
741:                         // Handle receiver error
742:                     }
743:                     </code>
744:                 
745:                   Remarks:
746:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
747:                     status flag.
748:                 
749:                     The receiver line status flags are only valid when data has been received
750:                     and for the data at the top of the RX FIFO.
751:                 
752:                     Note that the bitmask resulting from the bit-wise OR of these values will
753:                     result in a value that is not explicitly defined in the enumeration.
754:                   *****************************************************************************/
755:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
756:                 {
757:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
9D0090E4  3C029D01   LUI V0, -25343
9D0090E8  8FC30014   LW V1, 20(S8)
9D0090EC  00031880   SLL V1, V1, 2
9D0090F0  2442E8EC   ADDIU V0, V0, -5908
9D0090F4  00621021   ADDU V0, V1, V0
9D0090F8  8C420000   LW V0, 0(V0)
9D0090FC  8C420010   LW V0, 16(V0)
9D009100  3042031F   ANDI V0, V0, 799
758:                 }
759:                 
760:                 
761:                 /*******************************************************************************
762:                   Function:
763:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
764:                 
765:                   Summary:
766:                     Routine to detect if the transmitter is ready to accept data to transmit.
767:                 
768:                   Description:
769:                     This routine determines if the transmitter is ready to accept more data to
770:                     be transmitted.
771:                 
772:                   Precondition:
773:                     The UART module should have been appropriately configured and enabled.
774:                 
775:                   Parameters:
776:                     id      - Identifies the desired UART module.
777:                 
778:                   Returns:
779:                     Boolean identifying whether or not the transmitter is ready:
780:                     * TRUE    - If the transmitter is ready to accept more data
781:                     * FALSE   - If the transmitter is not ready to accept more data
782:                 
783:                   Example:
784:                     <code>
785:                     unsigned char data;
786:                 	
787:                 	data = 'a';
788:                 	
789:                 	if (UARTTransmitterIsReady(UART1))
790:                     {
791:                         UARTSendDataByte(UART1, data);
792:                     }
793:                     </code>
794:                 
795:                   Remarks:
796:                   *****************************************************************************/
797:                 
798:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
799:                 {
800:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D009248  3C029D01   LUI V0, -25343
9D00924C  8FC30020   LW V1, 32(S8)
9D009250  00031880   SLL V1, V1, 2
9D009254  2442E8EC   ADDIU V0, V0, -5908
9D009258  00621021   ADDU V0, V1, V0
9D00925C  8C420000   LW V0, 0(V0)
9D009260  8C420010   LW V0, 16(V0)
9D009264  30420200   ANDI V0, V0, 512
9D009268  14400004   BNE V0, ZERO, 0x9D00927C
9D00926C  00000000   NOP
9D009270  24020001   ADDIU V0, ZERO, 1
9D009274  0B4024A0   J 0x9D009280
9D009278  00000000   NOP
9D00927C  00001021   ADDU V0, ZERO, ZERO
801:                 }
802:                 
803:                 
804:                 /*******************************************************************************
805:                   Function:
806:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
807:                 
808:                   Summary:
809:                     Routine to send a byte of data.
810:                 
811:                   Description:
812:                     This routine allows the caller to send a byte of data.
813:                 
814:                   Precondition:
815:                     The UART should have been appropriately configured.  The configuration must
816:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
817:                     have been ready, although not necessarily enabled yet.
818:                 
819:                   Parameters:
820:                     id      - Identifies the desired UART module.
821:                 
822:                     data    - Data byte to be sent.
823:                 
824:                   Returns:
825:                     None
826:                 
827:                   Example:
828:                     <code>
829:                 	unsigned char data;
830:                 	
831:                 	data = 'a';
832:                 	
833:                     if (UARTTransmitterIsReady(UART1))
834:                     {
835:                         UARTSendDataByte(UART1, data);
836:                     }
837:                     </code>
838:                 
839:                   Remarks:
840:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
841:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
842:                     data.
843:                   *****************************************************************************/
844:                 
845:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
846:                 {
847:                     uartReg[id]->tx.reg = data;
9D008FB4  3C029D01   LUI V0, -25343
9D008FB8  8FC30010   LW V1, 16(S8)
9D008FBC  00031880   SLL V1, V1, 2
9D008FC0  2442E8EC   ADDIU V0, V0, -5908
9D008FC4  00621021   ADDU V0, V1, V0
9D008FC8  8C420000   LW V0, 0(V0)
9D008FCC  93C30014   LBU V1, 20(S8)
9D008FD0  AC430020   SW V1, 32(V0)
9D009350  3C029D01   LUI V0, -25343
9D009354  8FC30028   LW V1, 40(S8)
9D009358  00031880   SLL V1, V1, 2
9D00935C  2442E8EC   ADDIU V0, V0, -5908
9D009360  00621021   ADDU V0, V1, V0
9D009364  8C420000   LW V0, 0(V0)
9D009368  93C3002C   LBU V1, 44(S8)
9D00936C  AC430020   SW V1, 32(V0)
848:                 }
849:                 
850:                 
851:                 /*******************************************************************************
852:                   Function:
853:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
854:                 
855:                   Summary:
856:                     Routine to send data through the UART.
857:                 
858:                   Description:
859:                     This routine allows the caller to send data of any permitted size through
860:                     the UART.
861:                 
862:                   Precondition:
863:                     The UART module should have been appropriately configured.  The configuration must
864:                     have been for desired data size.  The transmitter must have been ready,
865:                     although not necessarily enabled yet.
866:                 
867:                   Parameters:
868:                     id      - Identifies the desired UART module.
869:                 
870:                     data    - Data to be sent.
871:                 
872:                   Returns:
873:                     None
874:                 
875:                   Example:
876:                     <code>
877:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
878:                 	
879:                 	if (UARTTransmitterIsReady(UART1))
880:                     {
881:                         UARTSendData(UART1, data);
882:                     }
883:                     </code>
884:                 
885:                   Remarks:
886:                     Size of the data word size depends on the current configuration (see
887:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
888:                   *****************************************************************************/
889:                 
890:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
891:                 {
892:                     uartReg[id]->tx.reg = data.__data;
893:                 }
894:                 
895:                 /*******************************************************************************
896:                   Function:
897:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
898:                 
899:                   Summary:
900:                     Routine to detect if the UART module has finshed transmitting the most recent
901:                     data.
902:                 
903:                   Description:
904:                     This routine determines if the transmitter has finished sending all
905:                     available data.
906:                 
907:                   Preconditions:
908:                     The UART module should have been appropriately configured and enabled and data
909:                     sent to the UART TX buffer.
910:                 
911:                   Parameters:
912:                     id      - Identifies the desired UART module.
913:                 
914:                   Returns:
915:                     Boolean identifying if the transmission has completed:
916:                     * TRUE    - If the transmitter has completed sending the data
917:                     * FALSE   - If the transmitter is still busy sending the data
918:                 
919:                   Example:
920:                     <code>
921:                 	if (UARTTransmissionHasCompleted(UART1))
922:                     {
923:                         // Perform any tasks necessary when all data has been sent
924:                     }
925:                     </code>
926:                 
927:                   Remarks:
928:                   *****************************************************************************/
929:                 
930:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
931:                 {
932:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D008E9C  3C029D01   LUI V0, -25343
9D008EA0  8FC30014   LW V1, 20(S8)
9D008EA4  00031880   SLL V1, V1, 2
9D008EA8  2442E8EC   ADDIU V0, V0, -5908
9D008EAC  00621021   ADDU V0, V1, V0
9D008EB0  8C420000   LW V0, 0(V0)
9D008EB4  8C420010   LW V0, 16(V0)
9D008EB8  30420100   ANDI V0, V0, 256
9D008EBC  10400004   BEQ V0, ZERO, 0x9D008ED0
9D008EC0  00000000   NOP
9D008EC4  24020001   ADDIU V0, ZERO, 1
9D008EC8  0B4023B5   J 0x9D008ED4
9D008ECC  00000000   NOP
9D008ED0  00001021   ADDU V0, ZERO, ZERO
9D0092A8  3C029D01   LUI V0, -25343
9D0092AC  8FC30024   LW V1, 36(S8)
9D0092B0  00031880   SLL V1, V1, 2
9D0092B4  2442E8EC   ADDIU V0, V0, -5908
9D0092B8  00621021   ADDU V0, V1, V0
9D0092BC  8C420000   LW V0, 0(V0)
9D0092C0  8C420010   LW V0, 16(V0)
933:                 }
934:                 
935:                 
936:                 /*******************************************************************************
937:                   Function:
938:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
939:                 
940:                   Summary:
941:                     Routine to detect if the receiver has data available.
942:                 
943:                   Description:
944:                     This routine determines if the receiver has data available to be read.
945:                 
946:                   Precondition:
947:                     The UART module must have been configured appropriately and enabled. A complete
948:                     data frame must have been sent to the UART before it will return a TRUE.
949:                 
950:                   Parameters:
951:                     id      - Identifies the desired UART module.
952:                 
953:                   Returns:
954:                     Boolean identifying whether or not data is available:
955:                     * TRUE    - If the receiver has data available
956:                     * FALSE   - If the receiver does not have data availble
957:                 
958:                   Example:
959:                     <code>
960:                     UART_DATA data;
961:                 	
962:                 	if (UARTReceivedDataIsAvailable(UART1))
963:                     {
964:                         data = UARTGetData(UART1);
965:                     }
966:                     </code>
967:                 
968:                   Remarks:
969:                     This routine provides the same information as the UART_DATA_READY line
970:                     status flag.
971:                   *****************************************************************************/
972:                 
973:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
974:                 {
975:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D009148  3C029D01   LUI V0, -25343
9D00914C  8FC30018   LW V1, 24(S8)
9D009150  00031880   SLL V1, V1, 2
9D009154  2442E8EC   ADDIU V0, V0, -5908
9D009158  00621021   ADDU V0, V1, V0
9D00915C  8C420000   LW V0, 0(V0)
9D009160  8C420010   LW V0, 16(V0)
9D009164  30420001   ANDI V0, V0, 1
976:                 }
977:                 
978:                 
979:                 /*******************************************************************************
980:                   Function:
981:                     BYTE UARTGetDataByte ( UART_MODULE id )
982:                 
983:                   Summary:
984:                     Routine to get a byte of data received by the UART.
985:                 
986:                   Description:
987:                     This routine allows the caller to read a byte of data received by the UART.
988:                 
989:                   Precondition:
990:                     The UART module must have been appropriately configured, the configuration must
991:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
992:                     been enabled.  Also, a complete data frame must have been received by the UART.
993:                 
994:                   Parameters:
995:                     id      - Identifies the desired UART module.
996:                 
997:                   Returns:
998:                     A byte of data received by the UART.
999:                 
1000:                  Example:
1001:                    <code>
1002:                    unsigned char data;
1003:                	
1004:                	if (UARTReceivedDataIsAvailable(UART1))
1005:                    {
1006:                        data = UARTGetDataByte(UART1);
1007:                    }
1008:                    </code>
1009:                
1010:                  Remarks:
1011:                    This routine is optimized for receiving 8-bit data through the UART.
1012:                  *****************************************************************************/
1013:                
1014:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1015:                {
1016:                    return (BYTE)uartReg[id]->rx.reg;
9D00918C  3C029D01   LUI V0, -25343
9D009190  8FC3001C   LW V1, 28(S8)
9D009194  00031880   SLL V1, V1, 2
9D009198  2442E8EC   ADDIU V0, V0, -5908
9D00919C  00621021   ADDU V0, V1, V0
9D0091A0  8C420000   LW V0, 0(V0)
9D0091A4  8C420030   LW V0, 48(V0)
9D0091A8  304200FF   ANDI V0, V0, 255
1017:                }
1018:                
1019:                
1020:                /*******************************************************************************
1021:                  Function:
1022:                    UART_DATA UARTGetData ( UART_MODULE id )
1023:                
1024:                  Summary:
1025:                    Routine to get data received by the UART.
1026:                
1027:                  Description:
1028:                    This routine allows the caller to read a data word received by the UART.
1029:                
1030:                  Precondition:
1031:                    The module must have been appropriately configured, the UART module must have been
1032:                    enabled, and a complete data frame must have been received by the UART.
1033:                
1034:                  Parameters:
1035:                    id      - Identifies the desired UART module.
1036:                
1037:                  Returns:
1038:                    Data received by the UART.
1039:                
1040:                  Example:
1041:                    <code>
1042:                    UART_DATA data;
1043:                	
1044:                	if (UARTReceivedDataIsAvailable(UART1))
1045:                    {
1046:                        data = UARTGetData(UART1);
1047:                    }
1048:                    </code>
1049:                
1050:                  Remarks:
1051:                    Size of the data word depends on the current configuration (see
1052:                    UARTSetLineControl).
1053:                  *****************************************************************************/
1054:                
1055:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1056:                {
1057:                    UART_DATA data;
1058:                
1059:                    data.__data = uartReg[id]->rx.reg;
1060:                
1061:                    return data;
1062:                }
1063:                
1064:                
1065:                /*******************************************************************************
1066:                  Function:
1067:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1068:                
1069:                  Summary:
1070:                    Routine to program the address for which the UART module may watch.
1071:                
1072:                  Description:
1073:                    This routine programs the 8-bit address for which the module may watch.
1074:                
1075:                  Precondition:
1076:                    None
1077:                
1078:                  Parameters:
1079:                    id      - Identifies the desired UART module.
1080:                
1081:                    address - 8-bit address for which the module will watch.
1082:                
1083:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1084:                              * TRUE - Enable address watch mode
1085:                              * FALSE - Disable address watch mode
1086:                
1087:                  Returns:
1088:                    None.
1089:                
1090:                  Example:
1091:                    <code>
1092:                    #define SLAVE_ADDRESS  0x42
1093:                	
1094:                	UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1095:                    </code>
1096:                
1097:                  Remarks:
1098:                    The module can be placed into a mode where it will ignore all data received
1099:                    until it identifies the programmed adress.  After the programmed address
1100:                    has been identified, it will begin receiving data normally.  This mode is
1101:                    particularly useful for supporting the IEEE-485 protocol.
1102:                  *****************************************************************************/
1103:                
1104:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1105:                
1106:                
1107:                /*******************************************************************************
1108:                  Function:
1109:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1110:                
1111:                  Summary:
1112:                    Routine to enable or disable recognition of the programmed address byte.
1113:                
1114:                  Description:
1115:                    This routine can enable or disable the "address watch" mode.  In this mode,
1116:                    the UART module will ignore all data until it recognizes the programmed address.
1117:                
1118:                  Precondition:
1119:                    UART should have already been enabled and set with watch address.
1120:                
1121:                  Parameters:
1122:                    id      - Identifies the desired UART module.
1123:                
1124:                    watch   - Determines if the "address watch" mode will be enabled or
1125:                              disabled.
1126:                              * TRUE - Enable address watch mode
1127:                              * FALSE - Disable address watch mode
1128:                
1129:                  Returns:
1130:                    None.
1131:                
1132:                  Example:
1133:                    <code>
1134:                    #define SLAVE_ADDRESS 0x42
1135:                	
1136:                	// Set the address, but don't enable the watch until later,
1137:                	// UART continues to receive data normally
1138:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1139:                
1140:                    // ...
1141:                
1142:                    // Now begin to ignore all UART traffic until we are addressed
1143:                    UARTWatchForAddress(UART1, TRUE);
1144:                    </code>
1145:                
1146:                  Remarks:
1147:                    The UART module can be placed into a mode where it will ignore all data received
1148:                    until it identifies the programmed address.  After the programmed address
1149:                    has been identified, it will begin receiving data normally.  This mode is
1150:                    particularly useful for supporting the IEEE-485 protocol.
1151:                  *****************************************************************************/
1152:                
1153:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1154:                
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    void UARTSendBreak ( UART_MODULE id )
1159:                
1160:                  Summary:
1161:                    Routine to send a break signal from the UART.
1162:                
1163:                  Description:
1164:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1165:                
1166:                  Precondition:
1167:                    The UART should have been appropriately configured.  The transmitter should
1168:                    be idle, although not necessarily enabled yet.
1169:                
1170:                  Parameters:
1171:                    id      - Identifies the desired UART module.
1172:                
1173:                  Returns:
1174:                    None
1175:                
1176:                  Example:
1177:                    <code>
1178:                    if (UARTTransmissionHasCompleted(UART1))
1179:                    {
1180:                        UARTSendBreak(UART1);
1181:                    }
1182:                    </code>
1183:                
1184:                  Remarks:
1185:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1186:                    data may be pre-loaded into the FIFO and it will be send immediately
1187:                    following the break signal.
1188:                  *****************************************************************************/
1189:                
1190:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1191:                {
1192:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1193:                }
1194:                
1195:                
1196:                /*******************************************************************************
1197:                  Function:
1198:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1199:                
1200:                  Summary:
1201:                    Routine to automatically determine the data rate (bits-per-second) of an
1202:                    external transmitter to the UART.
1203:                
1204:                  Description:
1205:                    This routine initiates the process of automatically determining the data
1206:                    rate (bits-per-second) of an external transmitter to the UART.
1207:                
1208:                  Precondition:
1209:                    The UART should have been appropriately configured.  The transmitter should
1210:                    be idle, although not necessarily enabled yet.
1211:                
1212:                  Parameters:
1213:                    id      - Identifies the desired UART module.
1214:                
1215:                  Returns:
1216:                    None
1217:                
1218:                  Example:
1219:                    <code>
1220:                	// See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1221:                	// methods to detect a Break.
1222:                	
1223:                    if (breakDetected && useAutoRateDetect) 
1224:                    {
1225:                        UARTStartAutoDataRateDetect (UART1);
1226:                    }
1227:                    </code>
1228:                
1229:                  Remarks:
1230:                    The UART module begins measuring the data rate beginning at the next start
1231:                    bit.  The external transmitter should send an alternating pattern (0x55)
1232:                    for the byte to be measured for an effective rate detection.  To ensure
1233:                    an effective measurement sequence, this can be done immediately following
1234:                    a break reception. It is important that this UART module is not
1235:                	transmitting data while it is trying to detect RX baud rate, see the 
1236:                	"PIC32 Family Reference Manual, Sect. 21 UART".
1237:                  *****************************************************************************/
1238:                
1239:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1240:                {
1241:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1242:                }
1243:                
1244:                
1245:                
1246:                /*******************************************************************************
1247:                  Function:
1248:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1249:                
1250:                  Summary:
1251:                    Routine to identify when automatic data rate detection has completed.
1252:                
1253:                  Description:
1254:                    This routine checks to see if automatic data rate detection has completed.
1255:                
1256:                  Precondition:
1257:                    Automatic rate detection should have been previously started.
1258:                
1259:                  Parameters:
1260:                    id      - Identifies the desired UART module.
1261:                
1262:                  Returns:
1263:                    * TRUE    - Indicates that automatic rate detection has completed.
1264:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1265:                
1266:                  Example:
1267:                    <code>
1268:                    #define PERIPHERAL_CLOCK    10000000
1269:                	
1270:                	UINT32 currentRate;
1271:                	
1272:                	if (UARTDataRateDetected(UART1))
1273:                    {
1274:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1275:                    }
1276:                    </code>
1277:                
1278:                  Remarks:
1279:                    This routine returns FALSE after automatic rate detection
1280:                    has been started but before rate is detectdd, it will return TRUE
1281:                	at any other time.
1282:                  *****************************************************************************/
1283:                
1284:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1285:                {
1286:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1287:                }
1288:                
1289:                #ifdef __cplusplus
1290:                  }
1291:                #endif
1292:                
1293:                #endif // _UART_h_
1294:                
---  c:/program files/microchip/xc32/v1.20/pic32mx/include/peripheral/system.h  -------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0081A0  8FC20028   LW V0, 40(S8)
9D0081A4  AFC2002C   SW V0, 44(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0081A8  8FC30028   LW V1, 40(S8)
9D0081AC  3C0204C4   LUI V0, 1220
9D0081B0  3442B401   ORI V0, V0, -19455
9D0081B4  0062102B   SLTU V0, V1, V0
9D0081B8  14400008   BNE V0, ZERO, 0x9D0081DC
9D0081BC  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D0081C0  3C020008   LUI V0, 8
9D0081C4  AFC20030   SW V0, 48(S8)
118:                         pb_clock >>= 1;
9D0081C8  8FC2002C   LW V0, 44(S8)
9D0081CC  00021042   SRL V0, V0, 1
9D0081D0  AFC2002C   SW V0, 44(S8)
9D0081D4  0B402078   J 0x9D0081E0
9D0081D8  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D0081DC  AFC00030   SW ZERO, 48(S8)
9D0081E0  8FC20030   LW V0, 48(S8)
9D0081E4  AFC20034   SW V0, 52(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
9D008120  AFC00020   SW ZERO, 32(S8)
9D008124  0B402053   J 0x9D00814C
9D008128  00000000   NOP
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
9D00814C  8FC3001C   LW V1, 28(S8)
9D008150  3C0201C9   LUI V0, 457
9D008154  3442C381   ORI V0, V0, -15487
9D008158  0062102B   SLTU V0, V1, V0
9D00815C  1040FFF3   BEQ V0, ZERO, 0x9D00812C
9D008160  00000000   NOP
170:                     {
171:                         wait_states++;
9D00812C  8FC20020   LW V0, 32(S8)
9D008130  24420001   ADDIU V0, V0, 1
9D008134  AFC20020   SW V0, 32(S8)
172:                         sys_clock -= FLASH_SPEED_HZ;
9D008138  8FC3001C   LW V1, 28(S8)
9D00813C  3C02FE36   LUI V0, -458
9D008140  34423C80   ORI V0, V0, 15488
9D008144  00621021   ADDU V0, V1, V0
9D008148  AFC2001C   SW V0, 28(S8)
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
9D008164  0F403A39   JAL INTDisableInterrupts
9D008168  00000000   NOP
9D00816C  AFC20024   SW V0, 36(S8)
176:                     mCheConfigure(wait_states);
9D008170  3C02BF88   LUI V0, -16504
9D008174  8FC30020   LW V1, 32(S8)
9D008178  AC434000   SW V1, 16384(V0)
177:                     INTRestoreInterrupts(int_status);
9D00817C  8FC40024   LW A0, 36(S8)
9D008180  0F4039B2   JAL INTRestoreInterrupts
9D008184  00000000   NOP
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D0080EC  0F403A39   JAL INTDisableInterrupts
9D0080F0  00000000   NOP
9D0080F4  AFC20018   SW V0, 24(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D0080F8  3C02BF88   LUI V0, -16504
9D0080FC  24030040   ADDIU V1, ZERO, 64
9D008100  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D008104  8FC20014   LW V0, 20(S8)
9D008108  30420001   ANDI V0, V0, 1
9D00810C  304200FF   ANDI V0, V0, 255
9D008110  1040001D   BEQ V0, ZERO, 0x9D008188
9D008114  00000000   NOP
9D008118  8FC20010   LW V0, 16(S8)
9D00811C  AFC2001C   SW V0, 28(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D008188  8FC20014   LW V0, 20(S8)
9D00818C  30420002   ANDI V0, V0, 2
9D008190  10400068   BEQ V0, ZERO, 0x9D008334
9D008194  00000000   NOP
9D008198  8FC20010   LW V0, 16(S8)
9D00819C  AFC20028   SW V0, 40(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
9D008334  8FC20014   LW V0, 20(S8)
9D008338  30420004   ANDI V0, V0, 4
9D00833C  1040000C   BEQ V0, ZERO, 0x9D008370
9D008340  00000000   NOP
358:                     {
359:                         cache_status = mCheGetCon();
9D008344  3C02BF88   LUI V0, -16504
9D008348  8C424000   LW V0, 16384(V0)
9D00834C  AFC2004C   SW V0, 76(S8)
360:                         cache_status |= CHE_CONF_PF_ALL;
9D008350  8FC2004C   LW V0, 76(S8)
9D008354  34420030   ORI V0, V0, 48
9D008358  AFC2004C   SW V0, 76(S8)
361:                         mCheConfigure(cache_status);
9D00835C  3C02BF88   LUI V0, -16504
9D008360  8FC3004C   LW V1, 76(S8)
9D008364  AC434000   SW V1, 16384(V0)
362:                         CheKseg0CacheOn();
9D008368  0F4039D4   JAL CheKseg0CacheOn
9D00836C  00000000   NOP
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D008370  8FC20010   LW V0, 16(S8)
9D008374  AFC20050   SW V0, 80(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D008378  3C02BF81   LUI V0, -16511
9D00837C  8C42F000   LW V0, -4096(V0)
9D008380  7C420CC0   EXT V0, V0, 19, 2
9D008384  304200FF   ANDI V0, V0, 255
9D008388  8FC30050   LW V1, 80(S8)
9D00838C  00431006   SRLV V0, V1, V0
9D008390  AFC20050   SW V0, 80(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D008394  8FC40018   LW A0, 24(S8)
9D008398  0F4039B2   JAL INTRestoreInterrupts
9D00839C  00000000   NOP
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  c:/program files/microchip/xc32/v1.20/pic32mx/include/peripheral/osc.h  ----------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the “Company”) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company’s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION ),
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D0081E8  0F403A39   JAL INTDisableInterrupts
9D0081EC  00000000   NOP
9D0081F0  AFC20038   SW V0, 56(S8)
9D008238  AFC20040   SW V0, 64(S8)
9D00823C  3C02BF81   LUI V0, -16511
9D008240  AC40F230   SW ZERO, -3536(V0)
9D008244  3C02BF81   LUI V0, -16511
9D008248  3C03AA99   LUI V1, -21863
9D00824C  34636655   ORI V1, V1, 26197
9D008250  AC43F230   SW V1, -3536(V0)
9D008254  3C02BF81   LUI V0, -16511
9D008258  3C035566   LUI V1, 21862
9D00825C  346399AA   ORI V1, V1, -26198
9D008260  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D008264  3C02BF81   LUI V0, -16511
9D008268  8C42F000   LW V0, -4096(V0)
9D00826C  AFC20054   SW V0, 84(S8)
178:                 	oscBits.PBDIV=0;
9D008270  8FC20054   LW V0, 84(S8)
9D008274  7C02A4C4   INS V0, ZERO, 19, 2
9D008278  AFC20054   SW V0, 84(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D00827C  8FC30054   LW V1, 84(S8)
9D008280  8FC20034   LW V0, 52(S8)
9D008284  00621025   OR V0, V1, V0
9D008288  AFC20054   SW V0, 84(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D00828C  8FC30054   LW V1, 84(S8)
9D008290  3C02BF81   LUI V0, -16511
9D008294  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D008298  3C02BF81   LUI V0, -16511
9D00829C  8C42F000   LW V0, -4096(V0)
9D0082A0  AFC20054   SW V0, 84(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D0082A4  3C02BF81   LUI V0, -16511
9D0082A8  3C033333   LUI V1, 13107
9D0082AC  34633333   ORI V1, V1, 13107
9D0082B0  AC43F230   SW V1, -3536(V0)
9D0082B4  8FC20040   LW V0, 64(S8)
9D0082B8  AFC20044   SW V0, 68(S8)
9D008328  8FC40038   LW A0, 56(S8)
9D00832C  0F4039B2   JAL INTRestoreInterrupts
9D008330  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  c:/program files/microchip/xc32/v1.20/pic32mx/include/peripheral/dma_3xx_4xx.h  --------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the “Company”) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company’s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,                           // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 
144:                 	/*********************************************************************
145:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
146:                 	 *
147:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
148:                 	 *
149:                 	 * Input:           chn    - channel to be configured in the DMA controller
150:                 	 *                  chPri  - the priority given to the channel, 0-3
151:                 	 *                  oFlags - orred flags specifying the open mode:
152:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
153:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
154:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
155:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
156:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
157:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
158:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
159:                 	 *
160:                 	 *
161:                 	 *
162:                 	 * Output:          None
163:                 	 *
164:                 	 * Side Effects:    None
165:                 	 *
166:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
167:                 	 *
168:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
169:                 	 *                  Use the low level functions to address special settings.
170:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
171:                 	 *                  After that the channel is configured.
172:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
173:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
174:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
175:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
176:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
177:                 	 *                  User has to call event channel functions to enable the event flags if needed.
178:                 	 *
179:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
180:                 	 ********************************************************************/
181:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
182:                 
183:                 	/*********************************************************************
184:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
185:                 	 *
186:                 	 * PreCondition:    None
187:                 	 *
188:                 	 * Input:			chn		- channel to be enabled
189:                 	 *
190:                 	 * Output:          None
191:                 	 *
192:                 	 * Side Effects:    None
193:                 	 *
194:                 	 * Overview:		The function enables a previously configured DMA channel.
195:                 	 *
196:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
197:                 	 *
198:                 	 * Example:			DmaChnEnable(DMA_CHANNEL2);
199:                 	 ********************************************************************/
200:                 	 void			DmaChnEnable(DmaChannel chn);
201:                 
202:                 	/*********************************************************************
203:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
204:                 	 *
205:                 	 * PreCondition:    None
206:                 	 *
207:                 	 * Input:			chn		- selected channel in the DMA controller
208:                 	 *
209:                 	 * Output:          None
210:                 	 *
211:                 	 * Side Effects:    None
212:                 	 *
213:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
214:                 	 *
215:                 	 * Note:            None.
216:                 	 *
217:                 	 * Example:			DmaChnDisable(DMA_CHANNEL2);
218:                 	 ********************************************************************/
219:                 	 void			DmaChnDisable(DmaChannel chn);
220:                 
221:                 	/*********************************************************************
222:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
223:                 	 *
224:                 	 * PreCondition:    chn		- valid DMA channel
225:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
226:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
227:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
228:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
229:                 	 *
230:                 	 * Input:			chn			- DMA channel number
231:                 	 * 								- vSrcAdd: source of the DMA transfer
232:                 	 * 								- vDstAdd: destination of the DMA transfer
233:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
234:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
235:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
236:                 	 *
237:                 	 * Output:          None
238:                 	 *
239:                 	 * Side Effects:    None
240:                 	 *
241:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
242:                 	 * 					the source and the destination addresses.
243:                 	 * 					the source and destination lengths
244:                 	 * 					and the number of bytes	transferred per event.
245:                 	 *
246:                 	 * Note:			The function clears the existing DMA channel event flags.
247:                 	 *
248:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL2, &U2RXREG, dstBuff, 1, 200, 1);
249:                 	 ********************************************************************/
250:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
251:                 
252:                 
253:                 	/*********************************************************************
254:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
255:                 	 *
256:                 	 * PreCondition:    chn		- valid DMA channel
257:                 	 *
258:                 	 * Input:           chn		- DMA channel number
259:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
260:                 	 * Output:          None
261:                 	 *
262:                 	 * Side Effects:    None
263:                 	 *
264:                 	 * Overview:        The function is a helper to set directly the transfer source address.
265:                 	 *
266:                 	 * Note:            None.
267:                 	 *
268:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
269:                 	 ********************************************************************/
270:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
271:                 
272:                 	/*********************************************************************
273:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
274:                 	 *
275:                 	 * PreCondition:    chn		- valid DMA channel
276:                 	 *
277:                 	 * Input:			chn			- DMA channel number
278:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
279:                 	 * Output:          None
280:                 	 *
281:                 	 * Side Effects:    None
282:                 	 *
283:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
284:                 	 *
285:                 	 * Note:            None
286:                 	 *
287:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
288:                 	 ********************************************************************/
289:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
290:                 
291:                 	/*********************************************************************
292:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
293:                 	 *
294:                 	 * PreCondition:    chn	- valid DMA channel
295:                 	 *
296:                 	 * Input:			chn		- DMA channel number
297:                 	 * 					pattern	-  the match pattern
298:                 	 *
299:                 	 * Output:          None
300:                 	 *
301:                 	 * Side Effects:    None
302:                 	 *
303:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
304:                 	 *
305:                 	 * Note:            None.
306:                 	 *
307:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL2, '\r');
308:                 	 ********************************************************************/
309:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
310:                 
311:                 	/*********************************************************************
312:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
313:                 	 *
314:                 	 * PreCondition:    chn	- valid DMA channel
315:                 	 *
316:                 	 * Input:			chn		- DMA channel number
317:                 	 *
318:                 	 * Output:          The channel match pattern.
319:                 	 *
320:                 	 * Side Effects:    None
321:                 	 *
322:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
323:                 	 *
324:                 	 * Note:            None.
325:                 	 *
326:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL2);
327:                 	 ********************************************************************/
328:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
329:                 
330:                 	/*********************************************************************
331:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
332:                 	 *
333:                 	 * PreCondition:    chn	- valid DMA channel
334:                 	 *
335:                 	 * Input:			chn		- DMA channel number
336:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
337:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
338:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
339:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
340:                 	 * 								If 0, wait forever.
341:                 	 *
342:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
343:                 	 * 					an DmaTxferRes error code  otherwise
344:                 	 *
345:                 	 * Side Effects:    None
346:                 	 *
347:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
348:                 	 * 					The DMA channel is enabled.
349:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
350:                 	 * 					this event) the function will periodically query the DMA controller for the
351:                 	 * 					transfer completion status.
352:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
353:                      * 					the block transfer than the function will re-force the transfer for each cell.
354:                 	 *
355:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
356:                      *                  by hardware interrupt requests.
357:                      *                  This is because the transfers are software forced, theere is no
358:                      *                  wait for the occurrence of the hardware trigger. 
359:                 	 *
360:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
361:                 	 ********************************************************************/
362:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
363:                 
364:                 	/*********************************************************************
365:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
366:                 	 *
367:                 	 * PreCondition:    chn	- valid DMA channel
368:                 	 *
369:                 	 * Input:			chn		- DMA channel number
370:                 	 *
371:                 	 * Output:          None
372:                 	 *
373:                 	 * Side Effects:    None
374:                 	 *
375:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
376:                 	 *
377:                 	 * Note:            None.
378:                 	 *
379:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL2);
380:                 	 ********************************************************************/
381:                 	 void			DmaChnForceTxfer(DmaChannel chn);
382:                 
383:                 	/*********************************************************************
384:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
385:                 	 *
386:                 	 * PreCondition:    chn	- valid DMA channel
387:                 	 *
388:                 	 * Input:			chn		- DMA channel number
389:                 	 *
390:                 	 * Output:          None
391:                 	 *
392:                 	 * Side Effects:    None
393:                 	 *
394:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
395:                 	 *
396:                 	 * Note:            None.
397:                 	 *
398:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL2);
399:                 	 ********************************************************************/
400:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
401:                 
402:                 	// High level channel event and interrupt control functions
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 * 					eFlags	- event flags with the following significance:
411:                 	 * 								- DMA_EV_ERR: address error event
412:                 	 * 								- DMA_EV_ABORT: transfer abort event
413:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
414:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
415:                 	 * 								- DMA_EV_DST_HALF: destination half event
416:                 	 * 								- DMA_EV_DST_FULL: destination full event
417:                 	 * 								- DMA_EV_SRC_HALF: source half event
418:                 	 * 								- DMA_EV_SRC_FULL: source full event
419:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
420:                 	 *
421:                 	 * Output:          None
422:                 	 *
423:                 	 * Side Effects:    None
424:                 	 *
425:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
426:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
427:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
428:                 	 *
429:                 	 * Note:            None.
430:                 	 *
431:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
432:                 	 ********************************************************************/
433:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
434:                 
435:                 	/*********************************************************************
436:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                 	 *
438:                 	 * PreCondition:    chn	- valid DMA channel
439:                 	 *
440:                 	 * Input:			chn		- DMA channel number
441:                 	 * 					eFlags	- event flags with the following significance:
442:                 	 * 								- DMA_EV_ERR: address error event
443:                 	 * 								- DMA_EV_ABORT: transfer abort event
444:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
445:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
446:                 	 * 								- DMA_EV_DST_HALF: destination half event
447:                 	 * 								- DMA_EV_DST_FULL: destination full event
448:                 	 * 								- DMA_EV_SRC_HALF: source half event
449:                 	 * 								- DMA_EV_SRC_FULL: source full event
450:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
451:                 	 *
452:                 	 * Output:          None
453:                 	 *
454:                 	 * Side Effects:    None
455:                 	 *
456:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
457:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
459:                 	 *
460:                 	 * Note:            None.
461:                 	 *
462:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                 	 ********************************************************************/
464:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                 	/*********************************************************************
467:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                 	 *
469:                 	 * PreCondition:    chn	- valid DMA channel
470:                 	 *
471:                 	 * Input:			chn		- DMA channel number
472:                 	 * 					eFlags	- event flags with the following significance:
473:                 	 * 								- DMA_EV_ERR: address error event
474:                 	 * 								- DMA_EV_ABORT: transfer abort event
475:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
476:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
477:                 	 * 								- DMA_EV_DST_HALF: destination half event
478:                 	 * 								- DMA_EV_DST_FULL: destination full event
479:                 	 * 								- DMA_EV_SRC_HALF: source half event
480:                 	 * 								- DMA_EV_SRC_FULL: source full event
481:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
482:                 	 *
483:                 	 * Output:          None
484:                 	 *
485:                 	 * Side Effects:    None
486:                 	 *
487:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
488:                 	 * 					The channel event flags are forced to the eFlags value.
489:                 	 *
490:                 	 * Note:            None.
491:                 	 *
492:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
493:                 	 ********************************************************************/
494:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
495:                 
496:                 	/*********************************************************************
497:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
498:                 	 *
499:                 	 * PreCondition:    chn	- valid DMA channel
500:                 	 *
501:                 	 * Input:			chn		- DMA channel number
502:                 	 *
503:                 	 * Output:          - event flags with the following significance:
504:                 	 * 						- DMA_EV_ERR: address error event
505:                 	 * 						- DMA_EV_ABORT: transfer abort event
506:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
507:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
508:                 	 * 						- DMA_EV_DST_HALF: destination half event
509:                 	 * 						- DMA_EV_DST_FULL: destination full event
510:                 	 * 						- DMA_EV_SRC_HALF: source half event
511:                 	 * 						- DMA_EV_SRC_FULL: source full event
512:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
513:                 	 *
514:                 	 * Side Effects:    None
515:                 	 *
516:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
517:                 	 *
518:                 	 * Note:            None.
519:                 	 *
520:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL2);
521:                 	 ********************************************************************/
522:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
523:                 
524:                 	/*********************************************************************
525:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
526:                 	 *
527:                 	 * PreCondition:    chn	- valid DMA channel
528:                 	 *
529:                 	 * Input:			chn		- DMA channel number
530:                 	 * 					eFlags	- event flags with the following significance:
531:                 	 * 								- DMA_EV_ERR: address error event
532:                 	 * 								- DMA_EV_ABORT: transfer abort event
533:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
534:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
535:                 	 * 								- DMA_EV_DST_HALF: destination half event
536:                 	 * 								- DMA_EV_DST_FULL: destination full event
537:                 	 * 								- DMA_EV_SRC_HALF: source half event
538:                 	 * 								- DMA_EV_SRC_FULL: source full event
539:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
540:                 	 *
541:                 	 * Output:          None
542:                 	 *
543:                 	 * Side Effects:    None
544:                 	 *
545:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
546:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
547:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
548:                 	 *
549:                 	 * Note:            None.
550:                 	 *
551:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
552:                 	 ********************************************************************/
553:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
554:                 
555:                 	/*********************************************************************
556:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
557:                 	 *
558:                 	 * PreCondition:    chn	- valid DMA channel
559:                 	 *
560:                 	 * Input:			chn		- DMA channel number
561:                 	 *
562:                 	 * Output:          event flags with the following significance:
563:                 	 * 						- DMA_EV_ERR: address error event
564:                 	 * 						- DMA_EV_ABORT: transfer abort event
565:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
566:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
567:                 	 * 						- DMA_EV_DST_HALF: destination half event
568:                 	 * 						- DMA_EV_DST_FULL: destination full event
569:                 	 * 						- DMA_EV_SRC_HALF: source half event
570:                 	 * 						- DMA_EV_SRC_FULL: source full event
571:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
572:                 	 *
573:                 	 * Side Effects:    None
574:                 	 *
575:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
576:                 	 *
577:                 	 * Note:            None.
578:                 	 *
579:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL2);
580:                 	 ********************************************************************/
581:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
582:                 
583:                 
584:                 	// high level helpers for fast strcpy/memcpy transfers
585:                 
586:                 	/*********************************************************************
587:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
588:                 	 *
589:                 	 * PreCondition:    chn		- a valid DMA channel
590:                 	 * 					s1, s2	- valid memory pointers
591:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
592:                 	 *
593:                 	 * Input:			s1		- destination pointer
594:                 	 * 					s2		- source pointer
595:                 	 * 					n		- number of bytes to transfer
596:                 	 * 					chn		- the DMA channel to perform the transfer
597:                 	 * 					chPri	- the desired channel priority
598:                 	 *
599:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
600:                 	 * 					an DmaTxferRes error code  otherwise
601:                 	 *
602:                 	 * Side Effects:    None
603:                 	 *
604:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
605:                 	 * 			Then it copies one block of memory from source to destination.
606:                 	 *
607:                 	 *
608:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
609:                 	 * 						This way, the transfer will occur correctly together with CRC calculation.
610:                 	 * 					- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
611:                 	 * 					- Multiple channels could be opened to perform fast memory transfers, if necessary.
612:                 	 * 					- The function clears the suspend state and resumes the operation of the DMA controller.
613:                 	 *
614:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL2, DMA_CHN_PRI3);
615:                  	 ********************************************************************/
616:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
617:                 
618:                 	/*********************************************************************
619:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
620:                 	 *
621:                 	 * PreCondition:    chn		- a valid DMA channel
622:                 	 * 					s1, s2	- valid memory pointers
623:                 	 *
624:                 	 * Input:			s1		- destination pointer
625:                 	 * 					s2		- source pointer
626:                 	 * 					chn		- the DMA channel to perform the transfer
627:                 	 * 					chPri	- the desired channel priority
628:                 	 *
629:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
630:                 	 * 					an DmaTxferRes error code  otherwise
631:                 	 *
632:                 	 * Side Effects:    None
633:                 	 *
634:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
635:                 	 * 			Then it copies one zero terminated string from source to destination.
636:                 	 *
637:                 	 *
638:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
639:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
640:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
641:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
642:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
643:                 	 *
644:                 	 *
645:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL2, DMA_CHN_PRI3);
646:                 	 *********************************************************************/
647:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
648:                 
649:                 	/*********************************************************************
650:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
651:                 	 *
652:                 	 * PreCondition:    chn		- a valid DMA channel
653:                 	 * 				- s1, s2	- valid memory pointers
654:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
655:                 	 *
656:                 	 * Input:			s1		- destination pointer
657:                 	 * 					s2		- source pointer
658:                 	 * 					n	- max number of bytes to transfer
659:                 	 * 					chn		- the DMA channel to perform the transfer
660:                 	 * 					chPri	- the desired channel priority
661:                 	 *
662:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
663:                 	 * 					an DmaTxferRes error code  otherwise
664:                 	 *
665:                 	 * Side Effects:    None
666:                 	 *
667:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
668:                 	 * 			Then it copies one zero terminated string from source to destination.
669:                 	 * 			It copies no more than n characters from s2.
670:                 	 *
671:                 	 *
672:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
673:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
674:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
675:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
676:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
677:                 	 *
678:                 	 *
679:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL2, DMA_CHN_PRI3);
680:                 	 ********************************************************************/
681:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
682:                 
683:                 	/*********************************************************************
684:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
685:                 	 *
686:                 	 * PreCondition:    chn		- a valid DMA channel
687:                 	 * 					d, s		- valid memory pointer
688:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
689:                 	 *
690:                 	 * Input:			d		- address where to deposit the result
691:                 	 * 					s		- source buffer pointer
692:                 	 * 					n		- number of bytes in the pointer
693:                 	 * 					chn		- the DMA channel to use
694:                 	 * 					chPri	- the desired channel priority
695:                 	 *
696:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
697:                 	 * 					an DmaTxferRes error code  otherwise
698:                 	 *
699:                 	 * Side Effects:    None
700:                 	 *
701:                 	 * Overview:		The function is a helper that calculates the CRC of a memory block.
702:                 	 * 			The function configures the DMA channel for a fast memory transfer and calculates the CRC.
703:                 	 *
704:                 	 *
705:                 	 * Note:            - The CRC generator must have been previously configured using mCrcConfigure()
706:                 	 * 					- No transfer is done, just the CRC is calculated.
707:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
709:                 	 *
710:                 	 * Example:		int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
711:                 	 ********************************************************************/
712:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
713:                 
714:                 
715:                 	// High level CRC functions
716:                 
717:                 	/*********************************************************************
718:                 	 * Function:        void DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
719:                 	 *
720:                 	 * PreCondition:    pLen		- valid polynomial length within 1-16
721:                 	 *
722:                 	 * Input:			polynomial	- the layout of the CRC generator
723:                 	 * 					pLen		- the length of the CRC generator polynomial
724:                 	 * 					seed		- the initial seed of the CRC generator
725:                 	 *
726:                 	 * Output:          None
727:                 	 *
728:                 	 * Side Effects:    None
729:                 	 *
730:                 	 * Overview:		The function configures the CRC module by setting the parameters that define the generator polynomial:
731:                 	 * 					- the length of the CRC generator polynomial, pLen;
732:                 	 * 					- the function sets the layout of the shift stages that take place in the CRC generation.
733:                 	 * 						Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
734:                 	 * 						If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
735:                 	 * 						Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
736:                 	 * 						are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
737:                 	 * 						feedback should be 0x8005, or 0x8004, but not 0x018005;
738:                 	 *					- the function sets the seed of the CRC generator. This is the initial data present in the
739:                 	 * 						CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
740:                 	 *
741:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
742:                 	 * 					- When the append mode is set, the attached DMA channel has to have destination size <=4.
743:                 	 * 						Upon the transfer completion the calculated CRC is stored at the destination address.
744:                 	 * 					- When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
745:                 	 * 						the CrcResult() function.
746:                 	 * 					- The CRC module should be configured before enabled.
747:                 	 *
748:                 	 * Example:			DmaCrcConfigure(0x8005, 16, 0xffff);
749:                 	 ********************************************************************/
750:                 	extern __inline__ void __attribute__((always_inline)) DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
751:                 	{
752:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
753:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
754:                 		DCRCDATA=seed;
755:                 		DCRCXOR=polynomial;
756:                 	}
757:                 
758:                 	/*********************************************************************
759:                 	 * Function:        void CrcAttachChannel(DmaChannel chn, int appendMode)
760:                 	 *
761:                 	 * PreCondition:    chn		- valid DMA channel
762:                 	 *
763:                 	 * Input:			chn			- the DMA channel to be attached to the CRC generator module.
764:                 	 * 					appendMode	- if TRUE the data passed to the CRC generator is not transferred to destination
765:                 	 * 									but it's written to the destination address when the block transfer is complete.
766:                 	 * 								- if FALSE the data is transferred normally while the CRC is calculated. The CRC will
767:                 	 * 									be available using the CrcResult function.
768:                 	 *
769:                 	 * Output:          None
770:                 	 *
771:                 	 * Side Effects:    None
772:                 	 *
773:                 	 * Overview:		The function attaches the CRC module to an DMA channel and enables the CRC generator.
774:                 	 * 					From now on, all the DMA traffic is directed to the CRC generator. Once the DMA block transfer
775:                 	 * 					is complete, the CRC result is available both at the DMA destination address and in the CRC data register.
776:                 	 *
777:                 	 * Note:            None
778:                 	 *
779:                 	 * Example:			CrcAttachChannel(0, TRUE);
780:                 	 ********************************************************************/
781:                 	 void			CrcAttachChannel(DmaChannel chn, int appendMode);
782:                 
783:                 	/*********************************************************************
784:                 	 * Function:        unsigned int CrcResult(void)
785:                 	 *
786:                 	 * PreCondition:    None
787:                 	 *
788:                 	 * Input:			None
789:                 	 *
790:                 	 * Output:          the current value of the CRC generator.
791:                 	 *
792:                 	 * Side Effects:    None
793:                 	 *
794:                 	 * Overview:		The function returns the calculated CRC value.
795:                 	 *
796:                 	 * Note:            The function returns the valid CRC result by masking out the unused MSbits in the CRC register.
797:                 	 * 					Use CrcGetValue() to get the full CRC register value.
798:                 	 *
799:                 	 * Example:			int myCrc=CrcResult();
800:                 	 ********************************************************************/
801:                 	 unsigned int		CrcResult(void);
802:                 
803:                 
804:                 /*********************  end of high level functions ****************************************/
805:                 
806:                 	// low level definitions for the API functions
807:                 
808:                 
809:                 	typedef struct
810:                 	{
811:                 		union
812:                 		{
813:                 			struct
814:                 			{
815:                 				unsigned int chn:	3;		// last active DMA channel
816:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
817:                 			};
818:                 			unsigned int	w;						// word access
819:                 		}lastAccess;
820:                 		void*	lastAddress;		// most recent DMA address
821:                 	}DmaStatus;			// DMA controller status
822:                 #if(defined(__32MX330F064H__)||\
823:                     defined(__32MX330F064L__)||\
824:                     defined(__32MX350F128H__)||\
825:                     defined(__32MX350F128L__)||\
826:                     defined(__32MX350F256H__)||\
827:                     defined(__32MX350F256L__)||\
828:                     defined(__32MX430F064H__)||\
829:                     defined(__32MX430F064L__)||\
830:                     defined(__32MX450F128H__)||\
831:                     defined(__32MX450F128L__)||\
832:                     defined(__32MX450F256H__)||\
833:                     defined(__32MX450F256L__))
834:                 typedef enum
835:                 	{
836:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
837:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
838:                 		//
839:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
840:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
841:                 #else
842:                 	typedef enum
843:                 	{
844:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
845:                 		DMA_GFLG_SIDL =		_DMACON_SIDL_MASK,		// DMA controller sleep/active in idle mode
846:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
847:                 		//
848:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_SIDL|DMA_GFLG_ON		// all flags
849:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
850:                 
851:                 #endif
852:                 
853:                 
854:                 	typedef enum
855:                 	{
856:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
857:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
858:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
859:                         // the start and abort IRQ signals
860:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
861:                 
862:                 
863:                         // compiler use only field
864:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
865:                 	}DmaEvCtrlFlags;	// DMA channel event control fields accessibile as flags
866:                 	// also part of DmaEvCtrlFlags:
867:                 	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
868:                 	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
869:                 
870:                 	// DMA channel event control as a structure:
871:                 	#define	DmaEvCtrl	__DCH0ECONbits_t
872:                 
873:                 
874:                 
875:                 
876:                 	typedef enum
877:                 	{
878:                 		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
879:                 		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
880:                 		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
881:                 		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
882:                 		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
883:                         // use the DMA_CTL_PRI() below for selecting the DMA
884:                         // channel priority
885:                 	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
886:                 	// also part of DmaChnCtrlFlags:
887:                 	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
888:                 
889:                 	// DMA channel control as a structure:
890:                 	#define	DmaChnCtrl  	__DCH0CONbits_t
891:                 
892:                 	typedef struct
893:                 	{
894:                 		void*	vSrcAdd;		// source of the DMA transfer, virtual
895:                 		void*	vDstAdd;		// destination of the DMA transfer, virtual
896:                 		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
897:                 		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
898:                 		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
899:                 	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
900:                 
901:                 
902:                 	/********************** low level DMA channel functions *******************************/
903:                 
904:                 
905:                 
906:                 	// Global DMA controller functions
907:                 
908:                 
909:                 	/*********************************************************************
910:                 	 * Function:        void DmaEnable(int enable)
911:                 	 *
912:                 	 * PreCondition:    None
913:                 	 *
914:                 	 * Input:           enable - boolean to enable/disable the DMA controller
915:                 	 *
916:                 	 * Output:          None
917:                 	 *
918:                 	 * Side Effects:    None
919:                 	 *
920:                 	 * Overview:       The function enables/disables the DMA controller.
921:                 	 *
922:                 	 * Note:           None.
923:                 	 *
924:                 	 * Example:        DmaEnable(1);
925:                 	 ********************************************************************/
926:                 	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
927:                 	{
928:                 		if(enable)
929:                 		{
930:                 			DMACONSET=_DMACON_ON_MASK;
931:                 		}
932:                 		else
933:                 		{
934:                 			DMACONCLR=_DMACON_ON_MASK;
935:                 			while(DMACONbits.ON);		// wait to take effect
936:                 		}
937:                 	}
938:                 
939:                 	/*********************************************************************
940:                 	 * Function:        void DmaReset(void)
941:                 	 *
942:                 	 * PreCondition:    None
943:                 	 *
944:                 	 * Input:		None
945:                 	 *
946:                 	 * Output:          None
947:                 	 *
948:                 	 * Side Effects:    None
949:                 	 *
950:                 	 * Overview:        The function resets the DMA controller.
951:                 	 *
952:                 	 * Note:            None.
953:                 	 *
954:                 	 * Example:        DmaReset();
955:                 	 ********************************************************************/
956:                 	#define            DmaReset()	DmaEnable(0)
957:                 
958:                 	/*********************************************************************
959:                 	 * Function:        int DmaSuspend(void)
960:                 	 *
961:                 	 * PreCondition:    None
962:                 	 *
963:                 	 * Input:		None
964:                 	 *
965:                 	 * Output:          true if the DMA was previously suspended, false otherwise
966:                 	 *
967:                 	 *
968:                 	 * Side Effects:    None
969:                 	 *
970:                 	 * Overview:        The function suspends the DMA controller.
971:                 	 *
972:                 	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
973:                 	 *                  I.e. the function has to wait for the suspension to take place!
974:                 	 *
975:                 	 * Example:			int susp=DmaSuspend();
976:                 	 ********************************************************************/
977:                     extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
978:                 	{
979:                 		int suspSt;
980:                 		if(!(suspSt=DMACONbits.SUSPEND))
9D0081F4  3C02BF88   LUI V0, -16504
9D0081F8  8C423000   LW V0, 12288(V0)
9D0081FC  7C420300   EXT V0, V0, 12, 1
9D008200  304200FF   ANDI V0, V0, 255
9D008204  AFC2003C   SW V0, 60(S8)
9D008208  8FC2003C   LW V0, 60(S8)
9D00820C  14400009   BNE V0, ZERO, 0x9D008234
9D008210  00000000   NOP
9D0082C8  3C02BF88   LUI V0, -16504
9D0082CC  8C423000   LW V0, 12288(V0)
9D0082D0  7C420300   EXT V0, V0, 12, 1
9D0082D4  304200FF   ANDI V0, V0, 255
9D0082D8  AFC20048   SW V0, 72(S8)
9D0082DC  8FC20048   LW V0, 72(S8)
9D0082E0  14400010   BNE V0, ZERO, 0x9D008324
9D0082E4  00000000   NOP
981:                 		{
982:                 			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D008214  3C02BF88   LUI V0, -16504
9D008218  24031000   ADDIU V1, ZERO, 4096
9D00821C  AC433008   SW V1, 12296(V0)
9D0082E8  3C02BF88   LUI V0, -16504
9D0082EC  24031000   ADDIU V1, ZERO, 4096
9D0082F0  AC433008   SW V1, 12296(V0)
983:                 			while(!(DMACONbits.SUSPEND));	// wait to be actually suspended
9D008220  3C02BF88   LUI V0, -16504
9D008224  8C423000   LW V0, 12288(V0)
9D008228  30421000   ANDI V0, V0, 4096
9D00822C  1040FFFC   BEQ V0, ZERO, 0x9D008220
9D008230  00000000   NOP
9D0082F4  3C02BF88   LUI V0, -16504
9D0082F8  8C423000   LW V0, 12288(V0)
9D0082FC  30421000   ANDI V0, V0, 4096
9D008300  1040FFFC   BEQ V0, ZERO, 0x9D0082F4
9D008304  00000000   NOP
984:                 		}
985:                 		return suspSt;
9D008234  8FC2003C   LW V0, 60(S8)
9D008308  0B4020CA   J 0x9D008328
9D00830C  00000000   NOP
9D008324  00000000   NOP
986:                 	}
987:                 
988:                 
989:                 
990:                 	/*********************************************************************
991:                 	 * Function:        void DmaResume(int susp)
992:                 	 *
993:                 	 * PreCondition:    None
994:                 	 *
995:                 	 * Input:		the desired DMA suspended state.
996:                 	 *
997:                 	 * Output:          None
998:                 	 *
999:                 	 * Side Effects:    None
1000:                	 *
1001:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1002:                	 *
1003:                	 * Note:            None.
1004:                	 *
1005:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1006:                	 ********************************************************************/
1007:                    extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1008:                	{
1009:                		if(susp)
9D0082BC  8FC20044   LW V0, 68(S8)
9D0082C0  10400013   BEQ V0, ZERO, 0x9D008310
9D0082C4  00000000   NOP
1010:                		{
1011:                			DmaSuspend();
1012:                		}
1013:                		else
1014:                		{
1015:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D008310  3C02BF88   LUI V0, -16504
9D008314  24031000   ADDIU V1, ZERO, 4096
9D008318  AC433004   SW V1, 12292(V0)
9D00831C  0B4020CA   J 0x9D008328
9D008320  00000000   NOP
1016:                		}
1017:                	}
1018:                
1019:                	/*********************************************************************
1020:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1021:                	 *
1022:                	 * PreCondition:    pStat	- valid pointer
1023:                	 *
1024:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1025:                	 * 							status, carrying the following info:
1026:                	 * 								- chn:	the last active DMA channel
1027:                	 * 								- rdOp: the last DMA operation, read/write
1028:                	 * 								- lastAddress: the most recent DMA address
1029:                	 *
1030:                	 * Output:          None
1031:                	 *
1032:                	 * Side Effects:    None
1033:                	 *
1034:                	 * Overview:		The function updates the info for the current DMA controller status.
1035:                	 * 					It updates the last DMA: operation, channel used and address.
1036:                	 *
1037:                	 * Note:            None.
1038:                	 *
1039:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1040:                	 ********************************************************************/
1041:                	 void			DmaGetStatus(DmaStatus* pStat);
1042:                
1043:                	/*********************************************************************
1044:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1045:                	 *
1046:                	 * PreCondition:    None
1047:                	 *
1048:                	 * Input:			gFlags	- flags to be set, having the following fields:
1049:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1050:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1051:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1052:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1053:                	 *
1054:                	 * Output:          None
1055:                	 *
1056:                	 * Side Effects:    None
1057:                	 *
1058:                	 * Overview:		The function affects the global behavior of the DMA controller.
1059:                	 * 					It sets the specified flags. Any flag that is set in the gFlags will be
1060:                	 * 					enabled, the other flags won't be touched.
1061:                	 *
1062:                	 * Note:            None.
1063:                	 *
1064:                	 * Example:			DmaSetGlobalFlags(DMA_GFLG_SIDL|DMA_GFLG_ON);
1065:                	 ********************************************************************/
1066:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1067:                	{
1068:                		DMACONSET=gFlags;
1069:                	}
1070:                
1071:                	/*********************************************************************
1072:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1073:                	 *
1074:                	 * PreCondition:    None
1075:                	 *
1076:                	 * Input:			gFlags	- flags to be cleared, having the following fields:
1077:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1078:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1079:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1080:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1081:                	 *
1082:                	 * Output:          None
1083:                	 *
1084:                	 * Side Effects:    None
1085:                	 *
1086:                	 * Overview:		The function affects the global behavior of the DMA controller.
1087:                	 * 					It clears the specified flags. Any flag that is set in the gFlags will be
1088:                	 * 					cleared, the other flags won't be touched.
1089:                	 *
1090:                	 * Note:            None.
1091:                	 *
1092:                	 * Example:			DmaClrGlobalFlags(DMA_GFLG_SUSPEND|DMA_GFLG_SIDL);
1093:                	 ********************************************************************/
1094:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1095:                	{
1096:                		DMACONCLR=gFlags;
1097:                	}
1098:                
1099:                
1100:                	/*********************************************************************
1101:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1102:                	 *
1103:                	 * PreCondition:    None
1104:                	 *
1105:                	 * Input:			gFlags	- flags to be set, having the following fields:
1106:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1107:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1108:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1109:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1110:                	 *
1111:                	 * Output:          None
1112:                	 *
1113:                	 * Side Effects:    None
1114:                	 *
1115:                	 * Overview:		The function affects the global behavior of the DMA controller.
1116:                	 * 					It forces the flags to have the specified gFlags value.
1117:                	 *
1118:                	 * Note:            None.
1119:                	 *
1120:                	 * Example:			DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1121:                	 ********************************************************************/
1122:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1123:                	{
1124:                		DMACON=gFlags;
1125:                	}
1126:                
1127:                	/*********************************************************************
1128:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1129:                	 *
1130:                	 * PreCondition:    None
1131:                	 *
1132:                	 * Input:			None
1133:                	 *
1134:                	 * Output:          The current DMA controller flags settings.
1135:                	 * 						- DMA_GFLG_SUSPEND: DMA controller operation suspend
1136:                	 * 						- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1137:                	 * 						- DMA_GFLG_ON: DMA controller enabled/desabled
1138:                	 *
1139:                	 * Side Effects:    None
1140:                	 *
1141:                	 * Overview:		The function returns the global flags of the DMA controller.
1142:                	 *
1143:                	 * Note:            None.
1144:                	 *
1145:                	 * Example:			DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1146:                	 ********************************************************************/
1147:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1148:                	{
1149:                		return (DmaGlblFlags)DMACON;
1150:                	}
1151:                
1152:                
1153:                	/*********************************************************************
1154:                	 * Function:        int DmaGetMaxTxferSize(void)
1155:                	 *
1156:                	 * PreCondition:    None
1157:                	 *
1158:                	 * Input:           None
1159:                	 *
1160:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1161:                	 *
1162:                	 * Side Effects:    None
1163:                	 *
1164:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1165:                	 *
1166:                	 * Note:            Revision dependant.
1167:                	 *
1168:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1169:                	 ********************************************************************/
1170:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1171:                	{
1172:                		return 256;
1173:                	}
1174:                
1175:                
1176:                	// Direct Channel control functions
1177:                
1178:                	typedef enum
1179:                	{
1180:                		DMA_CONFIG_DEFAULT = 0,							        // DMA default operation
1181:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
1182:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1183:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),			// DMA channel is chained to higher channel
1184:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,				// events detection enabled while channel off
1185:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
1186:                		DMA_CONFIG_MATCH	= 0x80000000,						// DMA channel stops on match
1187:                	}DmaConfigFlags;	// flags for the channel configuration
1188:                
1189:                	/*********************************************************************
1190:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1191:                	 *
1192:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1193:                	 *
1194:                	 * Input:           chn    - channel to be configured in the DMA controller
1195:                	 *                  chPri  - the priority given to the channel, 0-3
1196:                	 *                  cFlags - orred flags specifying the configuration:
1197:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1198:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1199:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1200:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1201:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1202:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1203:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1204:                	 *
1205:                	 *
1206:                	 *
1207:                	 * Output:          None
1208:                	 *
1209:                	 * Side Effects:    None
1210:                	 *
1211:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1212:                	 *
1213:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1214:                	 *                  The channel is just configured.
1215:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1216:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1217:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1218:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1219:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1220:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1221:                	 *
1222:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1223:                	 ********************************************************************/
1224:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1225:                
1226:                
1227:                	/*********************************************************************
1228:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1229:                	 *
1230:                	 * PreCondition:    chn	- valid DMA channel
1231:                	 *
1232:                	 * Input:			chn		- DMA channel number
1233:                	 *
1234:                	 * Output:          Current channel source pointer.
1235:                	 *
1236:                	 * Side Effects:    None
1237:                	 *
1238:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1239:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1240:                	 *
1241:                	 * Note:            None
1242:                	 *
1243:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL2);
1244:                	 ********************************************************************/
1245:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1246:                
1247:                	/*********************************************************************
1248:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1249:                	 *
1250:                	 * PreCondition:    chn	- valid DMA channel
1251:                	 *
1252:                	 * Input:			chn		- DMA channel number
1253:                	 *
1254:                	 * Output:          Current channel destination pointer.
1255:                	 *
1256:                	 * Side Effects:    None
1257:                	 *
1258:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1259:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1260:                	 *
1261:                	 * Note:            None
1262:                	 *
1263:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL2);
1264:                	 ********************************************************************/
1265:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1266:                
1267:                	/*********************************************************************
1268:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1269:                	 *
1270:                	 * PreCondition:    chn	- valid DMA channel
1271:                	 *
1272:                	 * Input:			chn		- DMA channel number
1273:                	 *
1274:                	 * Output:          Current channel transfer pointer.
1275:                	 *
1276:                	 * Side Effects:    None
1277:                	 *
1278:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1279:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1280:                	 *
1281:                	 * Note:            None
1282:                	 *
1283:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL2);
1284:                	 ********************************************************************/
1285:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1286:                
1287:                
1288:                
1289:                	/*********************************************************************
1290:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1291:                	 *
1292:                	 * PreCondition:    chn	- valid DMA channel
1293:                	 *
1294:                	 * Input:			chn			- DMA channel number
1295:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1296:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1297:                	 * 										- SIRQEN: enable/disable the start IRQ action
1298:                	 * 										- PATEN: enable/disable the pattern match and abort
1299:                	 * 									or any of the DmaEvCtrlFlags:
1300:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1301:                	 *
1302:                	 *
1303:                	 * Output:          None
1304:                	 *
1305:                	 * Side Effects:    None
1306:                	 *
1307:                	 * Overview:		The function sets the events that start and abort the transfer
1308:                	 * 					for the selected DMA channel.
1309:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1310:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1311:                	 *
1312:                	 * Note:            None.
1313:                	 *
1314:                	 * Example:			either:
1315:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1316:                	 * 					or:
1317:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1318:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1319:                	 *
1320:                	 ********************************************************************/
1321:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1322:                
1323:                
1324:                	/*********************************************************************
1325:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1326:                	 *
1327:                	 * PreCondition:    chn	- valid DMA channel
1328:                	 *
1329:                	 * Input:			chn			- DMA channel number
1330:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1331:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1332:                	 * 										- SIRQEN: enable/disable the start IRQ action
1333:                	 * 										- PATEN: enable/disable the pattern match and abort
1334:                	 * 									or any of the DmaEvCtrlFlags:
1335:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1336:                	 *
1337:                	 *
1338:                	 * Output:          None
1339:                	 *
1340:                	 * Side Effects:    None
1341:                	 *
1342:                	 * Overview:		The function clears the events that start and abort the transfer
1343:                	 * 					for the selected DMA channel.
1344:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1345:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1346:                	 *
1347:                	 * Note:            None.
1348:                	 *
1349:                	 * Example:			either:
1350:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1351:                	 * 					or:
1352:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1353:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1354:                	 *
1355:                	 ********************************************************************/
1356:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1357:                
1358:                
1359:                
1360:                	/*********************************************************************
1361:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1362:                	 *
1363:                	 * PreCondition:    chn	- valid DMA channel
1364:                	 *
1365:                	 * Input:			chn			- DMA channel number
1366:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1367:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1368:                	 * 										- SIRQEN: enable/disable the start IRQ action
1369:                	 * 										- PATEN: enable/disable the pattern match and abort
1370:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1371:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1372:                	 * 									or any of the DmaEvCtrlFlags:
1373:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1374:                	 *
1375:                	 *
1376:                	 * Output:          None
1377:                	 *
1378:                	 * Side Effects:    None
1379:                	 *
1380:                	 * Overview:		The function writes the events that start and abort the transfer
1381:                	 * 					for the selected DMA channel.
1382:                	 *
1383:                	 * Note:            None.
1384:                	 *
1385:                	 * Example:			either:
1386:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1387:                	 * 					or:
1388:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1389:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1390:                	 *
1391:                	 ********************************************************************/
1392:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1393:                
1394:                
1395:                
1396:                	/*********************************************************************
1397:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1398:                	 *
1399:                	 * PreCondition:    chn	- valid DMA channel
1400:                	 *
1401:                	 * Input:			chn			- DMA channel number
1402:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1403:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1404:                	 * 										- SIRQEN: enable/disable the start IRQ action
1405:                	 * 										- PATEN: enable/disable the pattern match and abort
1406:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1407:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1408:                	 * 									or any of the DmaEvCtrlFlags:
1409:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1410:                	 *
1411:                	 *
1412:                	 * Output:          None
1413:                	 *
1414:                	 * Side Effects:    None
1415:                	 *
1416:                	 * Overview:		The function sets the events that start and abort the transfer
1417:                	 * 					for the selected DMA channel.
1418:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1419:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1420:                	 *
1421:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1422:                	 *
1423:                	 * Example:			either:
1424:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1425:                	 * 					or:
1426:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1427:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, evCtrl.w);
1428:                	 *
1429:                	 ********************************************************************/
1430:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1431:                
1432:                
1433:                	/*********************************************************************
1434:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1435:                	 *
1436:                	 * PreCondition:    chn	- valid DMA channel
1437:                	 *
1438:                	 * Input:			chn		- DMA channel number
1439:                	 *
1440:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1441:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1442:                	 * 							- SIRQEN: enable/disable the start IRQ action
1443:                	 * 							- PATEN: enable/disable the pattern match and abort
1444:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1445:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1446:                	 * 						or any of the DmaEvCtrlFlags:
1447:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1448:                	 *
1449:                	 *
1450:                	 * Side Effects:    None
1451:                	 *
1452:                	 * Overview:		The function retrieves the events that start and abort the transfer
1453:                	 * 					for the selected DMA channel.
1454:                	 *
1455:                	 * Note:            None.
1456:                	 *
1457:                	 * Example:			either:
1458:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1459:                	 * 					or:
1460:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrl.PATEN){...}
1461:                	 *
1462:                	 ********************************************************************/
1463:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1464:                
1465:                
1466:                	/*********************************************************************
1467:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1468:                	 *
1469:                	 * PreCondition:    chn	- valid DMA channel
1470:                	 *
1471:                	 * Input:			chn			- DMA channel number
1472:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1473:                	 * 										- autoEn: enable/disable the automatic mode
1474:                	 * 										- chainEn: enable/disable channel chaining
1475:                	 * 										- detectEn: enable/disable events detection when channel disabled
1476:                	 * 										- chEn: enable/disable channel functionality
1477:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1478:                	 * 									or any of the DmaChnCtrlFlags flags:
1479:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1480:                	 *
1481:                	 * Output:          None
1482:                	 *
1483:                	 * Side Effects:    None
1484:                	 *
1485:                	 * Overview:		The function sets the selected DMA channel control flags:
1486:                	 * 					the chaining or auto mode, and events detection.
1487:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1488:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1489:                	 *
1490:                	 * Note:            None.
1491:                	 *
1492:                	 * Example:			either:
1493:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1494:                	 * 					or:
1495:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1496:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, chCtrl.w);
1497:                	 *
1498:                	 ********************************************************************/
1499:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1500:                
1501:                	/*********************************************************************
1502:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1503:                	 *
1504:                	 * PreCondition:    chn	- valid DMA channel
1505:                	 *
1506:                	 * Input:			chn			- DMA channel number
1507:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1508:                	 * 										- autoEn: enable/disable the automatic mode
1509:                	 * 										- chainEn: enable/disable channel chaining
1510:                	 * 										- detectEn: enable/disable events detection when channel disabled
1511:                	 * 										- chEn: enable/disable channel functionality
1512:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1513:                	 * 									or any of the DmaChnCtrlFlags flags:
1514:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1515:                	 *
1516:                	 * Output:          None
1517:                	 *
1518:                	 * Side Effects:    None
1519:                	 *
1520:                	 * Overview:		The function clears the selected DMA channel control flags:
1521:                	 * 					the chaining or auto mode and events detection.
1522:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1523:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1524:                	 *
1525:                	 * Note:            None.
1526:                	 *
1527:                	 * Example:			either:
1528:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1529:                	 * 					or:
1530:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1531:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, chCtrl.w);
1532:                	 *
1533:                	 ********************************************************************/
1534:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1535:                
1536:                	/*********************************************************************
1537:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1538:                	 *
1539:                	 * PreCondition:    chn	- valid DMA channel
1540:                	 *
1541:                	 * Input:			chn			- DMA channel number
1542:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1543:                	 * 										- chPri: channel priority 0-3
1544:                	 * 										- autoEn: enable/disable the automatic mode
1545:                	 * 										- chainEn: enable/disable channel chaining
1546:                	 * 										- detectEn: enable/disable events detection when channel disabled
1547:                	 * 										- chEn: enable/disable channel functionality
1548:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1549:                	 * 									or any of the DmaChnCtrlFlags flags:
1550:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1551:                	 *
1552:                	 * Output:          None
1553:                	 *
1554:                	 * Side Effects:    None
1555:                	 *
1556:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1557:                	 * 					the channel priority, chaining mode or auto and events detection.
1558:                	 *
1559:                	 * Note:            None.
1560:                	 *
1561:                	 * Example:			either:
1562:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1563:                	 * 					or:
1564:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1565:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, chCtrl.w);
1566:                	 *
1567:                	 ********************************************************************/
1568:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1569:                
1570:                	/*********************************************************************
1571:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1572:                	 *
1573:                	 * PreCondition:    chn	- valid DMA channel
1574:                	 *
1575:                	 * Input:	    chn		- DMA channel number
1576:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1577:                	 * 						- chPri: channel priority 0-3
1578:                	 * 						- autoEn: enable/disable the automatic mode
1579:                	 * 						- chainEn: enable/disable channel chaining
1580:                	 * 						- detectEn: enable/disable events detection when channel disabled
1581:                	 * 						- chEn: enable/disable channel functionality
1582:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1583:                	 * 					or any of the DmaChnCtrlFlags flags:
1584:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1585:                	 *
1586:                	 * Output:          None
1587:                	 *
1588:                	 * Side Effects:    None
1589:                	 *
1590:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1591:                	 * 					the channel priority, chaining mode or auto and events detection.
1592:                	 *
1593:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1594:                	 *
1595:                	 * Example:         either:
1596:                	 *                      DmaChnSetControl(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1597:                	 *                  or:
1598:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1599:                	 * 			DmaChnSetControl(DMA_CHANNEL2, chCtrl.w);
1600:                	 *
1601:                	 ********************************************************************/
1602:                #define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1603:                
1604:                	/*********************************************************************
1605:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1606:                	 *
1607:                	 * PreCondition:    chn	- valid DMA channel
1608:                	 *
1609:                	 * Input:			chn			- DMA channel number
1610:                	 *
1611:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1612:                	 * 							- chPri: channel priority 0-3
1613:                	 * 							- autoEn: enable/disable the automatic mode
1614:                	 * 							- chainEn: enable/disable channel chaining
1615:                	 * 							- detectEn: enable/disable events detection when channel disabled
1616:                	 * 							- chEn: enable/disable channel functionality
1617:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1618:                	 *						or any of the DmaChnCtrlFlags flags:
1619:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1620:                	 *
1621:                	 * Side Effects:    None
1622:                	 *
1623:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1624:                	 * 					including the channel enable/disable status, the channel priority,
1625:                	 * 					chaining mode, auto mode and events detection.
1626:                	 *
1627:                	 * Note:            None.
1628:                	 *
1629:                	 * Example:			either:
1630:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL2); if(ctrl&DMA_CTL_AUTO_EN) {...}
1631:                	 * 					or:
1632:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL2); if(chnCtrl.autoEn) {...}
1633:                	 *
1634:                	 ********************************************************************/
1635:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1636:                
1637:                
1638:                	/*********************************************************************
1639:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1640:                	 *
1641:                	 * PreCondition:    chn	- valid DMA channel
1642:                	 *
1643:                	 * Input:			chn		- DMA channel number
1644:                	 *
1645:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1646:                	 *
1647:                	 * Side Effects:    None
1648:                	 *
1649:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1650:                	 *
1651:                	 * Note:            None.
1652:                	 *
1653:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL2);
1654:                	 *
1655:                	 ********************************************************************/
1656:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1657:                
1658:                	/*********************************************************************
1659:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1660:                	 *
1661:                	 * PreCondition:    chn		- valid DMA channel
1662:                	 * 					pTxCtrl	- valid pointer
1663:                	 *
1664:                	 * Input:			chn			- DMA channel number
1665:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1666:                	 * 								- vSrcAdd: source of the DMA transfer
1667:                	 * 								- vDstAdd: destination of the DMA transfer
1668:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1669:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1670:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1671:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1672:                	 *
1673:                	 * Output:          None
1674:                	 *
1675:                	 * Side Effects:    None
1676:                	 *
1677:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1678:                	 * 					the source and the destination addresses.
1679:                	 * 					It also retrieves the source and destination lengths
1680:                	 * 					and the number of bytes	transferred per event.
1681:                	 *
1682:                	 * Note:            None
1683:                	 *
1684:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL2, &txCtl, FALSE);
1685:                	 ********************************************************************/
1686:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1687:                
1688:                	// Low level CRC functions
1689:                
1690:                	/*********************************************************************
1691:                	 * Function:        void DmaCrcEnable(int enable)
1692:                	 *
1693:                	 * PreCondition:    None
1694:                	 *
1695:                	 * Input:           enable - boolean to enable/disable the CRC module
1696:                	 *
1697:                	 * Output:          None
1698:                	 *
1699:                	 * Side Effects:    None
1700:                	 *
1701:                	 * Overview:        The function enables the CRC module functionality and the attached DMA channel transfers are routed to the CRC module.
1702:                	 *
1703:                	 * Note:            The CRC module should be properly configured before enabled.
1704:                	 *
1705:                	 * Example:         CrcEnable(1);
1706:                	 ********************************************************************/
1707:                	extern __inline__ void __attribute__((always_inline)) DmaCrcEnable(int enable)
1708:                	{
1709:                		if(enable)
1710:                		{
1711:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1712:                		}
1713:                		else
1714:                		{
1715:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1716:                		}
1717:                	}
1718:                
1719:                
1720:                
1721:                	/*********************************************************************
1722:                	 * Function:        int DmaCrcGetEnable(void)
1723:                	 *
1724:                	 * PreCondition:    None
1725:                	 *
1726:                	 * Input:			None
1727:                	 *
1728:                	 * Output:          TRUE, if the CRC module is enabled
1729:                	 * 					FALSE otherwise
1730:                	 *
1731:                	 * Side Effects:    None
1732:                	 *
1733:                	 * Overview:		The function returns the CRC module enabling status.
1734:                	 *
1735:                	 * Note:            None
1736:                	 *
1737:                	 * Example:			int isCrcEnabled=DmaCrcGetEnable();
1738:                	 ********************************************************************/
1739:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetEnable(void)
1740:                	{
1741:                		return	DCRCCONbits.CRCEN!=0;
1742:                	}
1743:                
1744:                	
1745:                	/*********************************************************************
1746:                	 * Function:        void DmaCrcAppendModeEnable(int enable)
1747:                	 *
1748:                	 * PreCondition:    None
1749:                	 *
1750:                	 * Input:           enable - boolean to enable/disable the append mode
1751:                	 *
1752:                	 * Output:          None
1753:                	 *
1754:                	 * Side Effects:    None
1755:                	 *
1756:                	 * Overview:		The function enables the CRC append mode. In this mode, the attached DMA channel reads
1757:                	 * 					the source data but does not write it to the destination address. The data it's just passed
1758:                	 * 					to the CRC generator for CRC calculation.
1759:                	 * 					When the block transfer is completed, the CRC result is written to the
1760:                	 * 					DMA channel destination address.
1761:                	 *
1762:                	 * Note:            The CRC module should be properly configured before enabled.
1763:                	 *
1764:                	 * Example:         DmaCrcAppendModeEnable(1);
1765:                	 ********************************************************************/
1766:                	extern __inline__ void __attribute__((always_inline)) DmaCrcAppendModeEnable(int enable)
1767:                	{
1768:                		if(enable)
1769:                		{
1770:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1771:                		}
1772:                		else
1773:                		{
1774:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1775:                		}
1776:                	}
1777:                
1778:                
1779:                	/*********************************************************************
1780:                	 * Function:        int DmaCrcGetAppendMode(void)
1781:                	 *
1782:                	 * PreCondition:    None
1783:                	 *
1784:                	 * Input:           None
1785:                	 *
1786:                	 * Output:          TRUE, if the CRC append mode is enabled
1787:                	 * 					FALSE otherwise
1788:                	 *
1789:                	 * Side Effects:    None
1790:                	 *
1791:                	 * Overview:		The function returns the CRC module enabling status.
1792:                	 *
1793:                	 * Note:            None
1794:                	 *
1795:                	 * Example:			int isAppendEnabled=DmaCrcGetAppendMode();
1796:                	 ********************************************************************/
1797:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetAppendMode(void)
1798:                	{
1799:                		return DCRCCONbits.CRCAPP!=0;
1800:                	}
1801:                
1802:                	/*********************************************************************
1803:                	 * Function:        void DmaCrcSetAttach(DmaChannel chn)
1804:                	 *
1805:                	 * PreCondition:    chn		- valid DMA channel
1806:                	 *
1807:                	 * Input:			chn	- the DMA channel to be attached to the CRC module (the DMA channel transfers will be routed to the CRC module)
1808:                	 *
1809:                	 * Output:          None
1810:                	 *
1811:                	 * Side Effects:    None
1812:                	 *
1813:                	 * Overview:		The function attaches a DMA channel to the CRC module.
1814:                	 *
1815:                	 * Note:            None
1816:                	 *
1817:                	 * Example:			DmaCrcSetAttach(DMA_CHANNEL0);
1818:                	 ********************************************************************/
1819:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetAttach(DmaChannel chn)
1820:                	{
1821:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1822:                		DCRCCONSET=chn;
1823:                	}
1824:                		
1825:                	/*********************************************************************
1826:                	 * Function:        DmaChannel DmaCrcGetAttach(void)
1827:                	 *
1828:                	 * PreCondition:    None
1829:                	 *
1830:                	 * Input:			None
1831:                	 *
1832:                	 * Output:          the DMA channel that is currently attached to the CRC module
1833:                	 *
1834:                	 * Side Effects:    None
1835:                	 *
1836:                	 * Overview:		The function returns the DMA channel number that is currently attached to the CRC module.
1837:                	 *
1838:                	 * Note:            None
1839:                	 *
1840:                	 * Example:			DmaChannel chn=DmaCrcGetAttach();
1841:                	 ********************************************************************/
1842:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaCrcGetAttach(void)
1843:                	{
1844:                		return	(DmaChannel)DCRCCONbits.CRCCH;
1845:                	}
1846:                
1847:                
1848:                	/*********************************************************************
1849:                	 * Function:        void DmaCrcSetPLen(int pLen)
1850:                	 *
1851:                	 * PreCondition:    pLen	- valid polynomial length within 1-16
1852:                	 *
1853:                	 * Input:			pLen	- the length of the CRC generator polynomial
1854:                	 *
1855:                	 * Output:          None
1856:                	 *
1857:                	 * Side Effects:    None
1858:                	 *
1859:                	 * Overview:		The length of the CRC generator polynomial is set as being pLen;
1860:                	 *
1861:                	 * Note:            None
1862:                	 *
1863:                	 * Example:         DmaCrcSetPLen(16);
1864:                	 ********************************************************************/
1865:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1866:                	{
1867:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
1868:                		DCRCCONSET=(pLen)-1;
1869:                	}
1870:                		
1871:                	/*********************************************************************
1872:                	 * Function:        int DmaCrcGetPLen(void)
1873:                	 *
1874:                	 * PreCondition:    None
1875:                	 *
1876:                	 * Input:           None
1877:                	 *
1878:                	 * Output:          the length of the CRC generator polynomial
1879:                	 *
1880:                	 * Side Effects:    None
1881:                	 *
1882:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
1883:                	 *                  It's always a number between 1 and 16.
1884:                	 *
1885:                	 * Note:            None
1886:                	 *
1887:                	 * Example:         int polyLen=DmaCrcGetPLen();
1888:                	 ********************************************************************/
1889:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
1890:                	{
1891:                		return	DCRCCONbits.PLEN+1; 
1892:                	}
1893:                	
1894:                
1895:                	/*********************************************************************
1896:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
1897:                	 *
1898:                	 * PreCondition:    None
1899:                	 *
1900:                	 * Input:			feedback	- the layout of the CRC generator
1901:                	 *
1902:                	 * Output:          None
1903:                	 *
1904:                	 * Side Effects:    None
1905:                	 *
1906:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
1907:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1908:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1909:                	 *
1910:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1911:                	 *
1912:                	 * Example:         DmaCrcSetShiftFeedback(0x8005);
1913:                	 ********************************************************************/
1914:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
1915:                	{
1916:                		DCRCXOR=feedback;
1917:                	}
1918:                
1919:                		
1920:                	/*********************************************************************
1921:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
1922:                	 *
1923:                	 * PreCondition:    None
1924:                	 *
1925:                	 * Input:			None
1926:                	 *
1927:                	 * Output:          the current layout of the CRC generator
1928:                	 *
1929:                	 * Side Effects:    None
1930:                	 *
1931:                	 * Overview:		The function returns the layout of the shift stages that take place in the CRC generation.
1932:                	 * 					A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1933:                	 * 					If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1934:                	 *
1935:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1936:                	 *
1937:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
1938:                	 ********************************************************************/
1939:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
1940:                	{
1941:                		return DCRCXOR;
1942:                	}
1943:                
1944:                	/*********************************************************************
1945:                	 * Function:        void DmaCrcSetSeed(unsigned int seed)
1946:                	 *
1947:                	 * PreCondition:    None
1948:                	 *
1949:                	 * Input:			seed	- the initial seed of the CRC generator
1950:                	 *
1951:                	 * Output:          None
1952:                	 *
1953:                	 * Side Effects:    None
1954:                	 *
1955:                	 * Overview:		The function sets the seed of the CRC generator. This is the initial data present in the
1956:                	 * 					CRC shift register before the CRC calculation begins.
1957:                	 *
1958:                	 * Note:            None
1959:                	 *
1960:                	 * Example:			DmaCrcSetSeed(0xffff);
1961:                	 ********************************************************************/
1962:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetSeed(unsigned int seed)
1963:                	{
1964:                		DCRCDATA=seed;
1965:                	}
1966:                		
1967:                	/*********************************************************************
1968:                	 * Function:        unsigned int DmaCrcGetValue(void)
1969:                	 *
1970:                	 * PreCondition:    None
1971:                	 *
1972:                	 * Input:			None
1973:                	 *
1974:                	 * Output:          the current value of the CRC generator
1975:                	 *
1976:                	 * Side Effects:    None
1977:                	 *
1978:                	 * Overview:		The function returns the current value of the CRC generator.
1979:                	 *
1980:                	 * Note:            Only the remainder bits (0 to pLen-1) are significant, the rest should be ignored.
1981:                	 *
1982:                	 * Example:		unsigned int calcCrc=DmaCrcGetValue();
1983:                	 ********************************************************************/
1984:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetValue(void)
1985:                	{
1986:                		return DCRCDATA;
1987:                	}
1988:                
1989:                
1990:                	// Channel test/debug and special functions
1991:                
1992:                	/*********************************************************************
1993:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
1994:                	 *
1995:                	 * PreCondition:    chn	- valid DMA channel
1996:                	 *
1997:                	 * Input:			chn		- DMA channel number
1998:                	 * 					eFlags	- event flags with the following significance:
1999:                	 * 								- DMA_EV_ERR: address error event
2000:                	 * 								- DMA_EV_ABORT: transfer abort event
2001:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2002:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2003:                	 * 								- DMA_EV_DST_HALF: destination half event
2004:                	 * 								- DMA_EV_DST_FULL: destination full event
2005:                	 * 								- DMA_EV_SRC_HALF: source half event
2006:                	 * 								- DMA_EV_SRC_FULL: source full event
2007:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2008:                	 *
2009:                	 * Output:          None
2010:                	 *
2011:                	 * Side Effects:    None
2012:                	 *
2013:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2014:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2015:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2016:                	 *
2017:                	 * Note:            This is intended as a channel test function.
2018:                	 *
2019:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2020:                	 ********************************************************************/
2021:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2022:                
2023:                	/*********************************************************************
2024:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2025:                	 *
2026:                	 * PreCondition:    chn	- valid DMA channel
2027:                	 *
2028:                	 * Input:			chn		- DMA channel number
2029:                	 * 					eFlags	- event flags with the following significance:
2030:                	 * 								- DMA_EV_ERR: address error event
2031:                	 * 								- DMA_EV_ABORT: transfer abort event
2032:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2033:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2034:                	 * 								- DMA_EV_DST_HALF: destination half event
2035:                	 * 								- DMA_EV_DST_FULL: destination full event
2036:                	 * 								- DMA_EV_SRC_HALF: source half event
2037:                	 * 								- DMA_EV_SRC_FULL: source full event
2038:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2039:                	 *
2040:                	 * Output:          None
2041:                	 *
2042:                	 * Side Effects:    None
2043:                	 *
2044:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2045:                	 * 					The channel event flags are forced to the eFlags value.
2046:                	 *
2047:                	 * Note:            This is intended as a channel test function.
2048:                	 *
2049:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2050:                	 ********************************************************************/
2051:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2052:                
2053:                
2054:                	/********************************************************************
2055:                	 * Include legacy DMA functions
2056:                	 * New projects should not use them!
2057:                	 * Note that interrupt functions are no longer provided.
2058:                	 * The functions in the int.h should be used instead.
2059:                	 ********************************************************************/
2060:                	#ifndef _PLIB_DISABLE_LEGACY
2061:                		#include <peripheral/legacy/dma_legacy.h>
2062:                	#endif
2063:                
2064:                	 
2065:                #else
2066:                	#undef _DMA_CHANNELS		// no DMA channels
2067:                #endif	// _DMAC0
2068:                
2069:                #endif /*_DMA_H_*/
2070:                
2071:                
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/main.c  --------------------------
1:                   //*************************************************************************************************
2:                   //										M a i n . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	main() initialization and scheduler
8:                   //
9:                   //		001	15 Feb 13 <sek> created from Microchip UART sample code and gsf Code Base
10:                  //		002	05 Mar 13 <sek> moved configuation bits to MCUConfigurationBits.h
11:                  //		003	09 Mar 13 <sek> handle two motors
12:                  //		004 18 Mar 13 <sek> replace SYS_FREQ with GetSystemClock()
13:                  //
14:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
15:                  //					gsf Engineering	978-927-7189
16:                  //					Beverly, MA 01915
17:                  //
18:                  //		copyright (c) 2013 gsf Engineering (Beverly, MA USA) for SmartTrak Solar Systems Pvt, Hyderabad, AP, India
19:                  //
20:                  //*************************************************************************************************
21:                  //*******************************************************************************
22:                  /*FileName:       main.c
23:                  Dependencies:   See includes
24:                  Processor:      PIC32MX
25:                  
26:                  Complier:       Microchip MPLAB C32 v1.06 or higher
27:                  */
28:                  // *****************************************************************************
29:                  // *****************************************************************************
30:                  // Section: Includes
31:                  // *****************************************************************************
32:                  // *****************************************************************************
33:                  #include <GenericTypeDefs.h>
34:                  
35:                  //lint -e765					error 765: (Info -- external function could be made static)
36:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
37:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
38:                  //lint +e14
39:                  #include <legacy\int_3xx_4xx_legacy.h>	// required for various interrupt handlers
40:                  
41:                  
42:                  #define	DEFINE_GLOBALS
43:                  // NOTE: all header files that define global variables MUST be included here, even if the globals are not otherwise used in this file
44:                  #include "gsfstd.h"				// gsf standard #defines
45:                  #include "Debug.h"
46:                  #include "SmartTrak.h"			// Project wide definitions
47:                  #include "HardwareProfile.h"
48:                  #include "SerialPort.h"
49:                  #include "SerialDisplay.h"		// display functions for menus
50:                  #include "MenuFSM.h"
51:                  //#include "SST25VF016.h"		// SPI Flash function definitions
52:                  
53:                  //#include "init.h"
54:                  //#include "ADCRead.h"
55:                  //#include "Debounce.h"
56:                  //#include "CommandFSM.h"
57:                  //#include "MoveSequenceFSM.h"
58:                  #include "MotorPWM.h"			// Motor PWM function prototypes and definitions
59:                  #include "MotionFSM.h"			// Motion Control function prototypes and definitions
60:                  #include "MotionSensor.h"		// Motion Sensor (Hall Effect Encoder) function prototypes and definitions
61:                  //#include "MotionLimits.h"
62:                  //#include "MotionProfile.h"	// motion data table
63:                  #include "MotionStats.h"		// motion statistics for reporting
64:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
65:                  #include "EventFlags.h"			// event flag definitions and globals
66:                  
67:                  // MCU configuration bits
68:                  //lint -e766	error 766: (Info -- Header file 'MCUConfigurationBits.h' not used in module 'main.c')
69:                  #include "MCUConfigurationBits.h"
70:                  //lint +e776
71:                  
72:                  #undef	DEFINE_GLOBALS
73:                  
74:                  //----------------------------------------------------------------------
75:                  // Definitions
76:                  //----------------------------------------------------------------------
77:                  
78:                  // These are the counting periods for the medium (25mS) and slow (100mS) events, based on a 5mS tick
79:                  
80:                  #define _100MS_EVENT_PERIOD			(unsigned int)4			// 100ms period  @ 25mS
81:                  #define	_1S_EVENT_PERIOD			(unsigned int)40		// 1 Sec period @ 25mS
82:                  
83:                  // this is based on the 100mS tick
84:                  #define	_15S_EVENT_PERIOD			(unsigned int)150		// 15 Sec period @ 100mS
85:                  
86:                  enum tagMainErrors
87:                  {
88:                  	MAIN_ERROR_NONE = MAIN_ERROR_BASE,
89:                  	MAIN_ERROR_UNEXPECTED_TICK,				// 1 unexpected timer tick event
90:                  	MAIN_ERROR_UNEXPECTED_EVENT,			// 2 unexpected event
91:                  	MAIN_ERROR_INVALID_STATE,				// 3 not a valid state
92:                  	MAIN_ERROR_INVALID_SUBSTATE,			// 4 not a valid state
93:                  	MAIN_ERROR_UNKNOWN_COMMAND,				// 5 not a valid command
94:                  	MAIN_ERROR_25MS_TICK_OVERRUN,			// 6 unprocessed event flag
95:                  	MAIN_ERROR_100MS_TICK_OVERRUN,			// 7 unprocessed event flag
96:                  	MAIN_ERROR_1S_TICK_OVERRUN,				// 8 unprocessed event flag
97:                  	MAIN_ERROR_25MS_MOTION_TICK_OVERRUN,	// 9 unprocessed event flag
98:                  
99:                  	MAIN_ERROR_UNPROCESSED_EVENT = MAIN_ERROR_BASE + 0x0F
100:                 };
101:                 
102:                 
103:                 // 5mS Tick Time distribution FSM States
104:                 enum tag5mSTickStates
105:                 {
106:                     ST_5mS_TICK1,
107:                     ST_5mS_TICK2,
108:                     ST_5mS_TICK3,
109:                     ST_5mS_TICK4,
110:                     ST_5mS_TICK5
111:                 };
112:                 
113:                 enum tag5mSTickStates e5mSTickState = ST_5mS_TICK1;
114:                 
115:                 
116:                 // Panel Control sequencer FSM states
117:                 enum tagPanelControlStates
118:                 {
119:                 	ST_PANEL_IDLE,						// 0 power up and idle state
120:                 	ST_PANEL_STOPPED					// 1 motion complete
121:                 
122:                 };
123:                 
124:                 enum tagPanelControlStates ePumpState = ST_PANEL_IDLE;
125:                 
126:                 
127:                 //-----------------------------------------------------------------------------
128:                 // Static and File-Local Variables
129:                 //-----------------------------------------------------------------------------
130:                 //Bytebits Temp_bits;
131:                 unsigned char fgbSampleCnt;			// this could be a fixed macro...
132:                 
133:                 // This is a software counter used to time slower system events, such as button polling, etc.
134:                 FILE_GLOBAL_INIT unsigned int fg100mSTimerCount1 = _100MS_EVENT_PERIOD;
135:                 FILE_GLOBAL_INIT unsigned int fg100mSTimerCount2 = _100MS_EVENT_PERIOD;
136:                 FILE_GLOBAL_INIT unsigned int fg100mSTimerCount3 = _100MS_EVENT_PERIOD;
137:                 
138:                 
139:                 
140:                 // Let compile time pre-processor calculate the CORE_TICK_PERIOD
141:                 #define TOGGLES_PER_SEC			200
142:                 #define CORE_TICK_RATE	        (GetSystemClock()/2/TOGGLES_PER_SEC)
143:                 
144:                 // *****************************************************************************
145:                 // from C:\Program Files\Microchip\xc32\v1.20\pic32mx\include\peripheral\legacy\int_1xx_2xx_legacy.h:
146:                 // *****************************************************************************
147:                 // these macros only exist in the LEGACY header files.. why?
148:                 /*
149:                 #define mCTClearIntFlag()                   (IFS0CLR = _IFS0_CTIF_MASK)
150:                 #define mCTGetIntFlag()                     (IFS0bits.CTIF)
151:                 #define mCTIntEnable(enable)                (IEC0CLR = _IEC0_CTIE_MASK, IEC0SET = ((enable) << _IEC0_CTIE_POSITION))
152:                 #define mCTGetIntEnable()                   (IEC0bits.CTIE)
153:                 #define mCTSetIntPriority(priority)         (IPC0CLR = _IPC0_CTIP_MASK, IPC0SET = ((priority) << _IPC0_CTIP_POSITION))
154:                 #define mCTGetIntPriority()                 (IPC0bits.CTIP)
155:                 #define mCTSetIntSubPriority(subPriority)   (IPC0CLR = _IPC0_CTIS_MASK, IPC0SET = ((subPriority) << _IPC0_CTIS_POSITION))
156:                 #define mCTGetIntSubPriority()              (IPC0bits.CTIS)
157:                  */
158:                 // *****************************************************************************
159:                 
160:                 // *****************************************************************************
161:                 
162:                 // *****************************************************************************
163:                 // *****************************************************************************
164:                 // Section: Function Prototypes
165:                 // *****************************************************************************
166:                 // *****************************************************************************
167:                 
168:                 // *****************************************************************************
169:                 // *****************************************************************************
170:                 // Section: Constant Data
171:                 // *****************************************************************************
172:                 // *****************************************************************************
173:                 
174:                 // *****************************************************************************
175:                 // Section: Code
176:                 // *****************************************************************************
177:                 // *****************************************************************************
178:                 
179:                 // *****************************************************************************
180:                 // int main(void)
181:                 // *****************************************************************************
182:                 int main(void)
183:                  {
9D0080C8  27BDFFA0   ADDIU SP, SP, -96
9D0080CC  AFBF005C   SW RA, 92(SP)
9D0080D0  AFBE0058   SW S8, 88(SP)
9D0080D4  03A0F021   ADDU S8, SP, ZERO
9D0080D8  3C0204C4   LUI V0, 1220
9D0080DC  3442B400   ORI V0, V0, -19456
9D0080E0  AFC20010   SW V0, 16(S8)
9D0080E4  24020005   ADDIU V0, ZERO, 5
9D0080E8  AFC20014   SW V0, 20(S8)
184:                 
185:                 	// Configure the device for maximum performance, but do not change the PBDIV clock divisor.
186:                 	// Given the options, this function will change the program Flash wait states,
187:                 	// RAM wait state and enable prefetch cache, but will not change the PBDIV.
188:                 	// The PBDIV value is already set via the pragma FPBDIV option above.
189:                 	SYSTEMConfig(GetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
190:                 
191:                     // configure IOPORTS PORTD.RD0, RD1 as outputs
192:                     // could also use mPORTDSetPinsDigitalOut(BIT_6 | BIT_7);
193:                     PORTSetPinsDigitalOut(PORT_LEDS, PIN_LED1 | PIN_LED2 | PIN_LED3);
9D0083A0  24040003   ADDIU A0, ZERO, 3
9D0083A4  24050007   ADDIU A1, ZERO, 7
9D0083A8  0F403896   JAL PORTSetPinsDigitalOut
9D0083AC  00000000   NOP
194:                 
195:                     // initialize the port pins states = output low
196:                     PORTClearBits(PORT_LEDS, PIN_LED1 | PIN_LED2 | PIN_LED3);
9D0083B0  24040003   ADDIU A0, ZERO, 3
9D0083B4  24050007   ADDIU A1, ZERO, 7
9D0083B8  0F403987   JAL PORTClearBits
9D0083BC  00000000   NOP
197:                 
198:                     // PORTD.RD6, RD7, RD13 as inputs
199:                     // could also use mPORTDSetPinsDigitalIn(BIT_6 | BIT_7);
200:                     PORTSetPinsDigitalIn(PORT_SWITCHES, BIT_6 | BIT_7 | BIT_13);
9D0083C0  24040003   ADDIU A0, ZERO, 3
9D0083C4  240520C0   ADDIU A1, ZERO, 8384
9D0083C8  0F403887   JAL PORTSetPinsDigitalIn
9D0083CC  00000000   NOP
201:                 
202:                     //Initialize the DB_UTILS IO channel
203:                 	DBINIT();
204:                 
205:                     // Display a message
206:                     DBPRINTF("PIC32 RS-232 UART 2 Demo. \n");
207:                     DBPRINTF("Build date and time: (" __DATE__ "," __TIME__ ")\n");
208:                 
209:                     // configure the core timer roll-over rate (100msec)
210:                     OpenCoreTimer(CORE_TICK_RATE);
9D0083D0  3C020003   LUI V0, 3
9D0083D4  34440D40   ORI A0, V0, 3392
9D0083D8  0F403A2C   JAL OpenCoreTimer
9D0083DC  00000000   NOP
211:                 
212:                     // set up the core timer interrupt with a prioirty of 2 and zero sub-priority
213:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_2 | CT_INT_SUB_PRIOR_0));
9D0083E0  3C02BF88   LUI V0, -16504
9D0083E4  24030001   ADDIU V1, ZERO, 1
9D0083E8  AC431034   SW V1, 4148(V0)
9D0083EC  3C02BF88   LUI V0, -16504
9D0083F0  2403001C   ADDIU V1, ZERO, 28
9D0083F4  AC431094   SW V1, 4244(V0)
9D0083F8  3C02BF88   LUI V0, -16504
9D0083FC  24030008   ADDIU V1, ZERO, 8
9D008400  AC431098   SW V1, 4248(V0)
9D008404  3C02BF88   LUI V0, -16504
9D008408  24030003   ADDIU V1, ZERO, 3
9D00840C  AC431094   SW V1, 4244(V0)
9D008410  3C02BF88   LUI V0, -16504
9D008414  AC401098   SW ZERO, 4248(V0)
9D008418  3C02BF88   LUI V0, -16504
9D00841C  24030001   ADDIU V1, ZERO, 1
9D008420  AC431064   SW V1, 4196(V0)
9D008424  3C02BF88   LUI V0, -16504
9D008428  24030001   ADDIU V1, ZERO, 1
9D00842C  AC431068   SW V1, 4200(V0)
214:                 
215:                 	InitializeSerialPort(RS485_UART, DESIRED_RS232_BAUDRATE);
9D008430  24040001   ADDIU A0, ZERO, 1
9D008434  3405E100   ORI A1, ZERO, -7936
9D008438  0F4022B9   JAL InitializeSerialPort
9D00843C  00000000   NOP
216:                 	eSerialOutputMode = SER_MODE_MENU;
9D008440  24020001   ADDIU V0, ZERO, 1
9D008444  AF828070   SW V0, -32656(GP)
217:                 
218:                 	// configure for multi-vectored mode
219:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D008448  00002021   ADDU A0, ZERO, ZERO
9D00844C  0F403916   JAL INTConfigureSystem
9D008450  00000000   NOP
220:                 
221:                     // enable interrupts
222:                     INTEnableInterrupts();
9D008454  0F403A37   JAL INTEnableInterrupts
9D008458  00000000   NOP
223:                 
224:                     // enable device multi-vector interrupts
225:                     INTEnableSystemMultiVectoredInt();
9D00845C  0F403909   JAL INTEnableSystemMultiVectoredInt
9D008460  00000000   NOP
226:                 
227:                 	// initialize SST25 SPI flash
228:                 	if (InitSystemParameterTable() IS_NOT TRUE)
9D008464  0F403406   JAL InitSystemParameterTable
9D008468  00000000   NOP
9D00846C  00401821   ADDU V1, V0, ZERO
9D008470  24020001   ADDIU V0, ZERO, 1
9D008474  1062000D   BEQ V1, V0, 0x9D0084AC
9D008478  00000000   NOP
229:                 	{
230:                 		DisplayMessage(RS485_UART, "\x1B[2J\x1B[0;0H==SPI FLASH not found (Press a key to continue)", WAIT_FOR_DISPLAY);
9D00847C  24040001   ADDIU A0, ZERO, 1
9D008480  3C029D01   LUI V0, -25343
9D008484  2445E1E0   ADDIU A1, V0, -7712
9D008488  24060001   ADDIU A2, ZERO, 1
9D00848C  0F402E88   JAL DisplayMessage
9D008490  00000000   NOP
231:                 		while (AnyRxDataAvailable(RS485_UART) IS_FALSE)
9D008494  00000000   NOP
9D008498  24040001   ADDIU A0, ZERO, 1
9D00849C  0F402324   JAL AnyRxDataAvailable
9D0084A0  00000000   NOP
9D0084A4  1040FFFC   BEQ V0, ZERO, 0x9D008498
9D0084A8  00000000   NOP
232:                 			BLOCKING_DELAY;
233:                 	}
234:                 
235:                 	PWM_Init(MOTOR_AZIMUTH);
9D0084AC  00002021   ADDU A0, ZERO, ZERO
9D0084B0  0F402513   JAL PWM_Init
9D0084B4  00000000   NOP
236:                 	PWM_Init(MOTOR_ELEVATION);
9D0084B8  24040001   ADDIU A0, ZERO, 1
9D0084BC  0F402513   JAL PWM_Init
9D0084C0  00000000   NOP
237:                 	MotionSensor_Init();
9D0084C4  0F4019C4   JAL MotionSensor_Init
9D0084C8  00000000   NOP
9D0084CC  0B402136   J 0x9D0084D8
9D0084D0  00000000   NOP
238:                 
239:                 	// ************************************************************************
240:                 	//							main() loop / scheduler
241:                 	// ************************************************************************
242:                 	for(;;)
243:                 		{
244:                 		// This is the main software loop.  The watchdog timer is cleared and the flags are polled for various event handlers.
245:                 		// All events are scheduled using timer interrupts and software counters.
246:                 
247:                 //		ClrWdt();		// Clear the watchdog timer
248:                 
249:                 
250:                 		//-----------------------------------------------------------------
251:                 		//	Motion Sensor Tick handler executes as required
252:                 		//-----------------------------------------------------------------
253:                 		// for any 'speed' greater than MotionProfileSpeedAndPWM[??] results in a MSI tick FASTER than 5mS, so we need to process this FIRST
254:                 		if (IS_BITSET(efMotionSensorEvents[MOTOR_AZIMUTH], EF_MOTION_SENSOR_TICK))
9D0084D8  978280D8   LHU V0, -32552(GP)
9D0084DC  30420002   ANDI V0, V0, 2
9D0084E0  10400004   BEQ V0, ZERO, 0x9D0084F4
9D0084E4  00000000   NOP
255:                 			{
256:                 			MotionSensor_Tick(MOTOR_AZIMUTH);			// processes current speed for PWM adjustments
9D0084E8  00002021   ADDU A0, ZERO, ZERO
9D0084EC  0F4019F4   JAL MotionSensor_Tick
9D0084F0  00000000   NOP
257:                 
258:                 			//continue;				// we have processed something, so restart at the top of the loop
259:                 			}
260:                 
261:                 		if (IS_BITSET(efMotionSensorEvents[MOTOR_ELEVATION], EF_MOTION_SENSOR_TICK))
9D0084F4  978280DA   LHU V0, -32550(GP)
9D0084F8  30420002   ANDI V0, V0, 2
9D0084FC  10400004   BEQ V0, ZERO, 0x9D008510
9D008500  00000000   NOP
262:                 			{
263:                 			MotionSensor_Tick(MOTOR_ELEVATION);			// processes current speed for PWM adjustments
9D008504  24040001   ADDIU A0, ZERO, 1
9D008508  0F4019F4   JAL MotionSensor_Tick
9D00850C  00000000   NOP
264:                 
265:                 			//continue;				// we have processed something, so restart at the top of the loop
266:                 			}
267:                 
268:                 
269:                 		//-----------------------------------------------------------------
270:                 		//	ADC Tick handler executes as required
271:                 		//-----------------------------------------------------------------
272:                 		// the ADC interrupt is supposed to occur at a 6KHz rate, but it does not (currently) do so
273:                 
274:                 		if (IS_BITSET(efADCEvents, EF_ADC_CONVERSION_DONE))
275:                 			{
276:                 			//ADC_Tick();				// processes and interprets ADC values
277:                 
278:                 //			continue;				// we have processed something, so restart at the top of the loop
279:                 			}
280:                 
281:                 
282:                 		//-----------------------------------------------------------------
283:                 		// Generate Sub-timer Event Flags on 5mS tick
284:                 		//-----------------------------------------------------------------
285:                 
286:                 		if (IS_BITSET(efTimerEvents, EF_TIMER_5MS_TICK_INT))
9D008510  978280EE   LHU V0, -32530(GP)
9D008514  30420001   ANDI V0, V0, 1
9D008518  304200FF   ANDI V0, V0, 255
9D00851C  1040008E   BEQ V0, ZERO, 0x9D008758
9D008520  00000000   NOP
287:                 			{
288:                 			// clear event flag (5mS event overrun is handled in the 5mS timer interrupt)
289:                 			BITCLEAR(efTimerEvents, EF_TIMER_5MS_TICK_INT);
9D008524  978380EE   LHU V1, -32530(GP)
9D008528  2402FFFE   ADDIU V0, ZERO, -2
9D00852C  00621024   AND V0, V1, V0
9D008530  3042FFFF   ANDI V0, V0, -1
9D008534  A78280EE   SH V0, -32530(GP)
290:                 
291:                 			// handle 5mS events
292:                 			//Input_Debounce_FSM(FALSE);		// input switch debounce handling
293:                 
294:                 			// each of these states occurs once every 25mS, so we can distribute slower events across different 5mS ticks
295:                 			// there is no need for 5mS tick counters, because this is a 5 state FSM, called every 5mS
296:                 			switch (e5mSTickState)
9D008538  8F8280F4   LW V0, -32524(GP)
9D00853C  2C430005   SLTIU V1, V0, 5
9D008540  1060006D   BEQ V1, ZERO, 0x9D0086F8
9D008544  00000000   NOP
9D008548  00021880   SLL V1, V0, 2
9D00854C  3C029D01   LUI V0, -25343
9D008550  24428564   ADDIU V0, V0, -31388
9D008554  00621021   ADDU V0, V1, V0
9D008558  8C420000   LW V0, 0(V0)
9D00855C  00400008   JR V0
9D008560  00000000   NOP
297:                 				{
298:                 				//-------------------------------
299:                 				//			5mS Tick 1
300:                 				//-------------------------------
301:                 				case ST_5mS_TICK1:
302:                 					// check for 25mS event overrun
303:                 					if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK1))
9D008578  978280F0   LHU V0, -32528(GP)
9D00857C  30420001   ANDI V0, V0, 1
9D008580  304200FF   ANDI V0, V0, 255
9D008584  10400004   BEQ V0, ZERO, 0x9D008598
9D008588  00000000   NOP
304:                 						{
305:                 						RuntimeError(MAIN_ERROR_25MS_TICK_OVERRUN);
9D00858C  24040026   ADDIU A0, ZERO, 38
9D008590  0F40365E   JAL _RuntimeError
9D008594  00000000   NOP
306:                 						}
307:                 
308:                 					BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK1);
9D008598  978280F0   LHU V0, -32528(GP)
9D00859C  34420001   ORI V0, V0, 1
9D0085A0  3042FFFF   ANDI V0, V0, -1
9D0085A4  A78280F0   SH V0, -32528(GP)
309:                 					e5mSTickState = ST_5mS_TICK2;			// bump state for next tick
9D0085A8  24020001   ADDIU V0, ZERO, 1
9D0085AC  AF8280F4   SW V0, -32524(GP)
310:                 					break;
9D0085B0  0B4021BE   J 0x9D0086F8
9D0085B4  00000000   NOP
311:                 
312:                 				//-------------------------------
313:                 				//			5mS Tick 2
314:                 				//-------------------------------
315:                 				case ST_5mS_TICK2:
316:                 					// check for 25mS event overrun
317:                 					if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK2))
9D0085B8  978280F0   LHU V0, -32528(GP)
9D0085BC  30420002   ANDI V0, V0, 2
9D0085C0  10400004   BEQ V0, ZERO, 0x9D0085D4
9D0085C4  00000000   NOP
318:                 						{
319:                 						RuntimeError(MAIN_ERROR_25MS_TICK_OVERRUN);
9D0085C8  24040026   ADDIU A0, ZERO, 38
9D0085CC  0F40365E   JAL _RuntimeError
9D0085D0  00000000   NOP
320:                 						}
321:                 
322:                 					BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK2);
9D0085D4  978280F0   LHU V0, -32528(GP)
9D0085D8  34420002   ORI V0, V0, 2
9D0085DC  3042FFFF   ANDI V0, V0, -1
9D0085E0  A78280F0   SH V0, -32528(GP)
323:                 					e5mSTickState = ST_5mS_TICK3;			// bump state for next tick
9D0085E4  24020002   ADDIU V0, ZERO, 2
9D0085E8  AF8280F4   SW V0, -32524(GP)
324:                 					break;
9D0085EC  0B4021BE   J 0x9D0086F8
9D0085F0  00000000   NOP
325:                 
326:                 				//-------------------------------
327:                 				//			5mS Tick 3
328:                 				//-------------------------------
329:                 				case ST_5mS_TICK3:
330:                 					// check for 25mS event overrun
331:                 					if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK3))
9D0085F4  978280F0   LHU V0, -32528(GP)
9D0085F8  30420004   ANDI V0, V0, 4
9D0085FC  10400004   BEQ V0, ZERO, 0x9D008610
9D008600  00000000   NOP
332:                 						{
333:                 						RuntimeError(MAIN_ERROR_25MS_TICK_OVERRUN);
9D008604  24040026   ADDIU A0, ZERO, 38
9D008608  0F40365E   JAL _RuntimeError
9D00860C  00000000   NOP
334:                 						}
335:                 
336:                 					BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK3);
9D008610  978280F0   LHU V0, -32528(GP)
9D008614  34420004   ORI V0, V0, 4
9D008618  3042FFFF   ANDI V0, V0, -1
9D00861C  A78280F0   SH V0, -32528(GP)
337:                 					e5mSTickState = ST_5mS_TICK4;			// bump state for next tick
9D008620  24020003   ADDIU V0, ZERO, 3
9D008624  AF8280F4   SW V0, -32524(GP)
338:                 					break;
9D008628  0B4021BE   J 0x9D0086F8
9D00862C  00000000   NOP
339:                 
340:                 				//-------------------------------
341:                 				//			5mS Tick 4
342:                 				//-------------------------------
343:                 				case ST_5mS_TICK4:
344:                 					// ==> this delay may be anything UP TO 25mS; the start of the delay is asynchronous, but the end is always on Tick4
345:                 					if (IS_BITSET(efTimerEvents, EF_TIMER_MOTION))
9D008630  978280EE   LHU V0, -32530(GP)
9D008634  30420020   ANDI V0, V0, 32
9D008638  1040000E   BEQ V0, ZERO, 0x9D008674
9D00863C  00000000   NOP
346:                 						{
347:                 						// motion timer is enabled
348:                 
349:                 						// check for 25mS Motion Timer event overrun
350:                 						if (IS_BITSET(efTimerEvents, EF_TIMER_MOTION_25MS_TICK))
9D008640  978280EE   LHU V0, -32530(GP)
9D008644  30420040   ANDI V0, V0, 64
9D008648  10400004   BEQ V0, ZERO, 0x9D00865C
9D00864C  00000000   NOP
351:                 							{
352:                 							RuntimeError(MAIN_ERROR_25MS_MOTION_TICK_OVERRUN);
9D008650  24040029   ADDIU A0, ZERO, 41
9D008654  0F40365E   JAL _RuntimeError
9D008658  00000000   NOP
353:                 							}
354:                 
355:                 						// set event flag; processed by MotionFSM
356:                 						BITSET(efTimerEvents, EF_TIMER_MOTION_25MS_TICK);
9D00865C  978280EE   LHU V0, -32530(GP)
9D008660  34420040   ORI V0, V0, 64
9D008664  3042FFFF   ANDI V0, V0, -1
9D008668  A78280EE   SH V0, -32530(GP)
9D00866C  0B4021A2   J 0x9D008688
9D008670  00000000   NOP
357:                 						}
358:                 					else
359:                 						{
360:                 						// make sure event is reset for next use
361:                 						BITCLEAR(efTimerEvents, EF_TIMER_MOTION_25MS_TICK);
9D008674  978380EE   LHU V1, -32530(GP)
9D008678  2402FFBF   ADDIU V0, ZERO, -65
9D00867C  00621024   AND V0, V1, V0
9D008680  3042FFFF   ANDI V0, V0, -1
9D008684  A78280EE   SH V0, -32530(GP)
362:                 						}
363:                 
364:                 					// check for 25mS event overrun
365:                 					if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK4))
9D008688  978280F0   LHU V0, -32528(GP)
9D00868C  30420008   ANDI V0, V0, 8
9D008690  10400004   BEQ V0, ZERO, 0x9D0086A4
9D008694  00000000   NOP
366:                 						{
367:                 						RuntimeError(MAIN_ERROR_25MS_TICK_OVERRUN);
9D008698  24040026   ADDIU A0, ZERO, 38
9D00869C  0F40365E   JAL _RuntimeError
9D0086A0  00000000   NOP
368:                 						}
369:                 
370:                 					BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK4);
9D0086A4  978280F0   LHU V0, -32528(GP)
9D0086A8  34420008   ORI V0, V0, 8
9D0086AC  3042FFFF   ANDI V0, V0, -1
9D0086B0  A78280F0   SH V0, -32528(GP)
371:                 
372:                 					e5mSTickState = ST_5mS_TICK5;			// bump state for next tick
9D0086B4  24020004   ADDIU V0, ZERO, 4
9D0086B8  AF8280F4   SW V0, -32524(GP)
373:                 					break;
9D0086BC  0B4021BE   J 0x9D0086F8
9D0086C0  00000000   NOP
374:                 
375:                 				//-------------------------------
376:                 				//			5mS Tick 5
377:                 				//-------------------------------
378:                 				case ST_5mS_TICK5:
379:                 					// check for 25mS event overrun
380:                 					if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK5))
9D0086C4  978280F0   LHU V0, -32528(GP)
9D0086C8  30420010   ANDI V0, V0, 16
9D0086CC  10400004   BEQ V0, ZERO, 0x9D0086E0
9D0086D0  00000000   NOP
381:                 						{
382:                 						RuntimeError(MAIN_ERROR_25MS_TICK_OVERRUN);
9D0086D4  24040026   ADDIU A0, ZERO, 38
9D0086D8  0F40365E   JAL _RuntimeError
9D0086DC  00000000   NOP
383:                 						}
384:                 
385:                 					BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK5);
9D0086E0  978280F0   LHU V0, -32528(GP)
9D0086E4  34420010   ORI V0, V0, 16
9D0086E8  3042FFFF   ANDI V0, V0, -1
9D0086EC  A78280F0   SH V0, -32528(GP)
386:                 					e5mSTickState = ST_5mS_TICK1;			// bump state for next tick
9D0086F0  AF8080F4   SW ZERO, -32524(GP)
387:                 					break;
9D0086F4  00000000   NOP
388:                 
389:                 				}
390:                 
391:                 
392:                 			//-----------------------------------------------------------------
393:                 			// Check for non-timer based events to be processed every 5mS
394:                 			//-----------------------------------------------------------------
395:                 
396:                 			// these events should be executed whenever there are non-zero event flags - but not SO often that they completely tie up the system.
397:                 			// a sticky (unprocessed) event here will completely kill the system..
398:                 
399:                 			// if there is a switch UP event, we want to process it immediately
400:                 //			if ( (efCommandEvents IS_NOT (WORD)0) OR ((efSwitchEvents & EF_SWITCH_UP_EVENTS_MASK) IS_NOT (WORD)0) )
401:                 			if ( (efMotionResultEvents[MOTOR_AZIMUTH] IS_NOT NO_EVENTFLAGS) OR (efMotionResultEvents[MOTOR_ELEVATION] IS_NOT NO_EVENTFLAGS) OR ((efSwitchEvents & EF_SWITCH_UP_EVENTS_MASK) IS_NOT (WORD)0) )
9D0086F8  978280E4   LHU V0, -32540(GP)
9D0086FC  14400008   BNE V0, ZERO, 0x9D008720
9D008700  00000000   NOP
9D008704  978280E6   LHU V0, -32538(GP)
9D008708  14400005   BNE V0, ZERO, 0x9D008720
9D00870C  00000000   NOP
9D008710  978280EC   LHU V0, -32532(GP)
9D008714  30420300   ANDI V0, V0, 768
9D008718  10400003   BEQ V0, ZERO, 0x9D008728
9D00871C  00000000   NOP
402:                 				{
403:                 				//CommandFSM();			// event(s) to be processed, so run the Move Command FSM without waiting for the timer
404:                 
405:                 				continue;				// we have processed something, so restart at the top of the loop
9D008720  0B402262   J 0x9D008988
9D008724  00000000   NOP
406:                 				}
407:                 
408:                 			// run the MotionFSM second, because it has some slightly sticky events that would prevent the CommandFSM from running
409:                 			if ((efMotionEvents[MOTOR_AZIMUTH] IS_NOT NO_EVENTFLAGS) OR (efMotionEvents[MOTOR_ELEVATION] IS_NOT NO_EVENTFLAGS) OR (IS_BITSET(efTimerEvents, EF_TIMER_MOTION_25MS_TICK)))		// <== kludge?
9D008728  978280E8   LHU V0, -32536(GP)
9D00872C  14400008   BNE V0, ZERO, 0x9D008750
9D008730  00000000   NOP
9D008734  978280EA   LHU V0, -32534(GP)
9D008738  14400005   BNE V0, ZERO, 0x9D008750
9D00873C  00000000   NOP
9D008740  978280EE   LHU V0, -32530(GP)
9D008744  30420040   ANDI V0, V0, 64
9D008748  10400003   BEQ V0, ZERO, 0x9D008758
9D00874C  00000000   NOP
410:                 
411:                 				{
412:                 				//MotionFSM();			// event(s) to be processed, so run the Motion FSM without waiting for the timer
413:                 
414:                 				continue;				// we have processed something, so restart at the top of the loop
9D008750  0B402262   J 0x9D008988
9D008754  00000000   NOP
415:                 				}
416:                 
417:                 			}		// end if (IS_BITSET(efTimerEvents, EF_TIMER_5MS_TICK_INT))
418:                 
419:                 
420:                 		//-----------------------------------------------------------------
421:                 		//		Handle 25mS Tick events
422:                 		//-----------------------------------------------------------------
423:                 		// these events are tied to 25mS ticks, and the use of multiple 25mS tick flags forces them to be distributed in time
424:                 
425:                 		//-------------------------------
426:                 		//			25mS Tick 1
427:                 		//-------------------------------
428:                 		// enabled by:	(efTimerEvents, EF_TIMER_AUTO_CENTER)
429:                 		// tick:		(efTimerEvents, EF_TIMER_25MS_TICK1)
430:                 		// duration:	_1S_EVENT_PERIOD
431:                 		// counter:		fgAutoCenterDelayTimerCount
432:                 		// output:		(efTimerEvents, EF_TIMER_AUTO_CENTER_1S_TICK)
433:                 
434:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK1))
9D008758  978280F0   LHU V0, -32528(GP)
9D00875C  30420001   ANDI V0, V0, 1
9D008760  304200FF   ANDI V0, V0, 255
9D008764  10400006   BEQ V0, ZERO, 0x9D008780
9D008768  00000000   NOP
435:                 			{
436:                 			// clear calling event
437:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_25MS_TICK1);
9D00876C  978380F0   LHU V1, -32528(GP)
9D008770  2402FFFE   ADDIU V0, ZERO, -2
9D008774  00621024   AND V0, V1, V0
9D008778  3042FFFF   ANDI V0, V0, -1
9D00877C  A78280F0   SH V0, -32528(GP)
438:                 			}
439:                 
440:                 
441:                 		//-------------------------------
442:                 		//			25mS Tick 2
443:                 		//-------------------------------
444:                 		// enabled by:	none
445:                 		// tick:		(efTimerEvents, EF_TIMER_25MS_TICK2)
446:                 		// duration:	1 tick
447:                 		// counter:		none
448:                 		// output:		call MotionFSM
449:                 
450:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK2))
9D008780  978280F0   LHU V0, -32528(GP)
9D008784  30420002   ANDI V0, V0, 2
9D008788  10400008   BEQ V0, ZERO, 0x9D0087AC
9D00878C  00000000   NOP
451:                 			{
452:                 			// run Motion Control FSM on a timed basis
453:                 			//MotionFSM();
454:                 
455:                 			// clear calling event
456:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_25MS_TICK2);
9D008790  978380F0   LHU V1, -32528(GP)
9D008794  2402FFFD   ADDIU V0, ZERO, -3
9D008798  00621024   AND V0, V1, V0
9D00879C  3042FFFF   ANDI V0, V0, -1
9D0087A0  A78280F0   SH V0, -32528(GP)
457:                 
458:                 			continue;				// we have processed something, so restart at the top of the loop
9D0087A4  0B402262   J 0x9D008988
9D0087A8  00000000   NOP
459:                 			}
460:                 
461:                 
462:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK3))
9D0087AC  978280F0   LHU V0, -32528(GP)
9D0087B0  30420004   ANDI V0, V0, 4
9D0087B4  1040001B   BEQ V0, ZERO, 0x9D008824
9D0087B8  00000000   NOP
463:                 			{
464:                 			// run Menu FSM on a timed basis
465:                 			MenuFSM(RS485_UART);
9D0087BC  24040001   ADDIU A0, ZERO, 1
9D0087C0  0F400008   JAL MenuFSM
9D0087C4  00000000   NOP
466:                 
467:                 			// bump 100mS tick counter
468:                 			fg100mSTimerCount1--;
9D0087C8  8F828030   LW V0, -32720(GP)
9D0087CC  2442FFFF   ADDIU V0, V0, -1
9D0087D0  AF828030   SW V0, -32720(GP)
469:                 
470:                 			// check for timer complete - or (ACK!) rolled under
471:                 			if ((fg100mSTimerCount1 == (unsigned int)0) OR  (fg100mSTimerCount1 > _100MS_EVENT_PERIOD))
9D0087D4  8F828030   LW V0, -32720(GP)
9D0087D8  10400005   BEQ V0, ZERO, 0x9D0087F0
9D0087DC  00000000   NOP
9D0087E0  8F828030   LW V0, -32720(GP)
9D0087E4  2C420005   SLTIU V0, V0, 5
9D0087E8  14400007   BNE V0, ZERO, 0x9D008808
9D0087EC  00000000   NOP
472:                 				{
473:                 				// no need to check for overrun on 100mS events
474:                 
475:                 				// set event flag
476:                 				BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK1);
9D0087F0  978280F0   LHU V0, -32528(GP)
9D0087F4  34420020   ORI V0, V0, 32
9D0087F8  3042FFFF   ANDI V0, V0, -1
9D0087FC  A78280F0   SH V0, -32528(GP)
477:                 
478:                 				// reload timer
479:                 				fg100mSTimerCount1 = _100MS_EVENT_PERIOD;
9D008800  24020004   ADDIU V0, ZERO, 4
9D008804  AF828030   SW V0, -32720(GP)
480:                 				}
481:                 
482:                 
483:                 			// clear calling event
484:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_25MS_TICK3);
9D008808  978380F0   LHU V1, -32528(GP)
9D00880C  2402FFFB   ADDIU V0, ZERO, -5
9D008810  00621024   AND V0, V1, V0
9D008814  3042FFFF   ANDI V0, V0, -1
9D008818  A78280F0   SH V0, -32528(GP)
485:                 
486:                 			continue;				// we have processed something, so restart at the top of the loop
9D00881C  0B402262   J 0x9D008988
9D008820  00000000   NOP
487:                 			}
488:                 
489:                 
490:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK4))
9D008824  978280F0   LHU V0, -32528(GP)
9D008828  30420008   ANDI V0, V0, 8
9D00882C  10400018   BEQ V0, ZERO, 0x9D008890
9D008830  00000000   NOP
491:                 			{
492:                 			// bump 100mS tick counter
493:                 			fg100mSTimerCount2--;
9D008834  8F828034   LW V0, -32716(GP)
9D008838  2442FFFF   ADDIU V0, V0, -1
9D00883C  AF828034   SW V0, -32716(GP)
494:                 
495:                 			// check for timer complete - or (ACK!) rolled under
496:                 			if ((fg100mSTimerCount2 == (unsigned int)0) OR  (fg100mSTimerCount2 > _100MS_EVENT_PERIOD))
9D008840  8F828034   LW V0, -32716(GP)
9D008844  10400005   BEQ V0, ZERO, 0x9D00885C
9D008848  00000000   NOP
9D00884C  8F828034   LW V0, -32716(GP)
9D008850  2C420005   SLTIU V0, V0, 5
9D008854  14400007   BNE V0, ZERO, 0x9D008874
9D008858  00000000   NOP
497:                 				{
498:                 				// no need to check for overrun on 100mS events
499:                 
500:                 				// set event flag
501:                 				BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK2);
9D00885C  978280F0   LHU V0, -32528(GP)
9D008860  34420040   ORI V0, V0, 64
9D008864  3042FFFF   ANDI V0, V0, -1
9D008868  A78280F0   SH V0, -32528(GP)
502:                 
503:                 				// reload timer
504:                 				fg100mSTimerCount2 = _100MS_EVENT_PERIOD;
9D00886C  24020004   ADDIU V0, ZERO, 4
9D008870  AF828034   SW V0, -32716(GP)
505:                 				}
506:                 
507:                 
508:                 			// clear calling event
509:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_25MS_TICK4);
9D008874  978380F0   LHU V1, -32528(GP)
9D008878  2402FFF7   ADDIU V0, ZERO, -9
9D00887C  00621024   AND V0, V1, V0
9D008880  3042FFFF   ANDI V0, V0, -1
9D008884  A78280F0   SH V0, -32528(GP)
510:                 
511:                 			continue;				// we have processed something, so restart at the top of the loop
9D008888  0B402262   J 0x9D008988
9D00888C  00000000   NOP
512:                 			}
513:                 
514:                 
515:                 
516:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_25MS_TICK5))
9D008890  978280F0   LHU V0, -32528(GP)
9D008894  30420010   ANDI V0, V0, 16
9D008898  10400018   BEQ V0, ZERO, 0x9D0088FC
9D00889C  00000000   NOP
517:                 			{
518:                 			// bump 100mS tick counter
519:                 			fg100mSTimerCount3--;
9D0088A0  8F828038   LW V0, -32712(GP)
9D0088A4  2442FFFF   ADDIU V0, V0, -1
9D0088A8  AF828038   SW V0, -32712(GP)
520:                 
521:                 			// check for timer complete - or (ACK!) rolled under
522:                 			if ((fg100mSTimerCount3 == (unsigned int)0) OR  (fg100mSTimerCount3 > _100MS_EVENT_PERIOD))
9D0088AC  8F828038   LW V0, -32712(GP)
9D0088B0  10400005   BEQ V0, ZERO, 0x9D0088C8
9D0088B4  00000000   NOP
9D0088B8  8F828038   LW V0, -32712(GP)
9D0088BC  2C420005   SLTIU V0, V0, 5
9D0088C0  14400007   BNE V0, ZERO, 0x9D0088E0
9D0088C4  00000000   NOP
523:                 				{
524:                 				// no need to check for overrun on 100mS events
525:                 
526:                 				// set event flag
527:                 				BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK3);
9D0088C8  978280F0   LHU V0, -32528(GP)
9D0088CC  34420080   ORI V0, V0, 128
9D0088D0  3042FFFF   ANDI V0, V0, -1
9D0088D4  A78280F0   SH V0, -32528(GP)
528:                 
529:                 				// reload timer
530:                 				fg100mSTimerCount3 = _100MS_EVENT_PERIOD;
9D0088D8  24020004   ADDIU V0, ZERO, 4
9D0088DC  AF828038   SW V0, -32712(GP)
531:                 				}
532:                 
533:                 
534:                 			// clear calling event
535:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_25MS_TICK5);
9D0088E0  978380F0   LHU V1, -32528(GP)
9D0088E4  2402FFEF   ADDIU V0, ZERO, -17
9D0088E8  00621024   AND V0, V1, V0
9D0088EC  3042FFFF   ANDI V0, V0, -1
9D0088F0  A78280F0   SH V0, -32528(GP)
536:                 
537:                 			continue;				// we have processed something, so restart at the top of the loop
9D0088F4  0B402262   J 0x9D008988
9D0088F8  00000000   NOP
538:                 			}
539:                 
540:                 
541:                 		//-----------------------------------------------------------------
542:                 		//		Handle 100mS Tick events
543:                 		//-----------------------------------------------------------------
544:                 
545:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK1))
9D0088FC  978280F0   LHU V0, -32528(GP)
9D008900  30420020   ANDI V0, V0, 32
9D008904  1040000B   BEQ V0, ZERO, 0x9D008934
9D008908  00000000   NOP
546:                 			{
547:                 			// .. Toggle the LED
548:                 			mPORTDToggleBits(BIT_0);
9D00890C  3C02BF88   LUI V0, -16504
9D008910  24030001   ADDIU V1, ZERO, 1
9D008914  AC4360EC   SW V1, 24812(V0)
549:                 
550:                 			// run event
551:                 //			DebugLEDsTick();
552:                 
553:                 			//MoveSequenceTick();
554:                 #ifdef NOTDEF
555:                 			// handle Hard Stall Reset Delay Timer
556:                 			if (IS_BITSET(efTimerEvents, EF_TIMER_HARD_STALL))
557:                 				{
558:                 				// Hard Stall Reset Delay timer is enabled
559:                 
560:                 				// bump Hard Stall Reset Delay timer
561:                 				fgHardStallResetDelayTimerCount--;
562:                 
563:                 				if ( fgHardStallResetDelayTimerCount == 0 )
564:                 					{
565:                 					// Hard Stall has timed out, reset MCU
566:                 					Reset();							// reset MCU
567:                 					}
568:                 				}
569:                 			else
570:                 				{
571:                 				// make sure timer is reset for next use
572:                 				fgHardStallResetDelayTimerCount = _15S_EVENT_PERIOD;
573:                 				BITCLEAR(efTimerEvents, EF_TIMER_HARD_STALL_TIMEOUT);
574:                 				}
575:                 #endif
576:                 
577:                 			// clear calling event flag
578:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_100MS_TICK1);
9D008918  978380F0   LHU V1, -32528(GP)
9D00891C  2402FFDF   ADDIU V0, ZERO, -33
9D008920  00621024   AND V0, V1, V0
9D008924  3042FFFF   ANDI V0, V0, -1
9D008928  A78280F0   SH V0, -32528(GP)
579:                 
580:                 			continue;				// we have processed something, so restart at the top of the loop
9D00892C  0B402262   J 0x9D008988
9D008930  00000000   NOP
581:                 			}
582:                 
583:                 
584:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK2))
9D008934  978280F0   LHU V0, -32528(GP)
9D008938  30420040   ANDI V0, V0, 64
9D00893C  10400008   BEQ V0, ZERO, 0x9D008960
9D008940  00000000   NOP
585:                 			{
586:                 			// run event
587:                 //			AppLEDsTick();
588:                 
589:                 
590:                 			//if ((efMoveSequenceEvents IS_NOT NO_EVENTFLAGS) OR (IsMoveSequenceComplete() IS_FALSE))
591:                 				//MoveSequenceFSM();
592:                 
593:                 
594:                 			// clear calling event flag
595:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_100MS_TICK2);
9D008944  978380F0   LHU V1, -32528(GP)
9D008948  2402FFBF   ADDIU V0, ZERO, -65
9D00894C  00621024   AND V0, V1, V0
9D008950  3042FFFF   ANDI V0, V0, -1
9D008954  A78280F0   SH V0, -32528(GP)
596:                 
597:                 			continue;				// we have processed something, so restart at the top of the loop
9D008958  0B402262   J 0x9D008988
9D00895C  00000000   NOP
598:                 			}
599:                 
600:                 
601:                 		if (IS_BITSET(efSchedulerEvents, EF_SCHED_100MS_TICK3))
9D008960  978280F0   LHU V0, -32528(GP)
9D008964  30420080   ANDI V0, V0, 128
9D008968  1040FEDA   BEQ V0, ZERO, 0x9D0084D4
9D00896C  00000000   NOP
602:                 			{
603:                 			// run event
604:                 			//CommandFSM();
605:                 			//StartTransmitString(RS485_UART, "This is a test!");
606:                 
607:                 
608:                 			// clear calling event flag
609:                 			BITCLEAR(efSchedulerEvents, EF_SCHED_100MS_TICK3);
9D008970  978380F0   LHU V1, -32528(GP)
9D008974  2402FF7F   ADDIU V0, ZERO, -129
9D008978  00621024   AND V0, V1, V0
9D00897C  3042FFFF   ANDI V0, V0, -1
9D008980  A78280F0   SH V0, -32528(GP)
610:                 
611:                 			continue;				// we have processed something, so restart at the top of the loop
9D008984  00000000   NOP
612:                 			}
613:                 
614:                 #ifdef NOTDEF
615:                 		// this is an incomplete effort at providing a software restart..
616:                 		if (pgbTerminate IS_TRUE)
617:                 			{
618:                 			break;					// exit while loop, exit main(), restart
619:                 			}
620:                 #endif
621:                    		}		// end for(;;)
9D0084D4  00000000   NOP
9D008988  0B402136   J 0x9D0084D8
9D00898C  00000000   NOP
622:                 
623:                 
624:                 }
625:                 
626:                 
627:                 void __ISR(_CORE_TIMER_VECTOR, ipl2) CoreTimerHandler(void)
628:                 {
9D008990  415DE800   RDPGPR SP, SP
9D008994  401A7000   MFC0 K0, EPC
9D008998  401B6000   MFC0 K1, Status
9D00899C  27BDFF90   ADDIU SP, SP, -112
9D0089A0  AFBA006C   SW K0, 108(SP)
9D0089A4  AFBB0068   SW K1, 104(SP)
9D0089A8  7C1B7844   INS K1, ZERO, 1, 15
9D0089AC  377B0800   ORI K1, K1, 2048
9D0089B0  409B6000   MTC0 K1, Status
9D0089B4  AFBF005C   SW RA, 92(SP)
9D0089B8  AFBE0058   SW S8, 88(SP)
9D0089BC  AFB90054   SW T9, 84(SP)
9D0089C0  AFB80050   SW T8, 80(SP)
9D0089C4  AFAF004C   SW T7, 76(SP)
9D0089C8  AFAE0048   SW T6, 72(SP)
9D0089CC  AFAD0044   SW T5, 68(SP)
9D0089D0  AFAC0040   SW T4, 64(SP)
9D0089D4  AFAB003C   SW T3, 60(SP)
9D0089D8  AFAA0038   SW T2, 56(SP)
9D0089DC  AFA90034   SW T1, 52(SP)
9D0089E0  AFA80030   SW T0, 48(SP)
9D0089E4  AFA7002C   SW A3, 44(SP)
9D0089E8  AFA60028   SW A2, 40(SP)
9D0089EC  AFA50024   SW A1, 36(SP)
9D0089F0  AFA40020   SW A0, 32(SP)
9D0089F4  AFA3001C   SW V1, 28(SP)
9D0089F8  AFA20018   SW V0, 24(SP)
9D0089FC  AFA10014   SW AT, 20(SP)
9D008A00  00001012   MFLO V0
9D008A04  AFA20064   SW V0, 100(SP)
9D008A08  00001810   MFHI V1
9D008A0C  AFA30060   SW V1, 96(SP)
9D008A10  03A0F021   ADDU S8, SP, ZERO
629:                     // .. things to do
630:                 
631:                 	//***********************************************
632:                 	//				5mS Tick
633:                 	//***********************************************
634:                 	// 5mS tick is generated from Core Timer
635:                 
636:                 	// check for 5mS event overrun
637:                 	if (IS_BITSET(efTimerEvents, EF_TIMER_5MS_TICK_INT))
9D008A14  978280EE   LHU V0, -32530(GP)
9D008A18  30420001   ANDI V0, V0, 1
9D008A1C  304200FF   ANDI V0, V0, 255
9D008A20  10400004   BEQ V0, ZERO, 0x9D008A34
9D008A24  00000000   NOP
638:                 		{
639:                 		RuntimeError(TIMER_ERROR_5MS_TICK_OVERRUN);
9D008A28  240400C5   ADDIU A0, ZERO, 197
9D008A2C  0F40365E   JAL _RuntimeError
9D008A30  00000000   NOP
640:                 
641:                 		// hardware marker for oscilloscope trigger
642:                 		//PULSE_DEBUG_PIN1;
643:                 		}
644:                 
645:                 	// reload the counter (update the period)
646:                     UpdateCoreTimer(CORE_TICK_RATE);
9D008A34  3C020003   LUI V0, 3
9D008A38  34440D40   ORI A0, V0, 3392
9D008A3C  0F403A28   JAL UpdateCoreTimer
9D008A40  00000000   NOP
647:                 
648:                 	// hardware marker for oscilloscope trigger
649:                 	//TOGGLE_DEBUG_PIN1;
650:                 
651:                 	// set event flag
652:                 	BITSET(efTimerEvents, EF_TIMER_5MS_TICK_INT);
9D008A44  978280EE   LHU V0, -32530(GP)
9D008A48  34420001   ORI V0, V0, 1
9D008A4C  3042FFFF   ANDI V0, V0, -1
9D008A50  A78280EE   SH V0, -32530(GP)
653:                 
654:                     // clear the calling interrupt flag
655:                     mCTClearIntFlag();
9D008A54  3C02BF88   LUI V0, -16504
9D008A58  24030001   ADDIU V1, ZERO, 1
9D008A5C  AC431034   SW V1, 4148(V0)
656:                 }
9D008A60  03C0E821   ADDU SP, S8, ZERO
9D008A64  8FA20064   LW V0, 100(SP)
9D008A68  00400013   MTLO V0
9D008A6C  8FA30060   LW V1, 96(SP)
9D008A70  00600011   MTHI V1
9D008A74  8FBF005C   LW RA, 92(SP)
9D008A78  8FBE0058   LW S8, 88(SP)
9D008A7C  8FB90054   LW T9, 84(SP)
9D008A80  8FB80050   LW T8, 80(SP)
9D008A84  8FAF004C   LW T7, 76(SP)
9D008A88  8FAE0048   LW T6, 72(SP)
9D008A8C  8FAD0044   LW T5, 68(SP)
9D008A90  8FAC0040   LW T4, 64(SP)
9D008A94  8FAB003C   LW T3, 60(SP)
9D008A98  8FAA0038   LW T2, 56(SP)
9D008A9C  8FA90034   LW T1, 52(SP)
9D008AA0  8FA80030   LW T0, 48(SP)
9D008AA4  8FA7002C   LW A3, 44(SP)
9D008AA8  8FA60028   LW A2, 40(SP)
9D008AAC  8FA50024   LW A1, 36(SP)
9D008AB0  8FA40020   LW A0, 32(SP)
9D008AB4  8FA3001C   LW V1, 28(SP)
9D008AB8  8FA20018   LW V0, 24(SP)
9D008ABC  8FA10014   LW AT, 20(SP)
9D008AC0  41606000   DI ZERO
9D008AC4  000000C0   EHB
9D008AC8  8FBA006C   LW K0, 108(SP)
9D008ACC  8FBB0068   LW K1, 104(SP)
9D008AD0  409A7000   MTC0 K0, EPC
9D008AD4  27BD0070   ADDIU SP, SP, 112
9D008AD8  41DDE800   WRPGPR SP, SP
9D008ADC  409B6000   MTC0 K1, Status
9D008AE0  42000018   ERET
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/ftoa.c  --------------------------
1:                   
2:                   #include "ftoa.h"
3:                   #include <stdlib.h>
4:                   
5:                   typedef union
6:                       {
7:                       long L;
8:                       float F;
9:                       } LF_t;
10:                  
11:                  char *ftoa( float f, int *status)
12:                      {
9D00C240  27BDFFD0   ADDIU SP, SP, -48
9D00C244  AFBF002C   SW RA, 44(SP)
9D00C248  AFBE0028   SW S8, 40(SP)
9D00C24C  03A0F021   ADDU S8, SP, ZERO
9D00C250  AFC40030   SW A0, 48(S8)
9D00C254  AFC50034   SW A1, 52(S8)
13:                      long mantissa, int_part, frac_part;
14:                      short exp2;
15:                      LF_t x;
16:                      char *p;
17:                      static char outbuf[15];
18:                  
19:                      *status = 0;
9D00C258  8FC20034   LW V0, 52(S8)
9D00C25C  AC400000   SW ZERO, 0(V0)
20:                  
21:                      if ( f == 0.0 )
9D00C260  8FC40030   LW A0, 48(S8)
9D00C264  00002821   ADDU A1, ZERO, ZERO
9D00C268  0F402BA6   JAL __lesf2
9D00C26C  00000000   NOP
9D00C270  14400013   BNE V0, ZERO, 0x9D00C2C0
9D00C274  00000000   NOP
22:                          {
23:                          outbuf[0] = '0';
9D00C278  3C02A000   LUI V0, -24576
9D00C27C  24030030   ADDIU V1, ZERO, 48
9D00C280  A0430908   SB V1, 2312(V0)
24:                          outbuf[1] = '.';
9D00C284  3C02A000   LUI V0, -24576
9D00C288  24420908   ADDIU V0, V0, 2312
9D00C28C  2403002E   ADDIU V1, ZERO, 46
9D00C290  A0430001   SB V1, 1(V0)
25:                          outbuf[2] = '0';
9D00C294  3C02A000   LUI V0, -24576
9D00C298  24420908   ADDIU V0, V0, 2312
9D00C29C  24030030   ADDIU V1, ZERO, 48
9D00C2A0  A0430002   SB V1, 2(V0)
26:                          outbuf[3] = 0;
9D00C2A4  3C02A000   LUI V0, -24576
9D00C2A8  24420908   ADDIU V0, V0, 2312
9D00C2AC  A0400003   SB ZERO, 3(V0)
27:                          return outbuf;
9D00C2B0  3C02A000   LUI V0, -24576
9D00C2B4  24420908   ADDIU V0, V0, 2312
9D00C2B8  0B403176   J 0x9D00C5D8
9D00C2BC  00000000   NOP
28:                          }
29:                      x.F = f;
9D00C2C0  8FC20030   LW V0, 48(S8)
9D00C2C4  AFC20024   SW V0, 36(S8)
30:                  
31:                      exp2 = (unsigned char)(x.L >> 23) - 127;
9D00C2C8  8FC20024   LW V0, 36(S8)
9D00C2CC  000215C3   SRA V0, V0, 23
9D00C2D0  304200FF   ANDI V0, V0, 255
9D00C2D4  2442FF81   ADDIU V0, V0, -127
9D00C2D8  3042FFFF   ANDI V0, V0, -1
9D00C2DC  A7C2001E   SH V0, 30(S8)
32:                      mantissa = (x.L & 0xFFFFFF) | 0x800000;
9D00C2E0  8FC20024   LW V0, 36(S8)
9D00C2E4  7C43B000   EXT V1, V0, 0, 23
9D00C2E8  3C020080   LUI V0, 128
9D00C2EC  00621025   OR V0, V1, V0
9D00C2F0  AFC20020   SW V0, 32(S8)
33:                      frac_part = 0;
9D00C2F4  AFC00014   SW ZERO, 20(S8)
34:                      int_part = 0;
9D00C2F8  AFC00010   SW ZERO, 16(S8)
35:                  
36:                      if ( exp2 >= 31 )
9D00C2FC  87C2001E   LH V0, 30(S8)
9D00C300  2842001F   SLTI V0, V0, 31
9D00C304  14400007   BNE V0, ZERO, 0x9D00C324
9D00C308  00000000   NOP
37:                          {
38:                          *status = _FTOA_TOO_LARGE;
9D00C30C  8FC20034   LW V0, 52(S8)
9D00C310  2403FFFF   ADDIU V1, ZERO, -1
9D00C314  AC430000   SW V1, 0(V0)
39:                          return 0;
9D00C318  00001021   ADDU V0, ZERO, ZERO
9D00C31C  0B403176   J 0x9D00C5D8
9D00C320  00000000   NOP
40:                          }
41:                      else if ( exp2 < -23 )
9D00C324  87C2001E   LH V0, 30(S8)
9D00C328  2842FFE9   SLTI V0, V0, -23
9D00C32C  10400007   BEQ V0, ZERO, 0x9D00C34C
9D00C330  00000000   NOP
42:                          {
43:                          *status = _FTOA_TOO_SMALL;
9D00C334  8FC20034   LW V0, 52(S8)
9D00C338  2403FFFE   ADDIU V1, ZERO, -2
9D00C33C  AC430000   SW V1, 0(V0)
44:                          return 0;
9D00C340  00001021   ADDU V0, ZERO, ZERO
9D00C344  0B403176   J 0x9D00C5D8
9D00C348  00000000   NOP
45:                          }
46:                      else if ( exp2 >= 23 )
9D00C34C  87C2001E   LH V0, 30(S8)
9D00C350  28420017   SLTI V0, V0, 23
9D00C354  14400008   BNE V0, ZERO, 0x9D00C378
9D00C358  00000000   NOP
47:                          int_part = mantissa << (exp2 - 23);
9D00C35C  87C2001E   LH V0, 30(S8)
9D00C360  2442FFE9   ADDIU V0, V0, -23
9D00C364  8FC30020   LW V1, 32(S8)
9D00C368  00431004   SLLV V0, V1, V0
9D00C36C  AFC20010   SW V0, 16(S8)
9D00C370  0B4030F5   J 0x9D00C3D4
9D00C374  00000000   NOP
48:                      else if ( exp2 >= 0 )
9D00C378  87C2001E   LH V0, 30(S8)
9D00C37C  0440000F   BLTZ V0, 0x9D00C3BC
9D00C380  00000000   NOP
49:                          {
50:                          int_part = mantissa >> (23 - exp2);
9D00C384  87C2001E   LH V0, 30(S8)
9D00C388  24030017   ADDIU V1, ZERO, 23
9D00C38C  00621023   SUBU V0, V1, V0
9D00C390  8FC30020   LW V1, 32(S8)
9D00C394  00431007   SRAV V0, V1, V0
9D00C398  AFC20010   SW V0, 16(S8)
51:                          frac_part = (mantissa << (exp2 + 1)) & 0xFFFFFF;
9D00C39C  87C2001E   LH V0, 30(S8)
9D00C3A0  24420001   ADDIU V0, V0, 1
9D00C3A4  8FC30020   LW V1, 32(S8)
9D00C3A8  00431004   SLLV V0, V1, V0
9D00C3AC  7C42B800   EXT V0, V0, 0, 24
9D00C3B0  AFC20014   SW V0, 20(S8)
9D00C3B4  0B4030F5   J 0x9D00C3D4
9D00C3B8  00000000   NOP
52:                          }
53:                      else /* if (exp2 < 0) */
54:                          frac_part = (mantissa & 0xFFFFFF) >> -(exp2 + 1);
9D00C3BC  8FC20020   LW V0, 32(S8)
9D00C3C0  7C43B800   EXT V1, V0, 0, 24
9D00C3C4  87C2001E   LH V0, 30(S8)
9D00C3C8  00021027   NOR V0, ZERO, V0
9D00C3CC  00431007   SRAV V0, V1, V0
9D00C3D0  AFC20014   SW V0, 20(S8)
55:                  
56:                      p = outbuf;
9D00C3D4  3C02A000   LUI V0, -24576
9D00C3D8  24420908   ADDIU V0, V0, 2312
9D00C3DC  AFC20018   SW V0, 24(S8)
57:                  
58:                      if ( x.L < 0 )
9D00C3E0  8FC20024   LW V0, 36(S8)
9D00C3E4  04410007   BGEZ V0, 0x9D00C404
9D00C3E8  00000000   NOP
59:                          *p++ = '-';
9D00C3EC  8FC20018   LW V0, 24(S8)
9D00C3F0  2403002D   ADDIU V1, ZERO, 45
9D00C3F4  A0430000   SB V1, 0(V0)
9D00C3F8  8FC20018   LW V0, 24(S8)
9D00C3FC  24420001   ADDIU V0, V0, 1
9D00C400  AFC20018   SW V0, 24(S8)
60:                  
61:                      if ( int_part == 0 )
9D00C404  8FC20010   LW V0, 16(S8)
9D00C408  14400009   BNE V0, ZERO, 0x9D00C430
9D00C40C  00000000   NOP
62:                          *p++ = '0';
9D00C410  8FC20018   LW V0, 24(S8)
9D00C414  24030030   ADDIU V1, ZERO, 48
9D00C418  A0430000   SB V1, 0(V0)
9D00C41C  8FC20018   LW V0, 24(S8)
9D00C420  24420001   ADDIU V0, V0, 1
9D00C424  AFC20018   SW V0, 24(S8)
9D00C428  0B40311A   J 0x9D00C468
9D00C42C  00000000   NOP
63:                      else
64:                          {
65:                          ltoa(p, int_part, 10);
9D00C430  8FC40018   LW A0, 24(S8)
9D00C434  8FC50010   LW A1, 16(S8)
9D00C438  2406000A   ADDIU A2, ZERO, 10
9D00C43C  0F403868   JAL ltoa
9D00C440  00000000   NOP
66:                  
67:                          while ( *p )
9D00C444  0B403116   J 0x9D00C458
9D00C448  00000000   NOP
9D00C458  8FC20018   LW V0, 24(S8)
9D00C45C  80420000   LB V0, 0(V0)
9D00C460  1440FFFA   BNE V0, ZERO, 0x9D00C44C
9D00C464  00000000   NOP
68:                              p++;
9D00C44C  8FC20018   LW V0, 24(S8)
9D00C450  24420001   ADDIU V0, V0, 1
9D00C454  AFC20018   SW V0, 24(S8)
69:                          }
70:                      *p++ = '.';
9D00C468  8FC20018   LW V0, 24(S8)
9D00C46C  2403002E   ADDIU V1, ZERO, 46
9D00C470  A0430000   SB V1, 0(V0)
9D00C474  8FC20018   LW V0, 24(S8)
9D00C478  24420001   ADDIU V0, V0, 1
9D00C47C  AFC20018   SW V0, 24(S8)
71:                  
72:                      if ( frac_part == 0 )
9D00C480  8FC20014   LW V0, 20(S8)
9D00C484  14400009   BNE V0, ZERO, 0x9D00C4AC
9D00C488  00000000   NOP
73:                          *p++ = '0';
9D00C48C  8FC20018   LW V0, 24(S8)
9D00C490  24030030   ADDIU V1, ZERO, 48
9D00C494  A0430000   SB V1, 0(V0)
9D00C498  8FC20018   LW V0, 24(S8)
9D00C49C  24420001   ADDIU V0, V0, 1
9D00C4A0  AFC20018   SW V0, 24(S8)
9D00C4A4  0B403172   J 0x9D00C5C8
9D00C4A8  00000000   NOP
74:                      else
75:                          {
76:                          char m, max;
77:                  
78:                          max = sizeof(outbuf) - (p - outbuf) - 1;
9D00C4AC  8FC20018   LW V0, 24(S8)
9D00C4B0  304200FF   ANDI V0, V0, 255
9D00C4B4  00021023   SUBU V0, ZERO, V0
9D00C4B8  304300FF   ANDI V1, V0, 255
9D00C4BC  3C02A000   LUI V0, -24576
9D00C4C0  24420908   ADDIU V0, V0, 2312
9D00C4C4  304200FF   ANDI V0, V0, 255
9D00C4C8  2442000E   ADDIU V0, V0, 14
9D00C4CC  304200FF   ANDI V0, V0, 255
9D00C4D0  00621021   ADDU V0, V1, V0
9D00C4D4  304200FF   ANDI V0, V0, 255
9D00C4D8  A3C2001D   SB V0, 29(S8)
79:                  
80:                          if ( max > 7 )
9D00C4DC  83C2001D   LB V0, 29(S8)
9D00C4E0  28420008   SLTI V0, V0, 8
9D00C4E4  14400003   BNE V0, ZERO, 0x9D00C4F4
9D00C4E8  00000000   NOP
81:                              max = 7;
9D00C4EC  24020007   ADDIU V0, ZERO, 7
9D00C4F0  A3C2001D   SB V0, 29(S8)
82:                          /* print BCD */
83:                          for( m = 0; m < max; m++ )
9D00C4F4  A3C0001C   SB ZERO, 28(S8)
9D00C4F8  0B403157   J 0x9D00C55C
9D00C4FC  00000000   NOP
9D00C550  93C2001C   LBU V0, 28(S8)
9D00C554  24420001   ADDIU V0, V0, 1
9D00C558  A3C2001C   SB V0, 28(S8)
9D00C55C  83C3001C   LB V1, 28(S8)
9D00C560  83C2001D   LB V0, 29(S8)
9D00C564  0062102A   SLT V0, V1, V0
9D00C568  1440FFE5   BNE V0, ZERO, 0x9D00C500
9D00C56C  00000000   NOP
84:                              {
85:                              /* frac_part *= 10; */
86:                              frac_part = (frac_part << 3) + (frac_part << 1);
9D00C500  8FC20014   LW V0, 20(S8)
9D00C504  000218C0   SLL V1, V0, 3
9D00C508  8FC20014   LW V0, 20(S8)
9D00C50C  00021040   SLL V0, V0, 1
9D00C510  00621021   ADDU V0, V1, V0
9D00C514  AFC20014   SW V0, 20(S8)
87:                  
88:                              *p++ = (frac_part >> 24) + '0';
9D00C518  8FC20014   LW V0, 20(S8)
9D00C51C  00021603   SRA V0, V0, 24
9D00C520  304200FF   ANDI V0, V0, 255
9D00C524  24420030   ADDIU V0, V0, 48
9D00C528  304200FF   ANDI V0, V0, 255
9D00C52C  7C021C20   SEB V1, V0
9D00C530  8FC20018   LW V0, 24(S8)
9D00C534  A0430000   SB V1, 0(V0)
9D00C538  8FC20018   LW V0, 24(S8)
9D00C53C  24420001   ADDIU V0, V0, 1
9D00C540  AFC20018   SW V0, 24(S8)
89:                              frac_part &= 0xFFFFFF;
9D00C544  8FC20014   LW V0, 20(S8)
9D00C548  7C42B800   EXT V0, V0, 0, 24
9D00C54C  AFC20014   SW V0, 20(S8)
90:                              }
91:                          /* delete ending zeroes */
92:                          for( --p; p[0] == '0' && p[-1] != '.'; --p )
9D00C570  8FC20018   LW V0, 24(S8)
9D00C574  2442FFFF   ADDIU V0, V0, -1
9D00C578  AFC20018   SW V0, 24(S8)
9D00C57C  0B403164   J 0x9D00C590
9D00C580  00000000   NOP
9D00C584  8FC20018   LW V0, 24(S8)
9D00C588  2442FFFF   ADDIU V0, V0, -1
9D00C58C  AFC20018   SW V0, 24(S8)
9D00C590  8FC20018   LW V0, 24(S8)
9D00C594  80430000   LB V1, 0(V0)
9D00C598  24020030   ADDIU V0, ZERO, 48
9D00C59C  14620007   BNE V1, V0, 0x9D00C5BC
9D00C5A0  00000000   NOP
9D00C5A4  8FC20018   LW V0, 24(S8)
9D00C5A8  2442FFFF   ADDIU V0, V0, -1
9D00C5AC  80430000   LB V1, 0(V0)
9D00C5B0  2402002E   ADDIU V0, ZERO, 46
9D00C5B4  1462FFF3   BNE V1, V0, 0x9D00C584
9D00C5B8  00000000   NOP
93:                          ;
94:                          ++p;
9D00C5BC  8FC20018   LW V0, 24(S8)
9D00C5C0  24420001   ADDIU V0, V0, 1
9D00C5C4  AFC20018   SW V0, 24(S8)
95:                          }
96:                      *p = 0;
9D00C5C8  8FC20018   LW V0, 24(S8)
9D00C5CC  A0400000   SB ZERO, 0(V0)
97:                  
98:                      return outbuf;
9D00C5D0  3C02A000   LUI V0, -24576
9D00C5D4  24420908   ADDIU V0, V0, 2312
99:                      }
9D00C5D8  03C0E821   ADDU SP, S8, ZERO
9D00C5DC  8FBF002C   LW RA, 44(SP)
9D00C5E0  8FBE0028   LW S8, 40(SP)
9D00C5E4  27BD0030   ADDIU SP, SP, 48
9D00C5E8  03E00008   JR RA
9D00C5EC  00000000   NOP
100:                 
101:                 //char *ftoa( float f, int *status, char *buffer )
102:                 //    {
103:                     //... return buffer;
104:                 //    }
105:                 
106:                 //One bug was uncovered here->
107:                 
108:                 
109:                 //exp2 = (0xFF & (x.L >> 23)) - 127; /* JEB fixed for 16-bit char F2xxx */
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/TimeDelay.c  ---------------------
1:                   /******************************************************************************
2:                   
3:                   File Name:       TimeDelay.c
4:                   Dependencies:    None
5:                   Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32
6:                   Compiler:        C30 v3.12
7:                   Company:         Microchip Technology, Inc.
8:                   
9:                   Copyright (C) 2010 Microchip Technology Inc.  All rights reserved.
10:                  
11:                  Microchip licenses to you the right to use, modify, copy and distribute 
12:                  Software only when embedded on a Microchip microcontroller or digital signal 
13:                  controller that is integrated into your product or third party product 
14:                  (pursuant to the sublicense terms in the accompanying license agreement).  
15:                  
16:                  You should refer to the license agreement accompanying this Software for 
17:                  additional information regarding your rights and obligations.
18:                  
19:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
20:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF 
21:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. 
22:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER 
23:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR 
24:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES 
25:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR 
26:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF 
27:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES 
28:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
29:                  
30:                  Author          Date    Comments
31:                  --------------------------------------------------------------------------------
32:                  AKN	2009.10.14	FILE CREATED
33:                  AKN	2009.10.15	CHANGED C18 DELAY ROUTINE TO DECREMENT ENTIRE NUMBER OF CYCLES
34:                  AKN	2009.10.19	CHANGED C30 DELAY ROUTINE TO MATCH C18 IMPLEMENTATION
35:                  AKN	2009.10.26	ADDED C32 DELAY ROUTINE TO MATCH C18 IMPLEMENTATION
36:                  AKN	2009.10.27	CONSOLIDATED C30 AND C32 IMPLEMENTATIONS, ADDED PADDING TO
37:                                  MAKE C30 DELAYS MORE ACCURATE
38:                  PAT	2010.01.26	CONVERTED LOCALS TO VOLATILE 
39:                  PAT	2010.03.07	ADDED include "Compiler.h"
40:                  *******************************************************************************/
41:                  #if defined(__PIC32MX__)
42:                  	#include <plib.h>
43:                  #endif
44:                  #include "Compiler.h"
45:                  #include "HardwareProfile.h"
46:                  #include "TimeDelay.h" 
47:                  
48:                  /****************************************************************************
49:                    Function:
50:                      void Delay10us( UINT32 tenMicroSecondCounter )
51:                  
52:                    Description:
53:                      This routine performs a software delay in intervals of 10 microseconds.
54:                  
55:                    Precondition:
56:                      None
57:                  
58:                    Parameters:
59:                      UINT32 tenMicroSecondCounter - number of ten microsecond delays
60:                      to perform at once.
61:                  
62:                    Returns:
63:                      None
64:                  
65:                    Remarks:
66:                      None
67:                    ***************************************************************************/
68:                  void Delay10us( UINT32 tenMicroSecondCounter )
69:                  {
9D00DA2C  27BDFFF0   ADDIU SP, SP, -16
9D00DA30  AFBE000C   SW S8, 12(SP)
9D00DA34  03A0F021   ADDU S8, SP, ZERO
9D00DA38  AFC40010   SW A0, 16(S8)
70:                      volatile INT32 cyclesRequiredForEntireDelay;    
71:                          
72:                      #if defined(__PIC32MX__)
73:                      
74:                          if(GetInstructionClock() <= 500000) //for all FCY speeds under 500KHz (FOSC <= 1MHz)
75:                          {
76:                              //10 cycles burned through this path (includes return to caller).
77:                              //For FOSC == 1MHZ, it takes 5us.
78:                              //For FOSC == 4MHZ, it takes 0.5us
79:                              //For FOSC == 8MHZ, it takes 0.25us.
80:                              //For FOSC == 10MHZ, it takes 0.2us.
81:                          }    
82:                          else
83:                          {
84:                              //7 cycles burned to this point.
85:                              
86:                              //We want to pre-calculate number of cycles required to delay 10us * tenMicroSecondCounter using a 1 cycle granule.
87:                              cyclesRequiredForEntireDelay = (INT32)(GetInstructionClock()/100000)*tenMicroSecondCounter;
9D00DA3C  8FC30010   LW V1, 16(S8)
9D00DA40  24020320   ADDIU V0, ZERO, 800
9D00DA44  70621002   MUL V0, V1, V0
9D00DA48  AFC20000   SW V0, 0(S8)
88:                              
89:                              #if defined(__C30__)
90:                                  //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
91:                                  //Also we subtract the 5 cycle function return.
92:                                  cyclesRequiredForEntireDelay -= 44; //(29 + 5) + 10 cycles padding
93:                              #elif defined(__PIC32MX__)
94:                                  //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
95:                                  //Also we subtract the 5 cycle function return.
96:                                  cyclesRequiredForEntireDelay -= 24; //(19 + 5)
9D00DA4C  8FC20000   LW V0, 0(S8)
9D00DA50  2442FFE8   ADDIU V0, V0, -24
9D00DA54  AFC20000   SW V0, 0(S8)
97:                              #endif
98:                              
99:                              if(cyclesRequiredForEntireDelay <= 0)
9D00DA58  8FC20000   LW V0, 0(S8)
9D00DA5C  18400009   BLEZ V0, 0x9D00DA84
9D00DA60  00000000   NOP
100:                             {
101:                                 // If we have exceeded the cycle count already, bail!
102:                             }
103:                             else
104:                             {   
105:                                 while(cyclesRequiredForEntireDelay>0) //19 cycles used to this point.
9D00DA64  0B40369E   J 0x9D00DA78
9D00DA68  00000000   NOP
9D00DA78  8FC20000   LW V0, 0(S8)
9D00DA7C  1C40FFFB   BGTZ V0, 0x9D00DA6C
9D00DA80  00000000   NOP
106:                                 {
107:                                     #if defined(__C30__)
108:                                         cyclesRequiredForEntireDelay -= 11; //Subtract cycles burned while doing each delay stage, 12 in this case. Add one cycle as padding.
109:                                     #elif defined(__PIC32MX__)
110:                                         cyclesRequiredForEntireDelay -= 8; //Subtract cycles burned while doing each delay stage, 8 in this case.
9D00DA6C  8FC20000   LW V0, 0(S8)
9D00DA70  2442FFF8   ADDIU V0, V0, -8
9D00DA74  AFC20000   SW V0, 0(S8)
111:                                     #endif
112:                                 }
113:                             }
114:                         }
115:                     #endif
116:                 }
9D00DA84  03C0E821   ADDU SP, S8, ZERO
9D00DA88  8FBE000C   LW S8, 12(SP)
9D00DA8C  27BD0010   ADDIU SP, SP, 16
9D00DA90  03E00008   JR RA
9D00DA94  00000000   NOP
117:                 
118:                 /****************************************************************************
119:                   Function:
120:                     void DelayMs( UINT16 ms )
121:                 
122:                   Description:
123:                     This routine performs a software delay in intervals of 1 millisecond.
124:                 
125:                   Precondition:
126:                     None
127:                 
128:                   Parameters:
129:                     UINT16 ms - number of one millisecond delays to perform at once.
130:                 
131:                   Returns:
132:                     None
133:                 
134:                   Remarks:
135:                     None
136:                   ***************************************************************************/
137:                 void DelayMs( UINT16 ms )
138:                 {
9D00DA98  27BDFFE0   ADDIU SP, SP, -32
9D00DA9C  AFBF001C   SW RA, 28(SP)
9D00DAA0  AFBE0018   SW S8, 24(SP)
9D00DAA4  03A0F021   ADDU S8, SP, ZERO
9D00DAA8  00801021   ADDU V0, A0, ZERO
9D00DAAC  A7C20020   SH V0, 32(S8)
139:                     #if defined(__PIC32MX__)
140:                     
141:                         volatile UINT8 i;
142:                         
143:                         while (ms--)
9D00DAB0  0B4036BE   J 0x9D00DAF8
9D00DAB4  00000000   NOP
9D00DAF8  97C20020   LHU V0, 32(S8)
9D00DAFC  0002102B   SLTU V0, ZERO, V0
9D00DB00  304200FF   ANDI V0, V0, 255
9D00DB04  97C30020   LHU V1, 32(S8)
9D00DB08  2463FFFF   ADDIU V1, V1, -1
9D00DB0C  A7C30020   SH V1, 32(S8)
9D00DB10  1440FFE9   BNE V0, ZERO, 0x9D00DAB8
9D00DB14  00000000   NOP
144:                         {
145:                             i = 4;
9D00DAB8  24020004   ADDIU V0, ZERO, 4
9D00DABC  A3C20010   SB V0, 16(S8)
146:                             while (i--)
9D00DAC0  0B4036B5   J 0x9D00DAD4
9D00DAC4  00000000   NOP
9D00DAD4  93C20010   LBU V0, 16(S8)
9D00DAD8  304200FF   ANDI V0, V0, 255
9D00DADC  0002182B   SLTU V1, ZERO, V0
9D00DAE0  306300FF   ANDI V1, V1, 255
9D00DAE4  2442FFFF   ADDIU V0, V0, -1
9D00DAE8  304200FF   ANDI V0, V0, 255
9D00DAEC  A3C20010   SB V0, 16(S8)
9D00DAF0  1460FFF5   BNE V1, ZERO, 0x9D00DAC8
9D00DAF4  00000000   NOP
147:                             {
148:                                 Delay10us( 25 );
9D00DAC8  24040019   ADDIU A0, ZERO, 25
9D00DACC  0F40368B   JAL Delay10us
9D00DAD0  00000000   NOP
149:                             }
150:                         }
151:                     #endif
152:                 }
9D00DB18  03C0E821   ADDU SP, S8, ZERO
9D00DB1C  8FBF001C   LW RA, 28(SP)
9D00DB20  8FBE0018   LW S8, 24(SP)
9D00DB24  27BD0020   ADDIU SP, SP, 32
9D00DB28  03E00008   JR RA
9D00DB2C  00000000   NOP
153:                 
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/SystemParameters.c  --------------
1:                   //*************************************************************************************************
2:                   //								S y s t e m P a r a m e t e r s . c
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	SystemParameter table functions
8:                   //
9:                   //		001	27 Feb 13 <sek> created from gsf Code Base
10:                  //
11:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
12:                  //					gsf Engineering	978-927-7189
13:                  //					Beverly, MA 01915
14:                  //
15:                  //		copyright (c) 2013 gsf Engineering (Beverly, MA USA) for SmartTrak Solar Systems Pvt, Hyderabad, AP, India
16:                  //
17:                  //*************************************************************************************************
18:                  
19:                  //-----------------------------------------------------------------------------
20:                  // #include files
21:                  //-----------------------------------------------------------------------------
22:                  #include <GenericTypeDefs.h>
23:                  #include "HardwareProfile.h"
24:                  
25:                  // processor include file
26:                  //lint -e765					error 765: (Info -- external function could be made static)
27:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
28:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
29:                  //lint +e14
30:                  
31:                  #include "gsfstd.h"				// gsf standard #defines
32:                  #include "Debug.h"
33:                  #include "SmartTrak.h"			// Project wide definitions, default Parameter table
34:                  
35:                  #include "SST25VF016.h"				// SPI Flash function definitions
36:                  
37:                  //#include <stdlib.h>
38:                  //#include <string.h>
39:                  //#include <stdbool.h>
40:                  
41:                  //***********************************************
42:                  //				File Global Data
43:                  //***********************************************
44:                  
45:                  static const SmartTrakFLASH_SystemParameters_t	defaultSystemParameters =			// default valus of System Parameters
46:                  {
47:                  	.unChecksum = 0x0000,
48:                  	.unMagic = DEFAULT_MAGIC_NUMBER,
49:                  
50:                  	// ****************************
51:                  	//		unit location
52:                  	// ****************************
53:                  	.fLatitude = 0.0,					// R/W, In degrees. Range = +90 degrees to -90 degrees, Positive for north of the equator.
54:                  	.fLongitude = 0.0,					// R/W, In degrees. Range = -180 to +180deg, Positive for east of GMT
55:                  	.fElevation = 0.0,					// Float R/W In meters. Above sea level.
56:                  	.fRefraction = 0.0,					// Float R/W No units. Value is around 1.
57:                  	.fTimeZone = 0.0,					// Float R/W Offset from GMT (like 5.5 for India)
58:                  
59:                  	// ****************************
60:                  	//			Azimuth
61:                  	// ****************************
62:                  	.unAZ_PulsesPerRot = 472,			// Int R/W Motor setting. Number of hall pulses to complete 360deg rotation of the azimuth drive.
63:                  	.fAZ_SoftLim_Min = 0.0,				// Float R/W Azimuth soft limit minimum. Units: degrees
64:                  	.fAZ_SoftLim_Max  = 0.0,			// Float R/W Azimuth soft limit maximum. Units: degrees
65:                  	.fAZ_DeadBand = 0.0,				// Float R/W TBD
66:                  	.fAZ_NightStow = 0.0,				// Float R/W Default = 0 (remain in place)
67:                  	.fAZ_WindStow = 0.0,				// Float R/W Default = 0 (remain in place)
68:                  	.fAZ_SetPoint = 0.0,				// Float R/W This comes from SPA_calc, but limited by soft limits
69:                  	.fAZ_PVpos = 0.0,					// Float R only This is the present position of the PV panel. This is calculated based on AZ_PulseCount.
70:                  	.unAZ_PulseCount = 0.0,				// Int R only This is the number of hall pulses.
71:                  	.bAZ_En_AutoCal = FALSE,			// Bool R/W
72:                  	.bAZ_AutoMove = TRUE,				// Bool, R/W	True: Move the motor to AZ_SetPoint
73:                  										//				False: Move the motor only upon soft/hard joystick operation (soft= cmds; hard =push buttons)
74:                  	.fAZ_cal_param1 = 1.0,				// Float R/W TBD: could be needed for cal correction
75:                  	.fAZ_cal_param2 = 1.0,				// Float R/W TBD: could be needed for cal correction
76:                  
77:                  	// ****************************
78:                  	//			Elevation
79:                  	// ****************************
80:                  	.unEL_PulsesPerRot = 472,			// Int R/W Motor setting. Number of hall pulses to complete *deg rotation of the elevation drive.
81:                  	.fEL_SoftLim_Min = 0.0,				// Float R/W Azimuth soft limit minimum. Units: degrees
82:                  	.fEL_SoftLim_Max = 0.0,				// Float R/W Azimuth soft limit maximum. Units: degrees
83:                  	.fEL_DeadBand = 0.0,				// Float R/W TBD
84:                  	.fEL_NightStow = 0.0,				// Float R/W Default = 0 (remain in place)
85:                  	.fEL_WindStow = 0.0,				// Float R/W Default = 0 (remain in place)
86:                  	.fEL_SetPoint = 0.0,				// Float R/W This comes from SPA_calc, but limited by soft limits
87:                  	.fEL_PVpos = 0.0,					// Float R only This is the present position of the PV panel. This is calculated based on EL_PulseCount.
88:                  	.unEL_PulseCount = 0.0,				// Int R only This is the number of hall pulses.
89:                  	.bEL_En_AutoCal = FALSE,			// Bool R/W
90:                  	.bEL_AutoMove = TRUE,				// Bool R/W		True: Move the motor to EL_SetPoint
91:                  										//				False: Move the motor only upon soft/hard joystick operation (soft= cmds; hard =push buttons)
92:                  	.fEL_cal_param1 = 0.0,				// Float R/W TBD: could be needed for cal correction
93:                  	.fEL_cal_param2 = 0.0,				// Float R/W TBD: could be needed for cal correction
94:                  
95:                  	.ucTracker_State = POS_TRACKING,	// Int (enum) R/W Values: Tracking, Night Stow, Wind Stow
96:                  										// TBD: make it read only? May need write permission for testing purpose
97:                  
98:                  	.unUpdateCtr = DEFAULT_TABLE_UPDATE_CTR,
99:                  	.unEndMarker = DEFAULT_TABLE_END_MARKER,
100:                 
101:                 };
102:                 
103:                 
104:                 //***********************************************
105:                 //	Forward References (local Function Declarations)
106:                 //***********************************************
107:                 static UINT16 ChecksumSystemParameterTable(UINT8 *table);
108:                 static void ReadFlashParameterTable(void);
109:                 void WriteFlashParameterTable(void);					// write the RAM copy of SYSTEM and APPLICATION attributes to SPI Flash
110:                 
111:                 //*************************************************************************************************
112:                 //				Load and Initialize System Parameter from Flash Storage
113:                 //*************************************************************************************************
114:                 
115:                 BOOL InitSystemParameterTable(void)
116:                 {
9D00D018  27BDFFD8   ADDIU SP, SP, -40
9D00D01C  AFBF0024   SW RA, 36(SP)
9D00D020  AFBE0020   SW S8, 32(SP)
9D00D024  03A0F021   ADDU S8, SP, ZERO
117:                 	BOOL bRetVal = TRUE;
9D00D028  24020001   ADDIU V0, ZERO, 1
9D00D02C  AFC20010   SW V0, 16(S8)
118:                 	char SST25_ID[4];
119:                 	UINT16	nCheckSum;
120:                 
121:                 	// initialize SPI interface to the SST25 SPI flash
122:                     SST25Init();
9D00D030  0F401D89   JAL SST25Init
9D00D034  00000000   NOP
123:                 
124:                 	// verify presence of the SPI Flash by reading the device IDs
125:                 	if (SST25ReadID(SST25_ID) IS FALSE)
9D00D038  27C20018   ADDIU V0, S8, 24
9D00D03C  00402021   ADDU A0, V0, ZERO
9D00D040  0F401DE1   JAL SST25ReadID
9D00D044  00000000   NOP
9D00D048  1440000F   BNE V0, ZERO, 0x9D00D088
9D00D04C  00000000   NOP
126:                 	{
127:                 		bRetVal = FALSE;
9D00D050  AFC00010   SW ZERO, 16(S8)
128:                 		gbSPIFlashPresent = FALSE;
9D00D054  AF808050   SW ZERO, -32688(GP)
129:                 		RuntimeError(SYSTEM_ERROR_FLASH_NOT_PRESENT);
9D00D058  24040006   ADDIU A0, ZERO, 6
9D00D05C  0F40365E   JAL _RuntimeError
9D00D060  00000000   NOP
130:                 
131:                 		// initialize system parameters from default table
132:                 		memcpy((UINT8*)ptrRAM_SystemParameters, (UINT8*)&defaultSystemParameters, SMARTTRAK_SYS_FLASH_TABLE_SIZE);
9D00D064  8F828010   LW V0, -32752(GP)
9D00D068  00402021   ADDU A0, V0, ZERO
9D00D06C  3C029D01   LUI V0, -25343
9D00D070  2445DEA8   ADDIU A1, V0, -8536
9D00D074  24060088   ADDIU A2, ZERO, 136
9D00D078  0F403592   JAL 0x9D00D648
9D00D07C  00000000   NOP
9D00D080  0B403426   J 0x9D00D098
9D00D084  00000000   NOP
133:                 	}
134:                 	else
135:                 	{
136:                 		gbSPIFlashPresent = TRUE;
9D00D088  24020001   ADDIU V0, ZERO, 1
9D00D08C  AF828050   SW V0, -32688(GP)
137:                 		// read the System Parameter table from SPI Flash into MCU RAM.
138:                 		ReadFlashParameterTable();
9D00D090  0F40349B   JAL 0x9D00D26C
9D00D094  00000000   NOP
139:                 	}
140:                 
141:                 	// calculate checksum of System Parameter table
142:                     nCheckSum = ChecksumSystemParameterTable((UINT8 *)ptrRAM_SystemParameters);
9D00D098  8F828010   LW V0, -32752(GP)
9D00D09C  00402021   ADDU A0, V0, ZERO
9D00D0A0  0F40344B   JAL 0x9D00D12C
9D00D0A4  00000000   NOP
9D00D0A8  A7C20014   SH V0, 20(S8)
143:                 	
144:                 	// check for valid Attribute table
145:                 	// if	checksum is not correct (not 0)
146:                 	//		'magic' number in attributes copied from SPI flash does not match 'magic' number for this build
147:                 	//		structure end marker has moved relative to expected location for this build (which should have changed the 'magic' number
148:                 	// copy the defaultSystemParameters table to RAM, update the checksum and 'magic' number, and write out to SPI flash
149:                 	if ((nCheckSum) OR (ptrRAM_SystemParameters->unMagic IS_NOT DEFAULT_MAGIC_NUMBER) OR (ptrRAM_SystemParameters->unEndMarker IS_NOT DEFAULT_TABLE_END_MARKER))
9D00D0AC  97C20014   LHU V0, 20(S8)
9D00D0B0  1440000B   BNE V0, ZERO, 0x9D00D0E0
9D00D0B4  00000000   NOP
9D00D0B8  8F828010   LW V0, -32752(GP)
9D00D0BC  94430002   LHU V1, 2(V0)
9D00D0C0  3402A588   ORI V0, ZERO, -23160
9D00D0C4  14620006   BNE V1, V0, 0x9D00D0E0
9D00D0C8  00000000   NOP
9D00D0CC  8F828010   LW V0, -32752(GP)
9D00D0D0  94430084   LHU V1, 132(V0)
9D00D0D4  240255AA   ADDIU V0, ZERO, 21930
9D00D0D8  1062000D   BEQ V1, V0, 0x9D00D110
9D00D0DC  00000000   NOP
150:                 	{
151:                 		RuntimeError(SYSTEM_ERROR_PARAMETER_TABLE);
9D00D0E0  24040007   ADDIU A0, ZERO, 7
9D00D0E4  0F40365E   JAL _RuntimeError
9D00D0E8  00000000   NOP
152:                 
153:                 		// Replace the current RAM copy of the system parameters from default table
154:                 		memcpy((UINT8*)ptrRAM_SystemParameters, (UINT8*)&defaultSystemParameters, SMARTTRAK_SYS_FLASH_TABLE_SIZE);
9D00D0EC  8F828010   LW V0, -32752(GP)
9D00D0F0  00402021   ADDU A0, V0, ZERO
9D00D0F4  3C029D01   LUI V0, -25343
9D00D0F8  2445DEA8   ADDIU A1, V0, -8536
9D00D0FC  24060088   ADDIU A2, ZERO, 136
9D00D100  0F403592   JAL 0x9D00D648
9D00D104  00000000   NOP
155:                 
156:                 		//  Update checksum, etc, and write the RAM copy of SYSTEM and APPLICATION attributes to SPI Flash
157:                 		WriteFlashParameterTable();
9D00D108  0F40346C   JAL WriteFlashParameterTable
9D00D10C  00000000   NOP
158:                     }
159:                 
160:                 	return bRetVal;
9D00D110  8FC20010   LW V0, 16(S8)
161:                 }
9D00D114  03C0E821   ADDU SP, S8, ZERO
9D00D118  8FBF0024   LW RA, 36(SP)
9D00D11C  8FBE0020   LW S8, 32(SP)
9D00D120  27BD0028   ADDIU SP, SP, 40
9D00D124  03E00008   JR RA
9D00D128  00000000   NOP
162:                 
163:                 
164:                 // Calculate the checksum of the RAM System Parameter table
165:                 static UINT16 ChecksumSystemParameterTable(UINT8 *table)
166:                 {
9D00D12C  27BDFFF0   ADDIU SP, SP, -16
9D00D130  AFBE000C   SW S8, 12(SP)
9D00D134  03A0F021   ADDU S8, SP, ZERO
9D00D138  AFC40010   SW A0, 16(S8)
167:                     INT16 sum = -1;
9D00D13C  2402FFFF   ADDIU V0, ZERO, -1
9D00D140  A7C20000   SH V0, 0(S8)
168:                     UINT16 i;
169:                     UINT16* ptr = (UINT16*)table;
9D00D144  8FC20010   LW V0, 16(S8)
9D00D148  AFC20004   SW V0, 4(S8)
170:                 
171:                     /* Regenerate the checksum of the entire SYSTEM and APPLICATION attribute table */
172:                     for(i = 0; i < SMARTTRAK_SYS_FLASH_TABLE_SIZE / sizeof(UINT16); i++, ptr++)
9D00D14C  A7C00002   SH ZERO, 2(S8)
9D00D150  0B403462   J 0x9D00D188
9D00D154  00000000   NOP
9D00D170  97C20002   LHU V0, 2(S8)
9D00D174  24420001   ADDIU V0, V0, 1
9D00D178  A7C20002   SH V0, 2(S8)
9D00D17C  8FC20004   LW V0, 4(S8)
9D00D180  24420002   ADDIU V0, V0, 2
9D00D184  AFC20004   SW V0, 4(S8)
9D00D188  97C20002   LHU V0, 2(S8)
9D00D18C  2C420044   SLTIU V0, V0, 68
9D00D190  1440FFF1   BNE V0, ZERO, 0x9D00D158
9D00D194  00000000   NOP
173:                 	{
174:                         sum += *ptr;
9D00D158  8FC20004   LW V0, 4(S8)
9D00D15C  94430000   LHU V1, 0(V0)
9D00D160  97C20000   LHU V0, 0(S8)
9D00D164  00621021   ADDU V0, V1, V0
9D00D168  3042FFFF   ANDI V0, V0, -1
9D00D16C  A7C20000   SH V0, 0(S8)
175:                     }
176:                 
177:                     return sum;
9D00D198  97C20000   LHU V0, 0(S8)
178:                 }
9D00D19C  03C0E821   ADDU SP, S8, ZERO
9D00D1A0  8FBE000C   LW S8, 12(SP)
9D00D1A4  27BD0010   ADDIU SP, SP, 16
9D00D1A8  03E00008   JR RA
9D00D1AC  00000000   NOP
179:                 
180:                 
181:                 #ifdef SUPPORT_RESET_BUTTON
182:                 	/* Check for the user holding a factory reset button to wipe the flash parameters */
183:                 	static BOOL FlashTableReset(void)
184:                 	{
185:                 		if(getGpio(FACTORY_RESET_PIN) > 0) 
186:                 		{
187:                 			RTOS_Fixed_Delay_S(3);
188:                 			if(getGpio(FACTORY_RESET_PIN) > 0)
189:                 				return TRUE;
190:                 		}
191:                 		return FALSE;
192:                 	}
193:                 #endif	//  SUPPORT_RESET_BUTTON
194:                 
195:                 	
196:                 //*************************************************************************************************
197:                 //							Write System Parameter Table to Flash Storage
198:                 //*************************************************************************************************
199:                 
200:                 // update the RAM copy of the System Parameter table and write to external SPI Flash
201:                 void WriteFlashParameterTable(void)
202:                 {
9D00D1B0  27BDFFE0   ADDIU SP, SP, -32
9D00D1B4  AFBF001C   SW RA, 28(SP)
9D00D1B8  AFBE0018   SW S8, 24(SP)
9D00D1BC  AFB00014   SW S0, 20(SP)
9D00D1C0  03A0F021   ADDU S8, SP, ZERO
203:                 
204:                 	if (gbSPIFlashPresent IS FALSE)					// SPI flash is either not present or not functional
9D00D1C4  8F828050   LW V0, -32688(GP)
9D00D1C8  14400006   BNE V0, ZERO, 0x9D00D1E4
9D00D1CC  00000000   NOP
205:                 	{
206:                 		RuntimeError(SYSTEM_ERROR_FLASH_NOT_PRESENT);
9D00D1D0  24040006   ADDIU A0, ZERO, 6
9D00D1D4  0F40365E   JAL _RuntimeError
9D00D1D8  00000000   NOP
207:                 		return;
9D00D1DC  0B403494   J 0x9D00D250
9D00D1E0  00000000   NOP
208:                 	}
209:                 
210:                 	// bump structure update counter
211:                 	++(ptrRAM_SystemParameters->unUpdateCtr);
9D00D1E4  8F828010   LW V0, -32752(GP)
9D00D1E8  94430082   LHU V1, 130(V0)
9D00D1EC  24630001   ADDIU V1, V1, 1
9D00D1F0  3063FFFF   ANDI V1, V1, -1
9D00D1F4  A4430082   SH V1, 130(V0)
212:                 
213:                 	/* Regenerate the magic word (changes with change of Attribute structure size) */
214:                 	ptrRAM_SystemParameters->unMagic = DEFAULT_MAGIC_NUMBER;
9D00D1F8  8F828010   LW V0, -32752(GP)
9D00D1FC  2403A588   ADDIU V1, ZERO, -23160
9D00D200  A4430002   SH V1, 2(V0)
215:                 
216:                 	/* Regenerate the checksum (changes with any change of Attribute values) */
217:                 	ptrRAM_SystemParameters->unChecksum = 0;
9D00D204  8F828010   LW V0, -32752(GP)
9D00D208  A4400000   SH ZERO, 0(V0)
218:                 	ptrRAM_SystemParameters->unChecksum = -(INT16)ChecksumSystemParameterTable((UINT8*)ptrRAM_SystemParameters);
9D00D20C  8F908010   LW S0, -32752(GP)
9D00D210  8F828010   LW V0, -32752(GP)
9D00D214  00402021   ADDU A0, V0, ZERO
9D00D218  0F40344B   JAL 0x9D00D12C
9D00D21C  00000000   NOP
9D00D220  00021023   SUBU V0, ZERO, V0
9D00D224  3042FFFF   ANDI V0, V0, -1
9D00D228  A6020000   SH V0, 0(S0)
219:                 
220:                 	/* Erase the 4K sector (assumes flash table size is < sector size)*/
221:                 	SST25SectorErase((DWORD)SPI_FLASH_TABLE_ADDRESS);
9D00D22C  00002021   ADDU A0, ZERO, ZERO
9D00D230  0F401FF5   JAL SST25SectorErase
9D00D234  00000000   NOP
222:                 
223:                 	/* Write the System Parameters table */
224:                 	SST25WriteArray((DWORD)SPI_FLASH_TABLE_ADDRESS, (UINT8*)ptrRAM_SystemParameters, (WORD)SMARTTRAK_SYS_FLASH_TABLE_SIZE);
9D00D238  8F828010   LW V0, -32752(GP)
9D00D23C  00002021   ADDU A0, ZERO, ZERO
9D00D240  00402821   ADDU A1, V0, ZERO
9D00D244  24060088   ADDIU A2, ZERO, 136
9D00D248  0F401F17   JAL SST25WriteArray
9D00D24C  00000000   NOP
225:                 
226:                 	// ==> should have a return value
227:                 
228:                 }
9D00D250  03C0E821   ADDU SP, S8, ZERO
9D00D254  8FBF001C   LW RA, 28(SP)
9D00D258  8FBE0018   LW S8, 24(SP)
9D00D25C  8FB00014   LW S0, 20(SP)
9D00D260  27BD0020   ADDIU SP, SP, 32
9D00D264  03E00008   JR RA
9D00D268  00000000   NOP
229:                 
230:                 
231:                 
232:                 	
233:                 //*************************************************************************************************
234:                 //							Read System Parameter Table from SPI Flash Storage to RAM
235:                 //*************************************************************************************************
236:                 	
237:                 static void ReadFlashParameterTable()
238:                 {
9D00D26C  27BDFFE8   ADDIU SP, SP, -24
9D00D270  AFBF0014   SW RA, 20(SP)
9D00D274  AFBE0010   SW S8, 16(SP)
9D00D278  03A0F021   ADDU S8, SP, ZERO
239:                 	if (gbSPIFlashPresent IS FALSE)					// SPI flash is either not present or not functional
9D00D27C  8F828050   LW V0, -32688(GP)
9D00D280  14400006   BNE V0, ZERO, 0x9D00D29C
9D00D284  00000000   NOP
240:                 	{
241:                 		RuntimeError(SYSTEM_ERROR_FLASH_NOT_PRESENT);
9D00D288  24040006   ADDIU A0, ZERO, 6
9D00D28C  0F40365E   JAL _RuntimeError
9D00D290  00000000   NOP
242:                 		return;
9D00D294  0B4034AD   J 0x9D00D2B4
9D00D298  00000000   NOP
243:                 	}
244:                 
245:                 	/* Write the System Parameters table */
246:                 	SST25ReadArray((DWORD)SPI_FLASH_TABLE_ADDRESS, (UINT8*)ptrRAM_SystemParameters, (WORD)SMARTTRAK_SYS_FLASH_TABLE_SIZE);
9D00D29C  8F828010   LW V0, -32752(GP)
9D00D2A0  00002021   ADDU A0, ZERO, ZERO
9D00D2A4  00402821   ADDU A1, V0, ZERO
9D00D2A8  24060088   ADDIU A2, ZERO, 136
9D00D2AC  0F401F60   JAL SST25ReadArray
9D00D2B0  00000000   NOP
247:                 
248:                 }	
9D00D2B4  03C0E821   ADDU SP, S8, ZERO
9D00D2B8  8FBF0014   LW RA, 20(SP)
9D00D2BC  8FBE0010   LW S8, 16(SP)
9D00D2C0  27BD0018   ADDIU SP, SP, 24
9D00D2C4  03E00008   JR RA
9D00D2C8  00000000   NOP
249:                 	
250:                 // end of SystemParameters.c
251:                 
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/Stubs.c  -------------------------
1:                   
2:                   
3:                   #include <GenericTypeDefs.h>
4:                   
5:                   #include <string.h>
6:                   #include "ftoa.h"
7:                   #include "gsfstd.h"						// gsf standard #defines
8:                   #include "Debug.h"
9:                   #include "SmartTrak.h"
10:                  
11:                  void CurrentOrientation_Read(SmartTrakOrientation *ptrOrientation)
12:                  {
9D00D2CC  27BDFFF8   ADDIU SP, SP, -8
9D00D2D0  AFBE0004   SW S8, 4(SP)
9D00D2D4  03A0F021   ADDU S8, SP, ZERO
9D00D2D8  AFC40008   SW A0, 8(S8)
13:                  	ptrOrientation->fAzimuth = 0.0;
9D00D2DC  8FC20008   LW V0, 8(S8)
9D00D2E0  00001821   ADDU V1, ZERO, ZERO
9D00D2E4  AC430000   SW V1, 0(V0)
14:                  	ptrOrientation->fElevation = 0.0;
9D00D2E8  8FC20008   LW V0, 8(S8)
9D00D2EC  00001821   ADDU V1, ZERO, ZERO
9D00D2F0  AC430004   SW V1, 4(V0)
15:                  
16:                  }
9D00D2F4  03C0E821   ADDU SP, S8, ZERO
9D00D2F8  8FBE0004   LW S8, 4(SP)
9D00D2FC  27BD0008   ADDIU SP, SP, 8
9D00D300  03E00008   JR RA
9D00D304  00000000   NOP
17:                  
18:                  void CurrentOrientation_Format(char *ptrOutputStr)
19:                  {
9D00D308  27BDFFD8   ADDIU SP, SP, -40
9D00D30C  AFBF0024   SW RA, 36(SP)
9D00D310  AFBE0020   SW S8, 32(SP)
9D00D314  03A0F021   ADDU S8, SP, ZERO
9D00D318  AFC40028   SW A0, 40(S8)
20:                  	int nStatus = 0;
9D00D31C  AFC00010   SW ZERO, 16(S8)
21:                  
22:                  	SmartTrakOrientation Orientation;
23:                  	CurrentOrientation_Read(&Orientation);
9D00D320  27C20014   ADDIU V0, S8, 20
9D00D324  00402021   ADDU A0, V0, ZERO
9D00D328  0F4034B3   JAL CurrentOrientation_Read
9D00D32C  00000000   NOP
24:                  	strcpy(ptrOutputStr, "\tAzimuth: ");
9D00D330  8FC40028   LW A0, 40(S8)
9D00D334  3C029D01   LUI V0, -25343
9D00D338  2445E6AC   ADDIU A1, V0, -6484
9D00D33C  2406000B   ADDIU A2, ZERO, 11
9D00D340  0F403592   JAL 0x9D00D648
9D00D344  00000000   NOP
25:                  	strcat(ptrOutputStr, ftoa(Orientation.fAzimuth, &nStatus));
9D00D348  8FC20014   LW V0, 20(S8)
9D00D34C  00402021   ADDU A0, V0, ZERO
9D00D350  27C20010   ADDIU V0, S8, 16
9D00D354  00402821   ADDU A1, V0, ZERO
9D00D358  0F403090   JAL ftoa
9D00D35C  00000000   NOP
9D00D360  8FC40028   LW A0, 40(S8)
9D00D364  00402821   ADDU A1, V0, ZERO
9D00D368  0F4038FB   JAL strcat
9D00D36C  00000000   NOP
26:                  	strcat(ptrOutputStr, "  Elevation: ");
9D00D370  8FC40028   LW A0, 40(S8)
9D00D374  0F4035EC   JAL 0x9D00D7B0
9D00D378  00000000   NOP
9D00D37C  8FC30028   LW V1, 40(S8)
9D00D380  00621021   ADDU V0, V1, V0
9D00D384  00402021   ADDU A0, V0, ZERO
9D00D388  3C029D01   LUI V0, -25343
9D00D38C  2445E6B8   ADDIU A1, V0, -6472
9D00D390  2406000E   ADDIU A2, ZERO, 14
9D00D394  0F403592   JAL 0x9D00D648
9D00D398  00000000   NOP
27:                  	strcat(ptrOutputStr, ftoa(Orientation.fElevation, &nStatus));
9D00D39C  8FC20018   LW V0, 24(S8)
9D00D3A0  00402021   ADDU A0, V0, ZERO
9D00D3A4  27C20010   ADDIU V0, S8, 16
9D00D3A8  00402821   ADDU A1, V0, ZERO
9D00D3AC  0F403090   JAL ftoa
9D00D3B0  00000000   NOP
9D00D3B4  8FC40028   LW A0, 40(S8)
9D00D3B8  00402821   ADDU A1, V0, ZERO
9D00D3BC  0F4038FB   JAL strcat
9D00D3C0  00000000   NOP
28:                  
29:                  }
9D00D3C4  03C0E821   ADDU SP, S8, ZERO
9D00D3C8  8FBF0024   LW RA, 36(SP)
9D00D3CC  8FBE0020   LW S8, 32(SP)
9D00D3D0  27BD0028   ADDIU SP, SP, 40
9D00D3D4  03E00008   JR RA
9D00D3D8  00000000   NOP
30:                  
31:                  void SetCommandStarted(void)					// mark command as started so we cannot misinterpret completion
32:                  {
9D00D3DC  27BDFFF8   ADDIU SP, SP, -8
9D00D3E0  AFBE0004   SW S8, 4(SP)
9D00D3E4  03A0F021   ADDU S8, SP, ZERO
33:                  
34:                  }
9D00D3E8  03C0E821   ADDU SP, S8, ZERO
9D00D3EC  8FBE0004   LW S8, 4(SP)
9D00D3F0  27BD0008   ADDIU SP, SP, 8
9D00D3F4  03E00008   JR RA
9D00D3F8  00000000   NOP
35:                  
36:                  BOOL IsCommandComplete(void)
37:                  {
9D00D3FC  27BDFFF8   ADDIU SP, SP, -8
9D00D400  AFBE0004   SW S8, 4(SP)
9D00D404  03A0F021   ADDU S8, SP, ZERO
38:                  	return TRUE;
9D00D408  24020001   ADDIU V0, ZERO, 1
39:                  }
9D00D40C  03C0E821   ADDU SP, S8, ZERO
9D00D410  8FBE0004   LW S8, 4(SP)
9D00D414  27BD0008   ADDIU SP, SP, 8
9D00D418  03E00008   JR RA
9D00D41C  00000000   NOP
40:                  
41:                  void Reset(void)
42:                  {
9D00D420  27BDFFF8   ADDIU SP, SP, -8
9D00D424  AFBE0004   SW S8, 4(SP)
9D00D428  03A0F021   ADDU S8, SP, ZERO
43:                  
44:                  }
9D00D42C  03C0E821   ADDU SP, S8, ZERO
9D00D430  8FBE0004   LW S8, 4(SP)
9D00D434  27BD0008   ADDIU SP, SP, 8
9D00D438  03E00008   JR RA
9D00D43C  00000000   NOP
45:                  
46:                  BOOL IsMoveSequenceComplete(void)
47:                  {
9D00D440  27BDFFF8   ADDIU SP, SP, -8
9D00D444  AFBE0004   SW S8, 4(SP)
9D00D448  03A0F021   ADDU S8, SP, ZERO
48:                  	return TRUE;
9D00D44C  24020001   ADDIU V0, ZERO, 1
49:                  }
9D00D450  03C0E821   ADDU SP, S8, ZERO
9D00D454  8FBE0004   LW S8, 4(SP)
9D00D458  27BD0008   ADDIU SP, SP, 8
9D00D45C  03E00008   JR RA
9D00D460  00000000   NOP
50:                  
51:                  void SetMoveSequenceStarted()						// mark Move Sequence as started so we cannot misinterpret completion
52:                  {
9D00D464  27BDFFF8   ADDIU SP, SP, -8
9D00D468  AFBE0004   SW S8, 4(SP)
9D00D46C  03A0F021   ADDU S8, SP, ZERO
53:                  
54:                  }
9D00D470  03C0E821   ADDU SP, S8, ZERO
9D00D474  8FBE0004   LW S8, 4(SP)
9D00D478  27BD0008   ADDIU SP, SP, 8
9D00D47C  03E00008   JR RA
9D00D480  00000000   NOP
55:                  
56:                  BYTE GetInputSwitchState(void)
57:                  {
9D00D484  27BDFFF8   ADDIU SP, SP, -8
9D00D488  AFBE0004   SW S8, 4(SP)
9D00D48C  03A0F021   ADDU S8, SP, ZERO
58:                  	return 0;
9D00D490  00001021   ADDU V0, ZERO, ZERO
59:                  }
9D00D494  03C0E821   ADDU SP, S8, ZERO
9D00D498  8FBE0004   LW S8, 4(SP)
9D00D49C  27BD0008   ADDIU SP, SP, 8
9D00D4A0  03E00008   JR RA
9D00D4A4  00000000   NOP
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/StrConversions.c  ----------------
1:                   //*************************************************************************************************
2:                   //								S t r C o n v e r s i o n s . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Debug Runtime Error Handler functions
8:                   //
9:                   //		001	24 Feb 13 <sek> created from gsf Code Base
10:                  //
11:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
12:                  //					gsf Engineering	978-927-7189
13:                  //					Beverly, MA 01915
14:                  //
15:                  //		copyright (c) 2013 gsf Engineering
16:                  //
17:                  //*************************************************************************************************
18:                  
19:                  #include <GenericTypeDefs.h>
20:                  
21:                  // processor include file
22:                  //lint -e765					error 765: (Info -- external function could be made static)
23:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
24:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
25:                  //lint +e14
26:                  
27:                  
28:                  #include <string.h>				// Microchip string functions
29:                  
30:                  #include "gsfstd.h"				// gsf standard #defines, use <> so lint will treat this as a library file
31:                  #include "StrConversions.h"			
32:                  
33:                  
34:                  PRIVATE char HextoASCII(BYTE data);
35:                  
36:                  
37:                  //*****************************************************************************
38:                  //				s p r i n t ( ), s c a n f ( )   R e p l a c e m e n t s
39:                  //*****************************************************************************
40:                  
41:                  // NOTE: all of these functions are written to work with RAM based data, both input and output
42:                  
43:                  //*****************************************************************************
44:                  //							Data to ASCII
45:                  //*****************************************************************************
46:                  
47:                  // this array (a string, really) is used to convert a single nibl of hex data to its equivalent ASCII value
48:                  FILE_GLOBAL ARRAY char fgcHexToAscii[] = "0123456789ABCDEF";
49:                  
50:                  PRIVATE char HextoASCII(BYTE data)
51:                  {
9D00AF98  27BDFFF8   ADDIU SP, SP, -8
9D00AF9C  AFBE0004   SW S8, 4(SP)
9D00AFA0  03A0F021   ADDU S8, SP, ZERO
9D00AFA4  00801021   ADDU V0, A0, ZERO
9D00AFA8  A3C20008   SB V0, 8(S8)
52:                  	if (data <= 0x0F)
9D00AFAC  93C20008   LBU V0, 8(S8)
9D00AFB0  2C420010   SLTIU V0, V0, 16
9D00AFB4  10400008   BEQ V0, ZERO, 0x9D00AFD8
9D00AFB8  00000000   NOP
53:                  		{
54:                  		return(fgcHexToAscii[data]);
9D00AFBC  93C30008   LBU V1, 8(S8)
9D00AFC0  3C02A000   LUI V0, -24576
9D00AFC4  244208F4   ADDIU V0, V0, 2292
9D00AFC8  00621021   ADDU V0, V1, V0
9D00AFCC  80420000   LB V0, 0(V0)
9D00AFD0  0B402BF7   J 0x9D00AFDC
9D00AFD4  00000000   NOP
55:                  		}
56:                  	else
57:                  		{
58:                  		return('?');		// meaningless placekeeper
9D00AFD8  2402003F   ADDIU V0, ZERO, 63
59:                  		}
60:                  }
9D00AFDC  03C0E821   ADDU SP, S8, ZERO
9D00AFE0  8FBE0004   LW S8, 4(SP)
9D00AFE4  27BD0008   ADDIU SP, SP, 8
9D00AFE8  03E00008   JR RA
9D00AFEC  00000000   NOP
61:                  
62:                  // unsigned 8 bit to Decimal ASCII string
63:                  /* not used anywhere
64:                  char DectoASCII(BYTE data)
65:                  {
66:                  	if (data <= 0x09)
67:                  		{
68:                  		return(fgcHexToAscii[data]);
69:                  		}
70:                  	else
71:                  		{
72:                  		return('?');		// meaningless placekeeper
73:                  		}
74:                  }
75:                  */
76:                  
77:                  /* not used anywhere
78:                  void BYTEtoASCIIstr(BYTE cData, char *pStr)
79:                  	{
80:                  	WORDtoASCIIstr((WORD) cData, BYTE_WIDTH, pStr);
81:                  	}
82:                  */
83:                  
84:                  
85:                  // unsigned 8 bit to HEX ASCII string
86:                  void BYTEtoHexASCIIstr(BYTE cData, char *pStr)
87:                  	{
9D00AFF0  27BDFFE8   ADDIU SP, SP, -24
9D00AFF4  AFBF0014   SW RA, 20(SP)
9D00AFF8  AFBE0010   SW S8, 16(SP)
9D00AFFC  03A0F021   ADDU S8, SP, ZERO
9D00B000  00801021   ADDU V0, A0, ZERO
9D00B004  AFC5001C   SW A1, 28(S8)
9D00B008  A3C20018   SB V0, 24(S8)
88:                  	// convert hi nibl
89:                  	*pStr = HextoASCII((cData >> 4) & 0x0F);
9D00B00C  93C20018   LBU V0, 24(S8)
9D00B010  00021102   SRL V0, V0, 4
9D00B014  304200FF   ANDI V0, V0, 255
9D00B018  00402021   ADDU A0, V0, ZERO
9D00B01C  0F402BE6   JAL 0x9D00AF98
9D00B020  00000000   NOP
9D00B024  00401821   ADDU V1, V0, ZERO
9D00B028  8FC2001C   LW V0, 28(S8)
9D00B02C  A0430000   SB V1, 0(V0)
90:                  	++pStr;
9D00B030  8FC2001C   LW V0, 28(S8)
9D00B034  24420001   ADDIU V0, V0, 1
9D00B038  AFC2001C   SW V0, 28(S8)
91:                  
92:                  	// convert low nibl
93:                  	*pStr = HextoASCII(cData & 0x0F);
9D00B03C  93C20018   LBU V0, 24(S8)
9D00B040  3042000F   ANDI V0, V0, 15
9D00B044  00402021   ADDU A0, V0, ZERO
9D00B048  0F402BE6   JAL 0x9D00AF98
9D00B04C  00000000   NOP
9D00B050  00401821   ADDU V1, V0, ZERO
9D00B054  8FC2001C   LW V0, 28(S8)
9D00B058  A0430000   SB V1, 0(V0)
94:                  	++pStr;
9D00B05C  8FC2001C   LW V0, 28(S8)
9D00B060  24420001   ADDIU V0, V0, 1
9D00B064  AFC2001C   SW V0, 28(S8)
95:                  
96:                  	// add terminator
97:                  	*pStr = '\0';
9D00B068  8FC2001C   LW V0, 28(S8)
9D00B06C  A0400000   SB ZERO, 0(V0)
98:                  	}
9D00B070  03C0E821   ADDU SP, S8, ZERO
9D00B074  8FBF0014   LW RA, 20(SP)
9D00B078  8FBE0010   LW S8, 16(SP)
9D00B07C  27BD0018   ADDIU SP, SP, 24
9D00B080  03E00008   JR RA
9D00B084  00000000   NOP
99:                  
100:                 // unsigned 8 bit to HEX ASCII string
101:                 void WORDtoHexASCIIstr(WORD wData, char *pStr)
102:                 	{
9D00B088  27BDFFE8   ADDIU SP, SP, -24
9D00B08C  AFBF0014   SW RA, 20(SP)
9D00B090  AFBE0010   SW S8, 16(SP)
9D00B094  03A0F021   ADDU S8, SP, ZERO
9D00B098  00801021   ADDU V0, A0, ZERO
9D00B09C  AFC5001C   SW A1, 28(S8)
9D00B0A0  A7C20018   SH V0, 24(S8)
103:                 	// convert MSB hi nibl
104:                 	*pStr = HextoASCII((wData >> 12) & 0x000F);
9D00B0A4  97C20018   LHU V0, 24(S8)
9D00B0A8  00021302   SRL V0, V0, 12
9D00B0AC  3042FFFF   ANDI V0, V0, -1
9D00B0B0  304200FF   ANDI V0, V0, 255
9D00B0B4  3042000F   ANDI V0, V0, 15
9D00B0B8  00402021   ADDU A0, V0, ZERO
9D00B0BC  0F402BE6   JAL 0x9D00AF98
9D00B0C0  00000000   NOP
9D00B0C4  00401821   ADDU V1, V0, ZERO
9D00B0C8  8FC2001C   LW V0, 28(S8)
9D00B0CC  A0430000   SB V1, 0(V0)
105:                 	++pStr;
9D00B0D0  8FC2001C   LW V0, 28(S8)
9D00B0D4  24420001   ADDIU V0, V0, 1
9D00B0D8  AFC2001C   SW V0, 28(S8)
106:                 
107:                 	// convert MSB low nibl
108:                 	*pStr = HextoASCII((wData >> 8) & 0x000F);
9D00B0DC  97C20018   LHU V0, 24(S8)
9D00B0E0  00021202   SRL V0, V0, 8
9D00B0E4  3042FFFF   ANDI V0, V0, -1
9D00B0E8  304200FF   ANDI V0, V0, 255
9D00B0EC  3042000F   ANDI V0, V0, 15
9D00B0F0  00402021   ADDU A0, V0, ZERO
9D00B0F4  0F402BE6   JAL 0x9D00AF98
9D00B0F8  00000000   NOP
9D00B0FC  00401821   ADDU V1, V0, ZERO
9D00B100  8FC2001C   LW V0, 28(S8)
9D00B104  A0430000   SB V1, 0(V0)
109:                 	++pStr;
9D00B108  8FC2001C   LW V0, 28(S8)
9D00B10C  24420001   ADDIU V0, V0, 1
9D00B110  AFC2001C   SW V0, 28(S8)
110:                 
111:                 	// convert LSB hi nibl
112:                 	*pStr = HextoASCII((wData >> 4) & 0x000F);
9D00B114  97C20018   LHU V0, 24(S8)
9D00B118  00021102   SRL V0, V0, 4
9D00B11C  3042FFFF   ANDI V0, V0, -1
9D00B120  304200FF   ANDI V0, V0, 255
9D00B124  3042000F   ANDI V0, V0, 15
9D00B128  00402021   ADDU A0, V0, ZERO
9D00B12C  0F402BE6   JAL 0x9D00AF98
9D00B130  00000000   NOP
9D00B134  00401821   ADDU V1, V0, ZERO
9D00B138  8FC2001C   LW V0, 28(S8)
9D00B13C  A0430000   SB V1, 0(V0)
113:                 	++pStr;
9D00B140  8FC2001C   LW V0, 28(S8)
9D00B144  24420001   ADDIU V0, V0, 1
9D00B148  AFC2001C   SW V0, 28(S8)
114:                 
115:                 	// convert LSB low nibl
116:                 	*pStr = HextoASCII(wData & 0x000F);
9D00B14C  97C20018   LHU V0, 24(S8)
9D00B150  304200FF   ANDI V0, V0, 255
9D00B154  3042000F   ANDI V0, V0, 15
9D00B158  00402021   ADDU A0, V0, ZERO
9D00B15C  0F402BE6   JAL 0x9D00AF98
9D00B160  00000000   NOP
9D00B164  00401821   ADDU V1, V0, ZERO
9D00B168  8FC2001C   LW V0, 28(S8)
9D00B16C  A0430000   SB V1, 0(V0)
117:                 	++pStr;
9D00B170  8FC2001C   LW V0, 28(S8)
9D00B174  24420001   ADDIU V0, V0, 1
9D00B178  AFC2001C   SW V0, 28(S8)
118:                 
119:                 	// add terminator
120:                 	*pStr = '\0';
9D00B17C  8FC2001C   LW V0, 28(S8)
9D00B180  A0400000   SB ZERO, 0(V0)
121:                 	}
9D00B184  03C0E821   ADDU SP, S8, ZERO
9D00B188  8FBF0014   LW RA, 20(SP)
9D00B18C  8FBE0010   LW S8, 16(SP)
9D00B190  27BD0018   ADDIU SP, SP, 24
9D00B194  03E00008   JR RA
9D00B198  00000000   NOP
122:                 
123:                 
124:                 
125:                 // UNsigned 16 bit word to Decimal ASCII string
126:                 void WORDtoASCIIstr(WORD wData, BYTE cOutputWidth, char *pStr)
127:                 	{
9D00B19C  27BDFFD8   ADDIU SP, SP, -40
9D00B1A0  AFBF0024   SW RA, 36(SP)
9D00B1A4  AFBE0020   SW S8, 32(SP)
9D00B1A8  03A0F021   ADDU S8, SP, ZERO
9D00B1AC  00801821   ADDU V1, A0, ZERO
9D00B1B0  00A01021   ADDU V0, A1, ZERO
9D00B1B4  AFC60030   SW A2, 48(S8)
9D00B1B8  A7C30028   SH V1, 40(S8)
9D00B1BC  A3C2002C   SB V0, 44(S8)
128:                 	LOCAL ARRAY char strTemp[10];
129:                 
130:                 	// maximum output width is 5 characters, for decimal equivalent of 16 bits
131:                     BYTE	i = cOutputWidth - 1;			// output index, start at LSD end, leaving one character for the terminator
9D00B1C0  93C2002C   LBU V0, 44(S8)
9D00B1C4  2442FFFF   ADDIU V0, V0, -1
9D00B1C8  A3C20010   SB V0, 16(S8)
132:                 	BYTE	cOutputCtr = 0;					// count of output characters, to avoid comparing an index to 0
9D00B1CC  A3C00011   SB ZERO, 17(S8)
133:                 
134:                 	// generate ASCII digits from LSD to MSD
135:                     do 
136:                 		{
137:                 		// divide by 10, and convert the REMAINDER into a digit, moving to the LEFT
138:                 		strTemp[i--] = wData % 10 + '0';
9D00B1D0  93C20010   LBU V0, 16(S8)
9D00B1D4  97C40028   LHU A0, 40(S8)
9D00B1D8  2403000A   ADDIU V1, ZERO, 10
9D00B1DC  0083001B   DIVU A0, V1
9D00B1E0  006001F4   TEQ V1, ZERO
9D00B1E4  00001810   MFHI V1
9D00B1E8  3063FFFF   ANDI V1, V1, -1
9D00B1EC  306300FF   ANDI V1, V1, 255
9D00B1F0  24630030   ADDIU V1, V1, 48
9D00B1F4  306300FF   ANDI V1, V1, 255
9D00B1F8  7C031C20   SEB V1, V1
9D00B1FC  27C40010   ADDIU A0, S8, 16
9D00B200  00821021   ADDU V0, A0, V0
9D00B204  A0430004   SB V1, 4(V0)
9D00B208  93C20010   LBU V0, 16(S8)
9D00B20C  2442FFFF   ADDIU V0, V0, -1
9D00B210  A3C20010   SB V0, 16(S8)
139:                 
140:                 		++cOutputCtr;						// bump count of output characters
9D00B214  93C20011   LBU V0, 17(S8)
9D00B218  24420001   ADDIU V0, V0, 1
9D00B21C  A3C20011   SB V0, 17(S8)
141:                 
142:                 		// divide by 10 to strip away the data just converted
143:                 		wData /= 10;
9D00B220  97C30028   LHU V1, 40(S8)
9D00B224  3C02CCCC   LUI V0, -13108
9D00B228  3442CCCD   ORI V0, V0, -13107
9D00B22C  00620019   MULTU V1, V0
9D00B230  00001012   MFLO V0
9D00B234  00001810   MFHI V1
9D00B238  000310C2   SRL V0, V1, 3
9D00B23C  A7C20028   SH V0, 40(S8)
144:                 		}
145:                 	while ((wData > (WORD)0) AND (cOutputCtr IS_NOT cOutputWidth));	// while we still have something left to convert, and have not used the full output width
9D00B240  97C20028   LHU V0, 40(S8)
9D00B244  10400012   BEQ V0, ZERO, 0x9D00B290
9D00B248  00000000   NOP
9D00B24C  93C30011   LBU V1, 17(S8)
9D00B250  93C2002C   LBU V0, 44(S8)
9D00B254  1462FFDE   BNE V1, V0, 0x9D00B1D0
9D00B258  00000000   NOP
146:                 
147:                 
148:                 	// if we are not out of string, move LEFT and fill the rest with spaces
149:                 	while (cOutputCtr IS_NOT cOutputWidth)	// while we have not used the full output width
9D00B25C  0B402CA4   J 0x9D00B290
9D00B260  00000000   NOP
9D00B290  93C30011   LBU V1, 17(S8)
9D00B294  93C2002C   LBU V0, 44(S8)
9D00B298  1462FFF2   BNE V1, V0, 0x9D00B264
9D00B29C  00000000   NOP
150:                 		{
151:                 		strTemp[i] = ' ';					// pad with SPACE
9D00B264  93C20010   LBU V0, 16(S8)
9D00B268  27C30010   ADDIU V1, S8, 16
9D00B26C  00621021   ADDU V0, V1, V0
9D00B270  24030020   ADDIU V1, ZERO, 32
9D00B274  A0430004   SB V1, 4(V0)
152:                 		--i;								// bump index LEFT
9D00B278  93C20010   LBU V0, 16(S8)
9D00B27C  2442FFFF   ADDIU V0, V0, -1
9D00B280  A3C20010   SB V0, 16(S8)
153:                 		++cOutputCtr;						// bump count of output characters
9D00B284  93C20011   LBU V0, 17(S8)
9D00B288  24420001   ADDIU V0, V0, 1
9D00B28C  A3C20011   SB V0, 17(S8)
154:                 		}
155:                 
156:                 	// add a string terminator
157:                     strTemp[cOutputWidth] = '\0';
9D00B2A0  93C2002C   LBU V0, 44(S8)
9D00B2A4  27C30010   ADDIU V1, S8, 16
9D00B2A8  00621021   ADDU V0, V1, V0
9D00B2AC  A0400004   SB ZERO, 4(V0)
158:                 
159:                 	strcpy(pStr, strTemp);
9D00B2B0  27C20014   ADDIU V0, S8, 20
9D00B2B4  8FC40030   LW A0, 48(S8)
9D00B2B8  00402821   ADDU A1, V0, ZERO
9D00B2BC  0F40352A   JAL 0x9D00D4A8
9D00B2C0  00000000   NOP
160:                 	}
9D00B2C4  03C0E821   ADDU SP, S8, ZERO
9D00B2C8  8FBF0024   LW RA, 36(SP)
9D00B2CC  8FBE0020   LW S8, 32(SP)
9D00B2D0  27BD0028   ADDIU SP, SP, 40
9D00B2D4  03E00008   JR RA
9D00B2D8  00000000   NOP
161:                 
162:                 
163:                 // Signed 16 bit word to Decimal ASCII string
164:                 void INT16StoASCIIstr(INT16S nData, BYTE cOutputWidth, char *pStr)
165:                 	{
9D00B2DC  27BDFFD0   ADDIU SP, SP, -48
9D00B2E0  AFBF002C   SW RA, 44(SP)
9D00B2E4  AFBE0028   SW S8, 40(SP)
9D00B2E8  03A0F021   ADDU S8, SP, ZERO
9D00B2EC  AFC40030   SW A0, 48(S8)
9D00B2F0  00A01021   ADDU V0, A1, ZERO
9D00B2F4  AFC60038   SW A2, 56(S8)
9D00B2F8  A3C20034   SB V0, 52(S8)
166:                 	LOCAL ARRAY char strTemp[10];
167:                 
168:                 	// maximum output width is 5 characters plus sign, for decimal equivalent of 16 bits
169:                     INT16S	nDataCopy;						// copy of original data, to keep track of the sign
170:                     BYTE	i = cOutputWidth - 1;			// output index, start at LSD end, leaving one character for the terminator
9D00B2FC  93C20034   LBU V0, 52(S8)
9D00B300  2442FFFF   ADDIU V0, V0, -1
9D00B304  A3C20010   SB V0, 16(S8)
171:                 	BYTE	cOutputCtr = 0;					// count of output characters, to avoid comparing an index to 0
9D00B308  A3C00011   SB ZERO, 17(S8)
172:                 
173:                 	nDataCopy = nData;						// keep a copy of the original data value, to keep track of the sign...
9D00B30C  8FC20030   LW V0, 48(S8)
9D00B310  AFC20014   SW V0, 20(S8)
174:                     if (nData < 0)							// if nData is negative, we need to work with the absolute value
9D00B314  8FC20030   LW V0, 48(S8)
9D00B318  04410004   BGEZ V0, 0x9D00B32C
9D00B31C  00000000   NOP
175:                 		{
176:                         nData = -nData;						// make nData positive
9D00B320  8FC20030   LW V0, 48(S8)
9D00B324  00021023   SUBU V0, ZERO, V0
9D00B328  AFC20030   SW V0, 48(S8)
177:                 		}
178:                 
179:                 	// generate ASCII digits from LSD to MSD
180:                     do 
181:                 		{
182:                 		// divide by 10, and convert the REMAINDER into a digit, moving to the LEFT
183:                 		strTemp[i--] = nData % 10 + '0';
9D00B32C  93C20010   LBU V0, 16(S8)
9D00B330  8FC40030   LW A0, 48(S8)
9D00B334  2403000A   ADDIU V1, ZERO, 10
9D00B338  0083001A   DIV A0, V1
9D00B33C  006001F4   TEQ V1, ZERO
9D00B340  00001810   MFHI V1
9D00B344  306300FF   ANDI V1, V1, 255
9D00B348  24630030   ADDIU V1, V1, 48
9D00B34C  306300FF   ANDI V1, V1, 255
9D00B350  7C031C20   SEB V1, V1
9D00B354  27C40010   ADDIU A0, S8, 16
9D00B358  00821021   ADDU V0, A0, V0
9D00B35C  A0430008   SB V1, 8(V0)
9D00B360  93C20010   LBU V0, 16(S8)
9D00B364  2442FFFF   ADDIU V0, V0, -1
9D00B368  A3C20010   SB V0, 16(S8)
184:                 
185:                 		++cOutputCtr;						// bump count of output characters
9D00B36C  93C20011   LBU V0, 17(S8)
9D00B370  24420001   ADDIU V0, V0, 1
9D00B374  A3C20011   SB V0, 17(S8)
186:                 
187:                 		// divide by 10 to strip away the data just converted
188:                 		nData /= 10;
9D00B378  8FC30030   LW V1, 48(S8)
9D00B37C  2402000A   ADDIU V0, ZERO, 10
9D00B380  0062001A   DIV V1, V0
9D00B384  004001F4   TEQ V0, ZERO
9D00B388  00001810   MFHI V1
9D00B38C  00001012   MFLO V0
9D00B390  AFC20030   SW V0, 48(S8)
189:                 		}
190:                 	while ((nData > 0) AND (cOutputCtr < cOutputWidth));	// while we still have something left to convert, and have not used the full output width
9D00B394  8FC20030   LW V0, 48(S8)
9D00B398  18400006   BLEZ V0, 0x9D00B3B4
9D00B39C  00000000   NOP
9D00B3A0  93C30011   LBU V1, 17(S8)
9D00B3A4  93C20034   LBU V0, 52(S8)
9D00B3A8  0062102B   SLTU V0, V1, V0
9D00B3AC  1440FFDF   BNE V0, ZERO, 0x9D00B32C
9D00B3B0  00000000   NOP
191:                 
192:                 	// now restore the original sign
193:                     if (nDataCopy < 0)
9D00B3B4  8FC20014   LW V0, 20(S8)
9D00B3B8  04410008   BGEZ V0, 0x9D00B3DC
9D00B3BC  00000000   NOP
194:                 		{
195:                         strTemp[i] = '-';					// sign character for negative
9D00B3C0  93C20010   LBU V0, 16(S8)
9D00B3C4  27C30010   ADDIU V1, S8, 16
9D00B3C8  00621021   ADDU V0, V1, V0
9D00B3CC  2403002D   ADDIU V1, ZERO, 45
9D00B3D0  A0430008   SB V1, 8(V0)
9D00B3D4  0B402CFC   J 0x9D00B3F0
9D00B3D8  00000000   NOP
196:                 		}
197:                 	else
198:                 		{
199:                         strTemp[i] = ' ';					// just a space for positive
9D00B3DC  93C20010   LBU V0, 16(S8)
9D00B3E0  27C30010   ADDIU V1, S8, 16
9D00B3E4  00621021   ADDU V0, V1, V0
9D00B3E8  24030020   ADDIU V1, ZERO, 32
9D00B3EC  A0430008   SB V1, 8(V0)
200:                 		}
201:                 	--i;									// bump output index
9D00B3F0  93C20010   LBU V0, 16(S8)
9D00B3F4  2442FFFF   ADDIU V0, V0, -1
9D00B3F8  A3C20010   SB V0, 16(S8)
202:                 	++cOutputCtr;							// bump count of output characters to account for sign or space
9D00B3FC  93C20011   LBU V0, 17(S8)
9D00B400  24420001   ADDIU V0, V0, 1
9D00B404  A3C20011   SB V0, 17(S8)
203:                 
204:                 
205:                 	// if we are not out of string, move LEFT and fill the rest with spaces
206:                 	while (cOutputCtr IS_NOT cOutputWidth)	// while we have not used the full output width
9D00B408  0B402D0F   J 0x9D00B43C
9D00B40C  00000000   NOP
9D00B43C  93C30011   LBU V1, 17(S8)
9D00B440  93C20034   LBU V0, 52(S8)
9D00B444  1462FFF2   BNE V1, V0, 0x9D00B410
9D00B448  00000000   NOP
207:                 		{
208:                 		strTemp[i] = ' ';					// pad with SPACE
9D00B410  93C20010   LBU V0, 16(S8)
9D00B414  27C30010   ADDIU V1, S8, 16
9D00B418  00621021   ADDU V0, V1, V0
9D00B41C  24030020   ADDIU V1, ZERO, 32
9D00B420  A0430008   SB V1, 8(V0)
209:                 		--i;								// bump index LEFT
9D00B424  93C20010   LBU V0, 16(S8)
9D00B428  2442FFFF   ADDIU V0, V0, -1
9D00B42C  A3C20010   SB V0, 16(S8)
210:                 		++cOutputCtr;						// bump count of output characters
9D00B430  93C20011   LBU V0, 17(S8)
9D00B434  24420001   ADDIU V0, V0, 1
9D00B438  A3C20011   SB V0, 17(S8)
211:                 		}
212:                 
213:                 	// add a string terminator
214:                     strTemp[cOutputWidth] = '\0';
9D00B44C  93C20034   LBU V0, 52(S8)
9D00B450  27C30010   ADDIU V1, S8, 16
9D00B454  00621021   ADDU V0, V1, V0
9D00B458  A0400008   SB ZERO, 8(V0)
215:                 
216:                 	strcpy(pStr, strTemp);
9D00B45C  27C20018   ADDIU V0, S8, 24
9D00B460  8FC40038   LW A0, 56(S8)
9D00B464  00402821   ADDU A1, V0, ZERO
9D00B468  0F40352A   JAL 0x9D00D4A8
9D00B46C  00000000   NOP
217:                 	}
9D00B470  03C0E821   ADDU SP, S8, ZERO
9D00B474  8FBF002C   LW RA, 44(SP)
9D00B478  8FBE0028   LW S8, 40(SP)
9D00B47C  27BD0030   ADDIU SP, SP, 48
9D00B480  03E00008   JR RA
9D00B484  00000000   NOP
218:                 
219:                 
220:                 #ifdef NOTDEF
221:                 	void INT32StoASCIIstr(INT32S lData, char *pStr)
222:                 		{
223:                 
224:                 		}
225:                 #endif
226:                 
227:                 // UNsigned 32 bit word to Decimal ASCII string
228:                 void INT32UtoASCIIstr(INT32U lData, BYTE cOutputWidth, char *pStr)
229:                 	{
9D00B488  27BDFFD8   ADDIU SP, SP, -40
9D00B48C  AFBF0024   SW RA, 36(SP)
9D00B490  AFBE0020   SW S8, 32(SP)
9D00B494  03A0F021   ADDU S8, SP, ZERO
9D00B498  AFC40028   SW A0, 40(S8)
9D00B49C  00A01021   ADDU V0, A1, ZERO
9D00B4A0  AFC60030   SW A2, 48(S8)
9D00B4A4  A3C2002C   SB V0, 44(S8)
230:                 	LOCAL ARRAY char strTemp[12];
231:                 
232:                 	// maximum output width is 10 characters, for decimal equivalent of 32 bits
233:                     BYTE	i = cOutputWidth - 1;			// output index, start at LSD end, leaving one character for the terminator
9D00B4A8  93C2002C   LBU V0, 44(S8)
9D00B4AC  2442FFFF   ADDIU V0, V0, -1
9D00B4B0  A3C20010   SB V0, 16(S8)
234:                 	BYTE	cOutputCtr = 0;					// count of output characters, to avoid comparing an index to 0
9D00B4B4  A3C00011   SB ZERO, 17(S8)
235:                 
236:                 	// generate ASCII digits from LSD to MSD
237:                     do 
238:                 		{
239:                 		// divide by 10, and convert the REMAINDER into a digit, moving to the LEFT
240:                 		strTemp[i--] = lData % 10L + '0';
9D00B4B8  93C40010   LBU A0, 16(S8)
9D00B4BC  8FC30028   LW V1, 40(S8)
9D00B4C0  3C02CCCC   LUI V0, -13108
9D00B4C4  3442CCCD   ORI V0, V0, -13107
9D00B4C8  00620019   MULTU V1, V0
9D00B4CC  00003012   MFLO A2
9D00B4D0  00003810   MFHI A3
9D00B4D4  000710C2   SRL V0, A3, 3
9D00B4D8  2405000A   ADDIU A1, ZERO, 10
9D00B4DC  70451002   MUL V0, V0, A1
9D00B4E0  00621023   SUBU V0, V1, V0
9D00B4E4  304200FF   ANDI V0, V0, 255
9D00B4E8  24420030   ADDIU V0, V0, 48
9D00B4EC  304200FF   ANDI V0, V0, 255
9D00B4F0  7C021C20   SEB V1, V0
9D00B4F4  27C20010   ADDIU V0, S8, 16
9D00B4F8  00441021   ADDU V0, V0, A0
9D00B4FC  A0430004   SB V1, 4(V0)
9D00B500  93C20010   LBU V0, 16(S8)
9D00B504  2442FFFF   ADDIU V0, V0, -1
9D00B508  A3C20010   SB V0, 16(S8)
241:                 
242:                 		++cOutputCtr;						// bump count of output characters
9D00B50C  93C20011   LBU V0, 17(S8)
9D00B510  24420001   ADDIU V0, V0, 1
9D00B514  A3C20011   SB V0, 17(S8)
243:                 
244:                 		// divide by 10 to strip away the data just converted
245:                 		lData /= 10L;
9D00B518  8FC30028   LW V1, 40(S8)
9D00B51C  3C02CCCC   LUI V0, -13108
9D00B520  3442CCCD   ORI V0, V0, -13107
9D00B524  00620019   MULTU V1, V0
9D00B528  00001012   MFLO V0
9D00B52C  00001810   MFHI V1
9D00B530  000310C2   SRL V0, V1, 3
9D00B534  AFC20028   SW V0, 40(S8)
246:                 		}
247:                 	while ((lData > (INT32U)0) AND (cOutputCtr IS_NOT cOutputWidth));	// while we still have something left to convert, and have not used the full output width
9D00B538  8FC20028   LW V0, 40(S8)
9D00B53C  10400012   BEQ V0, ZERO, 0x9D00B588
9D00B540  00000000   NOP
9D00B544  93C30011   LBU V1, 17(S8)
9D00B548  93C2002C   LBU V0, 44(S8)
9D00B54C  1462FFDA   BNE V1, V0, 0x9D00B4B8
9D00B550  00000000   NOP
248:                 
249:                 
250:                 	// if we are not out of string, move LEFT and fill the rest with spaces
251:                 	while (cOutputCtr IS_NOT cOutputWidth)	// while we have not used the full output width
9D00B554  0B402D62   J 0x9D00B588
9D00B558  00000000   NOP
9D00B588  93C30011   LBU V1, 17(S8)
9D00B58C  93C2002C   LBU V0, 44(S8)
9D00B590  1462FFF2   BNE V1, V0, 0x9D00B55C
9D00B594  00000000   NOP
252:                 		{
253:                 		strTemp[i] = ' ';					// pad with SPACE
9D00B55C  93C20010   LBU V0, 16(S8)
9D00B560  27C30010   ADDIU V1, S8, 16
9D00B564  00621021   ADDU V0, V1, V0
9D00B568  24030020   ADDIU V1, ZERO, 32
9D00B56C  A0430004   SB V1, 4(V0)
254:                 		--i;								// bump index LEFT
9D00B570  93C20010   LBU V0, 16(S8)
9D00B574  2442FFFF   ADDIU V0, V0, -1
9D00B578  A3C20010   SB V0, 16(S8)
255:                 		++cOutputCtr;						// bump count of output characters
9D00B57C  93C20011   LBU V0, 17(S8)
9D00B580  24420001   ADDIU V0, V0, 1
9D00B584  A3C20011   SB V0, 17(S8)
256:                 		}
257:                 
258:                 	// add a string terminator
259:                     strTemp[cOutputWidth] = '\0';
9D00B598  93C2002C   LBU V0, 44(S8)
9D00B59C  27C30010   ADDIU V1, S8, 16
9D00B5A0  00621021   ADDU V0, V1, V0
9D00B5A4  A0400004   SB ZERO, 4(V0)
260:                 
261:                 	strcpy(pStr, strTemp);
9D00B5A8  27C20014   ADDIU V0, S8, 20
9D00B5AC  8FC40030   LW A0, 48(S8)
9D00B5B0  00402821   ADDU A1, V0, ZERO
9D00B5B4  0F40352A   JAL 0x9D00D4A8
9D00B5B8  00000000   NOP
262:                 	}
9D00B5BC  03C0E821   ADDU SP, S8, ZERO
9D00B5C0  8FBF0024   LW RA, 36(SP)
9D00B5C4  8FBE0020   LW S8, 32(SP)
9D00B5C8  27BD0028   ADDIU SP, SP, 40
9D00B5CC  03E00008   JR RA
9D00B5D0  00000000   NOP
263:                 
264:                 // unsigned 32 bit word to Hex ASCII string
265:                 void INT32UtoHexASCIIstr(INT32U lData, char *pStr)
266:                 	{
9D00B5D4  27BDFFE8   ADDIU SP, SP, -24
9D00B5D8  AFBF0014   SW RA, 20(SP)
9D00B5DC  AFBE0010   SW S8, 16(SP)
9D00B5E0  03A0F021   ADDU S8, SP, ZERO
9D00B5E4  AFC40018   SW A0, 24(S8)
9D00B5E8  AFC5001C   SW A1, 28(S8)
267:                 	// convert MSB hi nibl
268:                 	*pStr = HextoASCII((lData >> 12) & 0x000F);
9D00B5EC  8FC20018   LW V0, 24(S8)
9D00B5F0  00021302   SRL V0, V0, 12
9D00B5F4  304200FF   ANDI V0, V0, 255
9D00B5F8  3042000F   ANDI V0, V0, 15
9D00B5FC  00402021   ADDU A0, V0, ZERO
9D00B600  0F402BE6   JAL 0x9D00AF98
9D00B604  00000000   NOP
9D00B608  00401821   ADDU V1, V0, ZERO
9D00B60C  8FC2001C   LW V0, 28(S8)
9D00B610  A0430000   SB V1, 0(V0)
269:                 	++pStr;
9D00B614  8FC2001C   LW V0, 28(S8)
9D00B618  24420001   ADDIU V0, V0, 1
9D00B61C  AFC2001C   SW V0, 28(S8)
270:                 
271:                 	// convert MSB low nibl
272:                 	*pStr = HextoASCII((lData >> 8) & 0x000F);
9D00B620  8FC20018   LW V0, 24(S8)
9D00B624  00021202   SRL V0, V0, 8
9D00B628  304200FF   ANDI V0, V0, 255
9D00B62C  3042000F   ANDI V0, V0, 15
9D00B630  00402021   ADDU A0, V0, ZERO
9D00B634  0F402BE6   JAL 0x9D00AF98
9D00B638  00000000   NOP
9D00B63C  00401821   ADDU V1, V0, ZERO
9D00B640  8FC2001C   LW V0, 28(S8)
9D00B644  A0430000   SB V1, 0(V0)
273:                 	++pStr;
9D00B648  8FC2001C   LW V0, 28(S8)
9D00B64C  24420001   ADDIU V0, V0, 1
9D00B650  AFC2001C   SW V0, 28(S8)
274:                 
275:                 	// convert LSB hi nibl
276:                 	*pStr = HextoASCII((lData >> 4) & 0x000F);
9D00B654  8FC20018   LW V0, 24(S8)
9D00B658  00021102   SRL V0, V0, 4
9D00B65C  304200FF   ANDI V0, V0, 255
9D00B660  3042000F   ANDI V0, V0, 15
9D00B664  00402021   ADDU A0, V0, ZERO
9D00B668  0F402BE6   JAL 0x9D00AF98
9D00B66C  00000000   NOP
9D00B670  00401821   ADDU V1, V0, ZERO
9D00B674  8FC2001C   LW V0, 28(S8)
9D00B678  A0430000   SB V1, 0(V0)
277:                 	++pStr;
9D00B67C  8FC2001C   LW V0, 28(S8)
9D00B680  24420001   ADDIU V0, V0, 1
9D00B684  AFC2001C   SW V0, 28(S8)
278:                 
279:                 	// convert LSB low nibl
280:                 	*pStr = HextoASCII(lData & 0x000F);
9D00B688  8FC20018   LW V0, 24(S8)
9D00B68C  304200FF   ANDI V0, V0, 255
9D00B690  3042000F   ANDI V0, V0, 15
9D00B694  00402021   ADDU A0, V0, ZERO
9D00B698  0F402BE6   JAL 0x9D00AF98
9D00B69C  00000000   NOP
9D00B6A0  00401821   ADDU V1, V0, ZERO
9D00B6A4  8FC2001C   LW V0, 28(S8)
9D00B6A8  A0430000   SB V1, 0(V0)
281:                 	++pStr;
9D00B6AC  8FC2001C   LW V0, 28(S8)
9D00B6B0  24420001   ADDIU V0, V0, 1
9D00B6B4  AFC2001C   SW V0, 28(S8)
282:                 
283:                 	// add terminator
284:                 	*pStr = '\0';
9D00B6B8  8FC2001C   LW V0, 28(S8)
9D00B6BC  A0400000   SB ZERO, 0(V0)
285:                 	}
9D00B6C0  03C0E821   ADDU SP, S8, ZERO
9D00B6C4  8FBF0014   LW RA, 20(SP)
9D00B6C8  8FBE0010   LW S8, 16(SP)
9D00B6CC  27BD0018   ADDIU SP, SP, 24
9D00B6D0  03E00008   JR RA
9D00B6D4  00000000   NOP
286:                 
287:                 
288:                 //*****************************************************************************
289:                 //						ASCII to Data Functions
290:                 //*****************************************************************************
291:                 
292:                 #ifdef NOTDEF
293:                 	BYTE ASCIItoHex(char cData)
294:                 	{
295:                 		BYTE cRetVal;
296:                 
297:                 		if ((cData >= 'a') AND (cData <= 'f'))
298:                 			{
299:                 			cRetVal = (BYTE)(10 + (cData - 'a'));			//a - f
300:                 			}
301:                 		else if ((cData >= 'A') AND (cData <= 'F'))
302:                 			{
303:                 			cRetVal = (BYTE)(10 + (cData - 'A'));			//A - F
304:                 			}
305:                 		else if ((cData >= '0') AND (cData <= '9'))
306:                 			{
307:                 			cRetVal = (BYTE)(cData - 0x30);	// 0 - 9
308:                 			}
309:                 		else
310:                 			{
311:                 			return 0;					// not a valid hex character
312:                 			}
313:                 		
314:                 		return(cRetVal);
315:                 	}
316:                 #endif
317:                 
318:                 
319:                 // end of MenuFSM.c
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/SerialDisplay.c  -----------------
1:                   //*************************************************************************************************
2:                   //										S e r i a l D i s p l a y . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Serial Display Code for Debug and Application
8:                   //
9:                   //		001	18 Feb 13 <sek> created from gsf Code Base
10:                  //		002	26 Feb 13 <sek> RealTime, Character functions added
11:                  //
12:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
13:                  //					gsf Engineering	978-927-7189
14:                  //					Beverly, MA 01915
15:                  //
16:                  //		copyright (c) 2013 gsf Engineering
17:                  //
18:                  //*************************************************************************************************
19:                  
20:                  //-----------------------------------------------------------------------------
21:                  // #include files
22:                  //-----------------------------------------------------------------------------
23:                  #include <GenericTypeDefs.h>
24:                  
25:                  // processor include file
26:                  //lint -e765					error 765: (Info -- external function could be made static)
27:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
28:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
29:                  //lint +e14
30:                  
31:                  #include <string.h>				// Microchip string functions
32:                  //#include <ctype.h>				// tolower()
33:                  
34:                  // gsf standard #defines, use <> so lint will treat this as a library file
35:                  #include "gsfstd.h"				// gsf standard #defines
36:                  
37:                  #include "Debug.h"
38:                  #include "SmartTrak.h"			// Project wide definitions
39:                  #include "HardwareProfile.h"
40:                  
41:                  //#include "RTCC.h"
42:                  #include "SerialPort.h"
43:                  #include "StrConversions.h"			// ASCII string <==> numeric conversions
44:                  //#include "Timer.h"				// Timer access functions
45:                  //#include "Debounce.h"			// Input Switch debounce functions
46:                  #include "SerialDisplay.h"
47:                  
48:                  //-------------------------------------------------------------------------------------------------------
49:                  // Definitions
50:                  //-------------------------------------------------------------------------------------------------------
51:                  
52:                  enum tagSerialDisplayErrors
53:                  {
54:                  	SER_DISPLAY_ERROR_NONE = SER_DISPLAY_ERROR_BASE,
55:                  	SER_DISPLAY_ERROR_UNEXPECTED_TICK,			// 1 unexpected timer tick event
56:                  	SER_DISPLAY_ERROR_UNEXPECTED_EVENT,			// 2 unexpected event
57:                  	SER_DISPLAY_ERROR_INVALID_STATE,			// 3 not a valid state
58:                  	SER_DISPLAY_ERROR_INVALID_SUBSTATE,			// 4 not a valid state
59:                  	SER_DISPLAY_ERROR_BUFFER_OVERFLOW			// 5 menu string too long
60:                  };
61:                  
62:                  
63:                  //-------------------------------------------------------------------------------------------------------
64:                  // Display string handlers
65:                  //-------------------------------------------------------------------------------------------------------
66:                  
67:                  const char * strNewLine = "\r\n";
68:                  
69:                  //*************************************
70:                  //		RAM string handlers
71:                  //*************************************
72:                  
73:                  void ClearDisplayStr(void)
74:                  	{
9D00B6D8  27BDFFF8   ADDIU SP, SP, -8
9D00B6DC  AFBE0004   SW S8, 4(SP)
9D00B6E0  03A0F021   ADDU S8, SP, ZERO
75:                  	szDisplayStr[0] = '\0';
9D00B6E4  3C02A000   LUI V0, -24576
9D00B6E8  A040047C   SB ZERO, 1148(V0)
76:                  	}
9D00B6EC  03C0E821   ADDU SP, S8, ZERO
9D00B6F0  8FBE0004   LW S8, 4(SP)
9D00B6F4  27BD0008   ADDIU SP, SP, 8
9D00B6F8  03E00008   JR RA
9D00B6FC  00000000   NOP
77:                  
78:                  void AddDisplayStr(const char *pStr)
79:                  	{
9D00B700  27BDFFE8   ADDIU SP, SP, -24
9D00B704  AFBF0014   SW RA, 20(SP)
9D00B708  AFBE0010   SW S8, 16(SP)
9D00B70C  03A0F021   ADDU S8, SP, ZERO
9D00B710  AFC40018   SW A0, 24(S8)
80:                  	strcat(szDisplayStr, pStr);
9D00B714  3C02A000   LUI V0, -24576
9D00B718  2444047C   ADDIU A0, V0, 1148
9D00B71C  8FC50018   LW A1, 24(S8)
9D00B720  0F4038FB   JAL strcat
9D00B724  00000000   NOP
81:                  
82:                  	// make sure we have not overrun the menu string buffer 
83:                  	if (strlen(szDisplayStr) > DISPLAY_STR_SIZE)
9D00B728  3C02A000   LUI V0, -24576
9D00B72C  2444047C   ADDIU A0, V0, 1148
9D00B730  0F4035EC   JAL 0x9D00D7B0
9D00B734  00000000   NOP
9D00B738  2C4200F2   SLTIU V0, V0, 242
9D00B73C  14400007   BNE V0, ZERO, 0x9D00B75C
9D00B740  00000000   NOP
84:                  		{
85:                  		szDisplayStr[DISPLAY_STR_SIZE] = '\0';
9D00B744  3C02A000   LUI V0, -24576
9D00B748  2442047C   ADDIU V0, V0, 1148
9D00B74C  A04000F1   SB ZERO, 241(V0)
86:                  		RuntimeError(SER_DISPLAY_ERROR_BUFFER_OVERFLOW);
9D00B750  240400B5   ADDIU A0, ZERO, 181
9D00B754  0F40365E   JAL _RuntimeError
9D00B758  00000000   NOP
87:                  		}
88:                  	}
9D00B75C  03C0E821   ADDU SP, S8, ZERO
9D00B760  8FBF0014   LW RA, 20(SP)
9D00B764  8FBE0010   LW S8, 16(SP)
9D00B768  27BD0018   ADDIU SP, SP, 24
9D00B76C  03E00008   JR RA
9D00B770  00000000   NOP
89:                  
90:                  void AddDisplayStrAndNewLine(const char *pStr)
91:                  	{
9D00B774  27BDFFE8   ADDIU SP, SP, -24
9D00B778  AFBF0014   SW RA, 20(SP)
9D00B77C  AFBE0010   SW S8, 16(SP)
9D00B780  03A0F021   ADDU S8, SP, ZERO
9D00B784  AFC40018   SW A0, 24(S8)
92:                  	strcat(szDisplayStr, pStr);
9D00B788  3C02A000   LUI V0, -24576
9D00B78C  2444047C   ADDIU A0, V0, 1148
9D00B790  8FC50018   LW A1, 24(S8)
9D00B794  0F4038FB   JAL strcat
9D00B798  00000000   NOP
93:                  
94:                  	// add a line terminator from a ROM string
95:                  	IGNORE_RETURN_VALUE strcat(szDisplayStr, "\r\n");
9D00B79C  3C02A000   LUI V0, -24576
9D00B7A0  2444047C   ADDIU A0, V0, 1148
9D00B7A4  0F4035EC   JAL 0x9D00D7B0
9D00B7A8  00000000   NOP
9D00B7AC  00401821   ADDU V1, V0, ZERO
9D00B7B0  3C02A000   LUI V0, -24576
9D00B7B4  2442047C   ADDIU V0, V0, 1148
9D00B7B8  00621021   ADDU V0, V1, V0
9D00B7BC  00402021   ADDU A0, V0, ZERO
9D00B7C0  3C029D01   LUI V0, -25343
9D00B7C4  2445E4E0   ADDIU A1, V0, -6944
9D00B7C8  24060003   ADDIU A2, ZERO, 3
9D00B7CC  0F403592   JAL 0x9D00D648
9D00B7D0  00000000   NOP
96:                  
97:                  	// make sure we have not overrun the menu string buffer
98:                  	if (strlen(szDisplayStr) > DISPLAY_STR_SIZE)
9D00B7D4  3C02A000   LUI V0, -24576
9D00B7D8  2444047C   ADDIU A0, V0, 1148
9D00B7DC  0F4035EC   JAL 0x9D00D7B0
9D00B7E0  00000000   NOP
9D00B7E4  2C4200F2   SLTIU V0, V0, 242
9D00B7E8  14400007   BNE V0, ZERO, 0x9D00B808
9D00B7EC  00000000   NOP
99:                  		{
100:                 		szDisplayStr[DISPLAY_STR_SIZE] = '\0';
9D00B7F0  3C02A000   LUI V0, -24576
9D00B7F4  2442047C   ADDIU V0, V0, 1148
9D00B7F8  A04000F1   SB ZERO, 241(V0)
101:                 		RuntimeError(SER_DISPLAY_ERROR_BUFFER_OVERFLOW);
9D00B7FC  240400B5   ADDIU A0, ZERO, 181
9D00B800  0F40365E   JAL _RuntimeError
9D00B804  00000000   NOP
102:                 		}
103:                 	}
9D00B808  03C0E821   ADDU SP, S8, ZERO
9D00B80C  8FBF0014   LW RA, 20(SP)
9D00B810  8FBE0010   LW S8, 16(SP)
9D00B814  27BD0018   ADDIU SP, SP, 24
9D00B818  03E00008   JR RA
9D00B81C  00000000   NOP
104:                 
105:                 
106:                 void AddDisplayTab(void)
107:                 	{
9D00B820  27BDFFE8   ADDIU SP, SP, -24
9D00B824  AFBF0014   SW RA, 20(SP)
9D00B828  AFBE0010   SW S8, 16(SP)
9D00B82C  03A0F021   ADDU S8, SP, ZERO
108:                 	AddDisplayStr("\t");
9D00B830  3C029D01   LUI V0, -25343
9D00B834  2444E4E4   ADDIU A0, V0, -6940
9D00B838  0F402DC0   JAL AddDisplayStr
9D00B83C  00000000   NOP
109:                 	}
9D00B840  03C0E821   ADDU SP, S8, ZERO
9D00B844  8FBF0014   LW RA, 20(SP)
9D00B848  8FBE0010   LW S8, 16(SP)
9D00B84C  27BD0018   ADDIU SP, SP, 24
9D00B850  03E00008   JR RA
9D00B854  00000000   NOP
110:                 
111:                 void AddDisplaySpace(void)
112:                 	{
9D00B858  27BDFFE8   ADDIU SP, SP, -24
9D00B85C  AFBF0014   SW RA, 20(SP)
9D00B860  AFBE0010   SW S8, 16(SP)
9D00B864  03A0F021   ADDU S8, SP, ZERO
113:                 	AddDisplayStr(" ");
9D00B868  3C029D01   LUI V0, -25343
9D00B86C  2444E4E8   ADDIU A0, V0, -6936
9D00B870  0F402DC0   JAL AddDisplayStr
9D00B874  00000000   NOP
114:                 	}
9D00B878  03C0E821   ADDU SP, S8, ZERO
9D00B87C  8FBF0014   LW RA, 20(SP)
9D00B880  8FBE0010   LW S8, 16(SP)
9D00B884  27BD0018   ADDIU SP, SP, 24
9D00B888  03E00008   JR RA
9D00B88C  00000000   NOP
115:                 
116:                 void AddDisplayNewLine(void)
117:                 	{
9D00B890  27BDFFE8   ADDIU SP, SP, -24
9D00B894  AFBF0014   SW RA, 20(SP)
9D00B898  AFBE0010   SW S8, 16(SP)
9D00B89C  03A0F021   ADDU S8, SP, ZERO
118:                 	AddDisplayStr(strNewLine);
9D00B8A0  8F82803C   LW V0, -32708(GP)
9D00B8A4  00402021   ADDU A0, V0, ZERO
9D00B8A8  0F402DC0   JAL AddDisplayStr
9D00B8AC  00000000   NOP
119:                 	}
9D00B8B0  03C0E821   ADDU SP, S8, ZERO
9D00B8B4  8FBF0014   LW RA, 20(SP)
9D00B8B8  8FBE0010   LW S8, 16(SP)
9D00B8BC  27BD0018   ADDIU SP, SP, 24
9D00B8C0  03E00008   JR RA
9D00B8C4  00000000   NOP
120:                 
121:                 
122:                 void DisplayStr(UART_MODULE UARTid)
123:                 	{
9D00B8C8  27BDFFE8   ADDIU SP, SP, -24
9D00B8CC  AFBF0014   SW RA, 20(SP)
9D00B8D0  AFBE0010   SW S8, 16(SP)
9D00B8D4  03A0F021   ADDU S8, SP, ZERO
9D00B8D8  AFC40018   SW A0, 24(S8)
124:                 	StartTransmitString(UARTid, szDisplayStr);
9D00B8DC  8FC40018   LW A0, 24(S8)
9D00B8E0  3C02A000   LUI V0, -24576
9D00B8E4  2445047C   ADDIU A1, V0, 1148
9D00B8E8  0F4023C8   JAL StartTransmitString
9D00B8EC  00000000   NOP
125:                 	}
9D00B8F0  03C0E821   ADDU SP, S8, ZERO
9D00B8F4  8FBF0014   LW RA, 20(SP)
9D00B8F8  8FBE0010   LW S8, 16(SP)
9D00B8FC  27BD0018   ADDIU SP, SP, 24
9D00B900  03E00008   JR RA
9D00B904  00000000   NOP
126:                 
127:                 //*************************************
128:                 //	Placekeeper	string handler
129:                 //*************************************
130:                 
131:                 // Displays a string with a changing placekeeper character at the end
132:                 
133:                 // this is setup as an array of pointers
134:                 FILE_GLOBAL ARRAY const char *pstrSequenceText[] =
135:                 	{
136:                 	"|",
137:                 	"/",
138:                 	"-",
139:                 	"\\",
140:                 	"*",
141:                 	""
142:                 	};
143:                 
144:                 #define MAX_SEQ_INDEX		4
145:                 BYTE nSeqIndex = 0;
146:                 
147:                 void DisplayStrSequence(UART_MODULE UARTid, char *pStr)
148:                 	{
9D00B908  27BDFFE8   ADDIU SP, SP, -24
9D00B90C  AFBF0014   SW RA, 20(SP)
9D00B910  AFBE0010   SW S8, 16(SP)
9D00B914  03A0F021   ADDU S8, SP, ZERO
9D00B918  AFC40018   SW A0, 24(S8)
9D00B91C  AFC5001C   SW A1, 28(S8)
149:                 	// copy from ROM string to RAM buffer
150:                 	IGNORE_RETURN_VALUE strcpy(szDisplayStr, pStr);							// copy ROM text to output buffer
9D00B920  3C02A000   LUI V0, -24576
9D00B924  2444047C   ADDIU A0, V0, 1148
9D00B928  8FC5001C   LW A1, 28(S8)
9D00B92C  0F40352A   JAL 0x9D00D4A8
9D00B930  00000000   NOP
151:                 	IGNORE_RETURN_VALUE strcat(szDisplayStr, pstrSequenceText[nSeqIndex]);	// add sequence character
9D00B934  938280FC   LBU V0, -32516(GP)
9D00B938  00401821   ADDU V1, V0, ZERO
9D00B93C  3C02A000   LUI V0, -24576
9D00B940  00031880   SLL V1, V1, 2
9D00B944  244208DC   ADDIU V0, V0, 2268
9D00B948  00621021   ADDU V0, V1, V0
9D00B94C  8C420000   LW V0, 0(V0)
9D00B950  3C03A000   LUI V1, -24576
9D00B954  2464047C   ADDIU A0, V1, 1148
9D00B958  00402821   ADDU A1, V0, ZERO
9D00B95C  0F4038FB   JAL strcat
9D00B960  00000000   NOP
152:                 	++nSeqIndex;						// bump sequence index
9D00B964  938280FC   LBU V0, -32516(GP)
9D00B968  24420001   ADDIU V0, V0, 1
9D00B96C  304200FF   ANDI V0, V0, 255
9D00B970  A38280FC   SB V0, -32516(GP)
153:                 	if (nSeqIndex > MAX_SEQ_INDEX)		// bounds check
9D00B974  938280FC   LBU V0, -32516(GP)
9D00B978  2C420005   SLTIU V0, V0, 5
9D00B97C  14400002   BNE V0, ZERO, 0x9D00B988
9D00B980  00000000   NOP
154:                 		nSeqIndex = 0;					// restart sequence
9D00B984  A38080FC   SB ZERO, -32516(GP)
155:                 
156:                 	IGNORE_RETURN_VALUE strcat(szDisplayStr, "\r");							// add line terminator
9D00B988  3C02A000   LUI V0, -24576
9D00B98C  2444047C   ADDIU A0, V0, 1148
9D00B990  0F4035EC   JAL 0x9D00D7B0
9D00B994  00000000   NOP
9D00B998  00401821   ADDU V1, V0, ZERO
9D00B99C  3C02A000   LUI V0, -24576
9D00B9A0  2442047C   ADDIU V0, V0, 1148
9D00B9A4  00621021   ADDU V0, V1, V0
9D00B9A8  00402021   ADDU A0, V0, ZERO
9D00B9AC  3C029D01   LUI V0, -25343
9D00B9B0  2445E504   ADDIU A1, V0, -6908
9D00B9B4  24060002   ADDIU A2, ZERO, 2
9D00B9B8  0F403592   JAL 0x9D00D648
9D00B9BC  00000000   NOP
157:                 
158:                 	// make sure we have not overrun the menu string buffer
159:                 	if (strlen(szDisplayStr) > DISPLAY_STR_SIZE)
9D00B9C0  3C02A000   LUI V0, -24576
9D00B9C4  2444047C   ADDIU A0, V0, 1148
9D00B9C8  0F4035EC   JAL 0x9D00D7B0
9D00B9CC  00000000   NOP
9D00B9D0  2C4200F2   SLTIU V0, V0, 242
9D00B9D4  14400007   BNE V0, ZERO, 0x9D00B9F4
9D00B9D8  00000000   NOP
160:                 		{
161:                 		szDisplayStr[DISPLAY_STR_SIZE] = '\0';
9D00B9DC  3C02A000   LUI V0, -24576
9D00B9E0  2442047C   ADDIU V0, V0, 1148
9D00B9E4  A04000F1   SB ZERO, 241(V0)
162:                 		RuntimeError(SER_DISPLAY_ERROR_BUFFER_OVERFLOW);
9D00B9E8  240400B5   ADDIU A0, ZERO, 181
9D00B9EC  0F40365E   JAL _RuntimeError
9D00B9F0  00000000   NOP
163:                 		}
164:                 
165:                 	StartTransmitString(UARTid, szDisplayStr);
9D00B9F4  8FC40018   LW A0, 24(S8)
9D00B9F8  3C02A000   LUI V0, -24576
9D00B9FC  2445047C   ADDIU A1, V0, 1148
9D00BA00  0F4023C8   JAL StartTransmitString
9D00BA04  00000000   NOP
166:                 	}
9D00BA08  03C0E821   ADDU SP, S8, ZERO
9D00BA0C  8FBF0014   LW RA, 20(SP)
9D00BA10  8FBE0010   LW S8, 16(SP)
9D00BA14  27BD0018   ADDIU SP, SP, 24
9D00BA18  03E00008   JR RA
9D00BA1C  00000000   NOP
167:                 
168:                 
169:                 //*************************************************************************************************
170:                 
171:                 //*************************************************************************************************
172:                 
173:                 //*********************************************************
174:                 //			General Message Display
175:                 //*********************************************************
176:                 
177:                 // currently used in MenuFSM() ONLY for error messages
178:                 
179:                 void DisplayMessage(UART_MODULE UARTid, const char *pStr, enum tagWaitForDisplay eWaitForDisplay)
180:                 	{
9D00BA20  27BDFFE8   ADDIU SP, SP, -24
9D00BA24  AFBF0014   SW RA, 20(SP)
9D00BA28  AFBE0010   SW S8, 16(SP)
9D00BA2C  03A0F021   ADDU S8, SP, ZERO
9D00BA30  AFC40018   SW A0, 24(S8)
9D00BA34  AFC5001C   SW A1, 28(S8)
9D00BA38  AFC60020   SW A2, 32(S8)
181:                 	if (eSerialOutputMode IS_NOT SER_MODE_MENU)
9D00BA3C  8F838070   LW V1, -32656(GP)
9D00BA40  24020001   ADDIU V0, ZERO, 1
9D00BA44  14620019   BNE V1, V0, 0x9D00BAAC
9D00BA48  00000000   NOP
182:                 		return;
9D00BAAC  00000000   NOP
183:                 
184:                 	ClearDisplayStr();
9D00BA4C  0F402DB6   JAL ClearDisplayStr
9D00BA50  00000000   NOP
185:                 	AddDisplayStr(pStr);
9D00BA54  8FC4001C   LW A0, 28(S8)
9D00BA58  0F402DC0   JAL AddDisplayStr
9D00BA5C  00000000   NOP
186:                 	AddDisplayNewLine();
9D00BA60  0F402E24   JAL AddDisplayNewLine
9D00BA64  00000000   NOP
187:                 	DisplayStr(UARTid);
9D00BA68  8FC40018   LW A0, 24(S8)
9D00BA6C  0F402E32   JAL DisplayStr
9D00BA70  00000000   NOP
188:                 
189:                 	if (eWaitForDisplay IS WAIT_FOR_DISPLAY)
9D00BA74  8FC30020   LW V1, 32(S8)
9D00BA78  24020001   ADDIU V0, ZERO, 1
9D00BA7C  1462000C   BNE V1, V0, 0x9D00BAB0
9D00BA80  00000000   NOP
190:                 		{
191:                 		// this is a BLOCKING display sequence
192:                 
193:                 		// wait for serial TX to finish
194:                 		while(IsDisplayDone(UARTid) IS bNO)
9D00BA84  00000000   NOP
9D00BA88  8FC40018   LW A0, 24(S8)
9D00BA8C  0F402EDF   JAL IsDisplayDone
9D00BA90  00000000   NOP
9D00BA94  1040FFFC   BEQ V0, ZERO, 0x9D00BA88
9D00BA98  00000000   NOP
195:                 			BLOCKING_WAIT_FOR_HARDWARE;
196:                 
197:                 		// clear the display string buffer for subsequent usage
198:                 		ClearDisplayStr();
9D00BA9C  0F402DB6   JAL ClearDisplayStr
9D00BAA0  00000000   NOP
9D00BAA4  0B402EAC   J 0x9D00BAB0
9D00BAA8  00000000   NOP
199:                 		}
200:                 	}
9D00BAB0  03C0E821   ADDU SP, S8, ZERO
9D00BAB4  8FBF0014   LW RA, 20(SP)
9D00BAB8  8FBE0010   LW S8, 16(SP)
9D00BABC  27BD0018   ADDIU SP, SP, 24
9D00BAC0  03E00008   JR RA
9D00BAC4  00000000   NOP
201:                 
202:                 //*********************************************************
203:                 //			Single Character Display (Echo)
204:                 //*********************************************************
205:                 
206:                 // this is used for echoing parameter entry characters
207:                 
208:                 void DisplayCharacter(UART_MODULE UARTid, const char cChar, enum tagWaitForDisplay eWaitForDisplay)
209:                 	{
9D00BAC8  27BDFFE0   ADDIU SP, SP, -32
9D00BACC  AFBF001C   SW RA, 28(SP)
9D00BAD0  AFBE0018   SW S8, 24(SP)
9D00BAD4  03A0F021   ADDU S8, SP, ZERO
9D00BAD8  AFC40020   SW A0, 32(S8)
9D00BADC  00A01021   ADDU V0, A1, ZERO
9D00BAE0  AFC60028   SW A2, 40(S8)
9D00BAE4  A3C20024   SB V0, 36(S8)
210:                 	LOCAL ARRAY char strEchoChar[2];	// string for echoing parameter characters, one at a time
211:                 
212:                 	if (eSerialOutputMode IS_NOT SER_MODE_MENU)			// only used for Serial Menu
9D00BAE8  8F838070   LW V1, -32656(GP)
9D00BAEC  24020001   ADDIU V0, ZERO, 1
9D00BAF0  1462001B   BNE V1, V0, 0x9D00BB60
9D00BAF4  00000000   NOP
213:                 		return;
9D00BB60  00000000   NOP
214:                 
215:                 	ClearDisplayStr();							// initialize output buffer
9D00BAF8  0F402DB6   JAL ClearDisplayStr
9D00BAFC  00000000   NOP
216:                 
217:                 	strEchoChar[0] = cChar;						// copy single character to output buffer
9D00BB00  93C20024   LBU V0, 36(S8)
9D00BB04  A3C20010   SB V0, 16(S8)
218:                 	strEchoChar[1] = SZ_TERM;					// terminate the buffer; all serial output is based on terminated strings
9D00BB08  A3C00011   SB ZERO, 17(S8)
219:                 
220:                 	AddDisplayStr(strEchoChar);					// copy string (just one character!) to output buffer
9D00BB0C  27C20010   ADDIU V0, S8, 16
9D00BB10  00402021   ADDU A0, V0, ZERO
9D00BB14  0F402DC0   JAL AddDisplayStr
9D00BB18  00000000   NOP
221:                 	DisplayStr(UARTid);
9D00BB1C  8FC40020   LW A0, 32(S8)
9D00BB20  0F402E32   JAL DisplayStr
9D00BB24  00000000   NOP
222:                 
223:                 	if (eWaitForDisplay IS WAIT_FOR_DISPLAY)
9D00BB28  8FC30028   LW V1, 40(S8)
9D00BB2C  24020001   ADDIU V0, ZERO, 1
9D00BB30  1462000C   BNE V1, V0, 0x9D00BB64
9D00BB34  00000000   NOP
224:                 		{
225:                 		// this is a BLOCKING display sequence
226:                 
227:                 		// wait for serial TX to finish
228:                 		while( IsDisplayDone(UARTid) IS bNO)
9D00BB38  00000000   NOP
9D00BB3C  8FC40020   LW A0, 32(S8)
9D00BB40  0F402EDF   JAL IsDisplayDone
9D00BB44  00000000   NOP
9D00BB48  1040FFFC   BEQ V0, ZERO, 0x9D00BB3C
9D00BB4C  00000000   NOP
229:                 			BLOCKING_WAIT_FOR_HARDWARE;
230:                 
231:                 		// clear the display string buffer for subsequent usage
232:                 		ClearDisplayStr();
9D00BB50  0F402DB6   JAL ClearDisplayStr
9D00BB54  00000000   NOP
9D00BB58  0B402ED9   J 0x9D00BB64
9D00BB5C  00000000   NOP
233:                 		}
234:                 	}
9D00BB64  03C0E821   ADDU SP, S8, ZERO
9D00BB68  8FBF001C   LW RA, 28(SP)
9D00BB6C  8FBE0018   LW S8, 24(SP)
9D00BB70  27BD0020   ADDIU SP, SP, 32
9D00BB74  03E00008   JR RA
9D00BB78  00000000   NOP
235:                 
236:                 
237:                 //*********************************************************
238:                 //			Check for Display Complete
239:                 //*********************************************************
240:                 
241:                 BOOL IsDisplayDone(UART_MODULE UARTid)
242:                 {
9D00BB7C  27BDFFE8   ADDIU SP, SP, -24
9D00BB80  AFBF0014   SW RA, 20(SP)
9D00BB84  AFBE0010   SW S8, 16(SP)
9D00BB88  03A0F021   ADDU S8, SP, ZERO
9D00BB8C  AFC40018   SW A0, 24(S8)
243:                 	if (eSerialOutputMode IS_NOT SER_MODE_MENU)			// only used for Serial Menu
9D00BB90  8F838070   LW V1, -32656(GP)
9D00BB94  24020001   ADDIU V0, ZERO, 1
9D00BB98  10620004   BEQ V1, V0, 0x9D00BBAC
9D00BB9C  00000000   NOP
244:                 		return TRUE;
9D00BBA0  24020001   ADDIU V0, ZERO, 1
9D00BBA4  0B402EF6   J 0x9D00BBD8
9D00BBA8  00000000   NOP
245:                 
246:                 	// wait for serial TX to finish
247:                 	if (IsSerialTxComplete(UARTid) IS bNO)
9D00BBAC  8FC40018   LW A0, 24(S8)
9D00BBB0  0F402390   JAL IsTransmitComplete
9D00BBB4  00000000   NOP
9D00BBB8  14400004   BNE V0, ZERO, 0x9D00BBCC
9D00BBBC  00000000   NOP
248:                 		return FALSE;
9D00BBC0  00001021   ADDU V0, ZERO, ZERO
9D00BBC4  0B402EF6   J 0x9D00BBD8
9D00BBC8  00000000   NOP
249:                 
250:                 	// display must be complete
251:                 	// clear the display string buffer for subsequent usage
252:                 	ClearDisplayStr();
9D00BBCC  0F402DB6   JAL ClearDisplayStr
9D00BBD0  00000000   NOP
253:                 	return TRUE;
9D00BBD4  24020001   ADDIU V0, ZERO, 1
254:                 }
9D00BBD8  03C0E821   ADDU SP, S8, ZERO
9D00BBDC  8FBF0014   LW RA, 20(SP)
9D00BBE0  8FBE0010   LW S8, 16(SP)
9D00BBE4  27BD0018   ADDIU SP, SP, 24
9D00BBE8  03E00008   JR RA
9D00BBEC  00000000   NOP
255:                 
256:                 
257:                 
258:                 //*************************************************************************************************
259:                 //								RealTime Message Display Functions
260:                 //*************************************************************************************************
261:                 
262:                 //*********************************************************
263:                 //			RealTime Message Display
264:                 //*********************************************************
265:                 
266:                 // this function is used only for real-time display of packets and error messages
267:                 
268:                 void RealTimeDisplayMessage(UART_MODULE UARTid, const char *pStr)
269:                 {
9D00BBF0  27BDFFE8   ADDIU SP, SP, -24
9D00BBF4  AFBF0014   SW RA, 20(SP)
9D00BBF8  AFBE0010   SW S8, 16(SP)
9D00BBFC  03A0F021   ADDU S8, SP, ZERO
9D00BC00  AFC40018   SW A0, 24(S8)
9D00BC04  AFC5001C   SW A1, 28(S8)
270:                 
271:                 	// if RealTime display is not enabled, just return without doing anything
272:                 //	if (bRealTimeDisplay IS FALSE)
273:                 	if (eSerialOutputMode IS_NOT SER_MODE_REALTIME)
9D00BC08  8F838070   LW V1, -32656(GP)
9D00BC0C  24020002   ADDIU V0, ZERO, 2
9D00BC10  14620008   BNE V1, V0, 0x9D00BC34
9D00BC14  00000000   NOP
274:                 		return;
9D00BC34  00000000   NOP
275:                 
276:                 
277:                 	// RealTime display is enabled, so display the message and do NOT wait for it to complete
278:                 	DisplayMessage(UARTid, pStr, NO_WAIT_FOR_DISPLAY);
9D00BC18  8FC40018   LW A0, 24(S8)
9D00BC1C  8FC5001C   LW A1, 28(S8)
9D00BC20  00003021   ADDU A2, ZERO, ZERO
9D00BC24  0F402E88   JAL DisplayMessage
9D00BC28  00000000   NOP
9D00BC2C  0B402F0E   J 0x9D00BC38
9D00BC30  00000000   NOP
279:                 
280:                 }
9D00BC38  03C0E821   ADDU SP, S8, ZERO
9D00BC3C  8FBF0014   LW RA, 20(SP)
9D00BC40  8FBE0010   LW S8, 16(SP)
9D00BC44  27BD0018   ADDIU SP, SP, 24
9D00BC48  03E00008   JR RA
9D00BC4C  00000000   NOP
281:                 
282:                 
283:                 //*********************************************************
284:                 //			RealTime Constructed String Display
285:                 //*********************************************************
286:                 
287:                 // this function is used only for real-time display of status and error messages
288:                 // NOTE: this function makes use of the global fgszDisplayStr,
289:                 // so the caller must be sure NOT to modify the string until the display is complete
290:                 
291:                 void RealTimeDisplayStr(UART_MODULE UARTid)
292:                 {
9D00BC50  27BDFFE8   ADDIU SP, SP, -24
9D00BC54  AFBF0014   SW RA, 20(SP)
9D00BC58  AFBE0010   SW S8, 16(SP)
9D00BC5C  03A0F021   ADDU S8, SP, ZERO
9D00BC60  AFC40018   SW A0, 24(S8)
293:                 
294:                 	// if RealTime display is not enabled, just return without doing anything
295:                 //	if (bRealTimeDisplay IS FALSE)
296:                 	if (eSerialOutputMode IS_NOT SER_MODE_REALTIME)
9D00BC64  8F838070   LW V1, -32656(GP)
9D00BC68  24020002   ADDIU V0, ZERO, 2
9D00BC6C  14620006   BNE V1, V0, 0x9D00BC88
9D00BC70  00000000   NOP
297:                 		return;
9D00BC88  00000000   NOP
298:                 
299:                 
300:                 	// RealTime display is enabled, so display the contents of fgszDisplayStr and do NOT wait for it to complete
301:                 	DisplayStr(UARTid);
9D00BC74  8FC40018   LW A0, 24(S8)
9D00BC78  0F402E32   JAL DisplayStr
9D00BC7C  00000000   NOP
9D00BC80  0B402F23   J 0x9D00BC8C
9D00BC84  00000000   NOP
302:                 
303:                 }
9D00BC8C  03C0E821   ADDU SP, S8, ZERO
9D00BC90  8FBF0014   LW RA, 20(SP)
9D00BC94  8FBE0010   LW S8, 16(SP)
9D00BC98  27BD0018   ADDIU SP, SP, 24
9D00BC9C  03E00008   JR RA
9D00BCA0  00000000   NOP
304:                 
305:                 
306:                 //*********************************************************
307:                 //			Check for Display Complete
308:                 //*********************************************************
309:                 
310:                 BOOL IsRealTimeDisplayDone(UART_MODULE UARTid)
311:                 {
9D00BCA4  27BDFFE8   ADDIU SP, SP, -24
9D00BCA8  AFBF0014   SW RA, 20(SP)
9D00BCAC  AFBE0010   SW S8, 16(SP)
9D00BCB0  03A0F021   ADDU S8, SP, ZERO
9D00BCB4  AFC40018   SW A0, 24(S8)
312:                 
313:                 	// if RealTime display is not enabled, just return without doing anything
314:                 	// Fake TRUE return because display will not even occur
315:                 //	if (bRealTimeDisplay IS FALSE)
316:                 	if (eSerialOutputMode IS_NOT SER_MODE_REALTIME)
9D00BCB8  8F838070   LW V1, -32656(GP)
9D00BCBC  24020002   ADDIU V0, ZERO, 2
9D00BCC0  10620004   BEQ V1, V0, 0x9D00BCD4
9D00BCC4  00000000   NOP
317:                 		return TRUE;
9D00BCC8  24020001   ADDIU V0, ZERO, 1
9D00BCCC  0B402F40   J 0x9D00BD00
9D00BCD0  00000000   NOP
318:                 
319:                 	// RealTime display is enabled
320:                 
321:                 	// wait for serial TX to finish
322:                 	if (IsSerialTxComplete(UARTid) IS bNO)
9D00BCD4  8FC40018   LW A0, 24(S8)
9D00BCD8  0F402390   JAL IsTransmitComplete
9D00BCDC  00000000   NOP
9D00BCE0  14400004   BNE V0, ZERO, 0x9D00BCF4
9D00BCE4  00000000   NOP
323:                 		return FALSE;
9D00BCE8  00001021   ADDU V0, ZERO, ZERO
9D00BCEC  0B402F40   J 0x9D00BD00
9D00BCF0  00000000   NOP
324:                 
325:                 	// display must be complete
326:                 	// clear the display string buffer for subsequent usage
327:                 	ClearDisplayStr();
9D00BCF4  0F402DB6   JAL ClearDisplayStr
9D00BCF8  00000000   NOP
328:                 
329:                 	return TRUE;
9D00BCFC  24020001   ADDIU V0, ZERO, 1
330:                 }
9D00BD00  03C0E821   ADDU SP, S8, ZERO
9D00BD04  8FBF0014   LW RA, 20(SP)
9D00BD08  8FBE0010   LW S8, 16(SP)
9D00BD0C  27BD0018   ADDIU SP, SP, 24
9D00BD10  03E00008   JR RA
9D00BD14  00000000   NOP
331:                 
332:                 
333:                 // end of DisplayString.c
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/MotorPWM.c  ----------------------
1:                   //*************************************************************************************************
2:                   //										M o t o r P W M . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Motor PWM Init, Control
8:                   //
9:                   //		001	05 Mar 13 <sek> created from gsf Code Base
10:                  //		002	07 Mar 13 <sek> pgwPWMDutyCycle, PWM_SetDutyCycle() returns BOOL
11:                  //		003	09 Mar 13 <sek> handle two motors
12:                  //		004	11 Mar 13 <sek> initialze Pololu dual MC33926 board
13:                  //		005	16 Mar 13 <sek> changed HEI (hall effect int) to MSI (motion sensor int)
14:                  //		006	18 Mar 13 <sek> PWM_SetConfig() enables or disables motion sensor interrupts
15:                  //
16:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
17:                  //					gsf Engineering	978-927-7189
18:                  //					Beverly, MA 01915
19:                  //
20:                  //		copyright (c) 2013 gsf Engineering (Beverly, MA USA) for SmartTrak Solar Systems Pvt, Hyderabad, AP, India
21:                  //
22:                  //*************************************************************************************************
23:                  
24:                  #include <GenericTypeDefs.h>
25:                  
26:                  //lint -e765					error 765: (Info -- external function could be made static)
27:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
28:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
29:                  //lint +e14
30:                  
31:                  #include <string.h>				// Microchip string functions
32:                  								// see hlpC18.chm online help for so-called documentation
33:                  #include <ctype.h>				// tolower()
34:                  
35:                  #include "gsfstd.h"				// gsf standard #defines
36:                  //#include "init.h"				// port definitions and initialization state
37:                  #include "Debug.h"
38:                  #include "SmartTrak.h"			// Project wide definitions
39:                  #include "HardwareProfile.h"
40:                  
41:                  #include "EventFlags.h"			// event flag definitions and globals
42:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
43:                  //#include "ADCRead.h"			// adc access functions
44:                  #include "MotorPWM.h"			// Motor PWM function prototypes and definitions
45:                  #include "MotionFSM.h"			// Motion Control function prototypes and definitions
46:                  #include "MotionStats.h"		// Motion Control statistics for debugging and analysis
47:                  #include "Encoder.h"			// Hall Effect Quadrature Encoder function prototypes and definitions
48:                  
49:                  #include "Stubs.h"
50:                  
51:                  #ifdef DEFINE_GLOBALS
52:                  	#error "DEFINE_GLOBALS not expected here"
53:                  #endif
54:                  
55:                  //-------------------------------------------------------------------------------------------------------
56:                  // Definitions
57:                  //-------------------------------------------------------------------------------------------------------
58:                  
59:                  enum tagPWMErrors
60:                  {
61:                  	PWM_ERROR_NONE = PWM_ERROR_BASE,
62:                  	PWM_ERROR_UNEXPECTED_TICK,			// 1 unexpected timer tick event
63:                  	PWM_ERROR_UNEXPECTED_EVENT,			// 2 unexpected event
64:                  	PWM_ERROR_INVALID_STATE,			// 3 not a valid state
65:                  	PWM_ERROR_INVALID_SUBSTATE,			// 4 not a valid state
66:                  	PWM_ERROR_INVALID_CHANNEL,			// 5 not a valid channel number
67:                  	PWM_ERROR_INVALID_DIRECTION,		// 6 not a valid direction
68:                  	PWM_ERROR_INVALID_DUTY_CYCLE_HIGH,	// 7 not a valid duty cycle
69:                  	PWM_ERROR_INVALID_DUTY_CYCLE_LOW,	// 8 not a valid duty cycle
70:                  	PWM_ERROR_CONFIG_DIR_MISMATCH,		// 9 current config and requested direction do not match
71:                  	PWM_ERROR_INVALID_CONFIGURATION_CHANGE,	// A change from current to new configuration is not allowed
72:                  
73:                  	PWM_FSM_UNPROCESSED_EVENT = PWM_ERROR_BASE + 0x0F
74:                  };
75:                  
76:                  //----------------------------------------------------------------------
77:                  // System variables
78:                  //----------------------------------------------------------------------
79:                  
80:                  //----------------------------------------------------------------------
81:                  // System functions
82:                  //----------------------------------------------------------------------
83:                  
84:                  //----------------------------------------------------------------------
85:                  // Code functions
86:                  //----------------------------------------------------------------------
87:                  
88:                  //*************************************************************************************************
89:                  //									P W M _ I n i t ( )
90:                  //*************************************************************************************************
91:                  
92:                  // Useful Reference Material:
93:                  //
94:                  //		PIC32 Family Reference Manual, Section 16. Output Compare
95:                  //			version DS61111E, 16.3.3 Pulse Width Modulation Mode, page 16-26
96:                  //			version DS61111D, 16.3.3 Pulse Width Modulation Mode, page 16-54
97:                  //
98:                  //			NOTE: version D is older, but has much more useful information on the RELATED registers, such as timers
99:                  //			NOTE: the PIC32MX Family Reference Manual documents are much older, dating from 2008
100:                 
101:                 //	The following registers control the operation of the OC module:
102:                 
103:                 
104:                 
105:                 // According to the PIC32 Family Reference Manual, Section 16. Output Compare 16.3.3 Pulse Width Modulation Mode, page 16-54,
106:                 // the required operations to setup  the Output Compare module for PWM operation:
107:                 //	1. Set the PWM period by writing to the selected timer period register (PRy).
108:                 //	2. Set the PWM duty cycle by writing to the OCxRS register.
109:                 //	3. Write the OxCR register with the initial duty cycle.
110:                 //	4. Enable interrupts, if required, for the timer and Output Compare modules. The output
111:                 //			compare interrupt is required for PWM Fault pin utilization.
112:                 //	5. Configure the Output Compare module for oneof two PWM Operation modes by writing
113:                 //			to the Output Compare mode bits, OCM<2:0> (OCxCON<2:0>).
114:                 //	6. Set the TMRy prescale value and enable the time base by setting TON (TxCON<15>) = 1
115:                 
116:                 //	Note:
117:                 //		The OCxR register should be initialized before the Output Compare module is first 
118:                 //		enabled. The OCxR register becomes a read-only duty cycle register when the 
119:                 //		module is operated in the PWM modes. The value held in OCxR will become the 
120:                 //		PWM duty cycle for the first PWM period. The contents of the duty cycle buffer 
121:                 //		register, OCxRS, will not be transferred into OCxR until a time base period match occurs
122:                 
123:                 void PWM_Init(enum tagMotors eMotor)
124:                 {
9D00944C  27BDFFE8   ADDIU SP, SP, -24
9D009450  AFBF0014   SW RA, 20(SP)
9D009454  AFBE0010   SW S8, 16(SP)
9D009458  03A0F021   ADDU S8, SP, ZERO
9D00945C  AFC40018   SW A0, 24(S8)
125:                 
126:                 	InitMotorDrive();				// initializes pins associated with motor drives, but does NOT enable the driver
127:                 
128:                 	// initialize and enable the PWM for all 4 outputs (two per motor)
129:                 	// BUT	set the compare values to 0
130:                 	//		set the duty cycle to 0 (redundantly sets compare values to 0)
131:                 	//		set the configuration to STOPPED
132:                 
133:                 	// this may NOT be the optimal way to do this, but it DOES appear to work
134:                 	// perhaps we should be enabling and disabling the PWM, so only the active one are enabled?
135:                 
136:                 	if (eMotor IS MOTOR_AZIMUTH)
9D009480  8FC20018   LW V0, 24(S8)
9D009484  1440001B   BNE V0, ZERO, 0x9D0094F4
9D009488  00000000   NOP
137:                 	{
138:                 		// why did the sample code used for this include OC_LOW_HIGH?
139:                 		//      <<----------------------------OC1CON--------------------->>  OC1RS      OC1R
140:                 		/*     | 16 bit Mode    | Timer2 source |   PWM w/o Fault Input   , S Compare value, Compare value*/
141:                 		OpenOC1(OC_TIMER_MODE16 | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE,  0x0000, 0x0000);
9D00948C  3C02BF80   LUI V0, -16512
9D009490  AC403020   SW ZERO, 12320(V0)
9D009494  3C02BF80   LUI V0, -16512
9D009498  AC403010   SW ZERO, 12304(V0)
9D00949C  3C02BF80   LUI V0, -16512
9D0094A0  24030006   ADDIU V1, ZERO, 6
9D0094A4  AC433000   SW V1, 12288(V0)
142:                 		OC1CON |= (OC_ON);					// enable output compare 1
9D0094A8  3C02BF80   LUI V0, -16512
9D0094AC  8C423000   LW V0, 12288(V0)
9D0094B0  34438000   ORI V1, V0, -32768
9D0094B4  3C02BF80   LUI V0, -16512
9D0094B8  AC433000   SW V1, 12288(V0)
143:                 
144:                 		OpenOC2(OC_TIMER_MODE16 | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE,  0x0000, 0x0000);
9D0094BC  3C02BF80   LUI V0, -16512
9D0094C0  AC403220   SW ZERO, 12832(V0)
9D0094C4  3C02BF80   LUI V0, -16512
9D0094C8  AC403210   SW ZERO, 12816(V0)
9D0094CC  3C02BF80   LUI V0, -16512
9D0094D0  24030006   ADDIU V1, ZERO, 6
9D0094D4  AC433200   SW V1, 12800(V0)
145:                 		OC2CON |= (OC_ON);					// enable output compare 2
9D0094D8  3C02BF80   LUI V0, -16512
9D0094DC  8C423200   LW V0, 12800(V0)
9D0094E0  34438000   ORI V1, V0, -32768
9D0094E4  3C02BF80   LUI V0, -16512
9D0094E8  AC433200   SW V1, 12800(V0)
9D0094EC  0B402559   J 0x9D009564
9D0094F0  00000000   NOP
146:                 
147:                 	}
148:                 	else if (eMotor IS MOTOR_ELEVATION)
9D0094F4  8FC30018   LW V1, 24(S8)
9D0094F8  24020001   ADDIU V0, ZERO, 1
9D0094FC  14620019   BNE V1, V0, 0x9D009564
9D009500  00000000   NOP
149:                 	{
150:                 		//      <<----------------------------OC3CON--------------------->>  OC3RS      OC3R
151:                 		/*     | 16 bit Mode    | Timer2 source |   PWM w/o Fault Input   , S Compare value, Compare value*/
152:                 		OpenOC3(OC_TIMER_MODE16 | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE,  0x0000, 0x0000);
9D009504  3C02BF80   LUI V0, -16512
9D009508  AC403420   SW ZERO, 13344(V0)
9D00950C  3C02BF80   LUI V0, -16512
9D009510  AC403410   SW ZERO, 13328(V0)
9D009514  3C02BF80   LUI V0, -16512
9D009518  24030006   ADDIU V1, ZERO, 6
9D00951C  AC433400   SW V1, 13312(V0)
153:                 		OC3CON |= (OC_ON);					// enable output compare 3
9D009520  3C02BF80   LUI V0, -16512
9D009524  8C423400   LW V0, 13312(V0)
9D009528  34438000   ORI V1, V0, -32768
9D00952C  3C02BF80   LUI V0, -16512
9D009530  AC433400   SW V1, 13312(V0)
154:                 
155:                 		OpenOC4(OC_TIMER_MODE16 | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE,  0x0000, 0x0000);
9D009534  3C02BF80   LUI V0, -16512
9D009538  AC403620   SW ZERO, 13856(V0)
9D00953C  3C02BF80   LUI V0, -16512
9D009540  AC403610   SW ZERO, 13840(V0)
9D009544  3C02BF80   LUI V0, -16512
9D009548  24030006   ADDIU V1, ZERO, 6
9D00954C  AC433600   SW V1, 13824(V0)
156:                 		OC4CON |= (OC_ON);					// enable output compare 4
9D009550  3C02BF80   LUI V0, -16512
9D009554  8C423600   LW V0, 13824(V0)
9D009558  34438000   ORI V1, V0, -32768
9D00955C  3C02BF80   LUI V0, -16512
9D009560  AC433600   SW V1, 13824(V0)
157:                 
158:                 	}
159:                 
160:                 	/* Open Timer2 with Period register value */
161:                 	//		   T2CON   PR2			TMR2 = 0
162:                 	OpenTimer2(T2_ON, PWM_PERIOD);
9D009564  3C02BF80   LUI V0, -16512
9D009568  AC400800   SW ZERO, 2048(V0)
9D00956C  3C02BF80   LUI V0, -16512
9D009570  AC400810   SW ZERO, 2064(V0)
9D009574  3C02BF81   LUI V0, -16511
9D009578  8C42F000   LW V0, -4096(V0)
9D00957C  7C420CC0   EXT V0, V0, 19, 2
9D009580  304200FF   ANDI V0, V0, 255
9D009584  3C0304C4   LUI V1, 1220
9D009588  3463B400   ORI V1, V1, -19456
9D00958C  00431806   SRLV V1, V1, V0
9D009590  3C02D1B7   LUI V0, -11849
9D009594  34421759   ORI V0, V0, 5977
9D009598  00620019   MULTU V1, V0
9D00959C  00001012   MFLO V0
9D0095A0  00001810   MFHI V1
9D0095A4  00031B42   SRL V1, V1, 13
9D0095A8  3C02BF80   LUI V0, -16512
9D0095AC  AC430820   SW V1, 2080(V0)
9D0095B0  3C02BF80   LUI V0, -16512
9D0095B4  34038000   ORI V1, ZERO, -32768
9D0095B8  AC430808   SW V1, 2056(V0)
163:                 
164:                 	// see Timer.c:InitializeTimers() for TMR2 and PR2 register initialization
165:                 	// set PWM output duty cycle, specified as a percentage of the PWM period
166:                 	IGNORE_RETURN_VALUE PWM_SetDutyCycle(eMotor, PWM_DUTY_CYCLE_OFF);
9D0095BC  8FC40018   LW A0, 24(S8)
9D0095C0  00002821   ADDU A1, ZERO, ZERO
9D0095C4  0F402671   JAL PWM_SetDutyCycle
9D0095C8  00000000   NOP
167:                 
168:                 	// set Motor Driver configuration 
169:                 	// NOTE: setting PWM to STOPPED requires setting DutyCycle = 0 to force MOTOR_CTRL_PWM1 output LOW
170:                 	PWM_SetConfig(eMotor, PWM_CONFIG_STOPPED);
9D0095CC  8FC40018   LW A0, 24(S8)
9D0095D0  00002821   ADDU A1, ZERO, ZERO
9D0095D4  0F402581   JAL PWM_SetConfig
9D0095D8  00000000   NOP
171:                 
172:                 	EnableMotorDrive();						// enable motor driver ICs (MC33926)
173:                 
174:                 }
9D0095EC  03C0E821   ADDU SP, S8, ZERO
9D0095F0  8FBF0014   LW RA, 20(SP)
9D0095F4  8FBE0010   LW S8, 16(SP)
9D0095F8  27BD0018   ADDIU SP, SP, 24
9D0095FC  03E00008   JR RA
9D009600  00000000   NOP
175:                 
176:                 
177:                 
178:                 //*************************************************************************************************
179:                 //									P W M _ 5 m S T i c k ( )
180:                 //*************************************************************************************************
181:                 
182:                 #ifdef NOTDEF
183:                 	void PWM_5mSecTick(void)
184:                 	{
185:                 
186:                 	}
187:                 #endif
188:                 
189:                 //*************************************************************************************************
190:                 //									P W M   H a n d l e r s
191:                 //*************************************************************************************************
192:                 
193:                 // PWM_SetConfig() is called at most once for each motion phase to setup the PWM drive outputs
194:                 // PWM_CONFIG_FORWARD and PWM_CONFIG_REVERSE initialize the Motion Stats and enable Motion Sensor interrupts
195:                 // PWM_CONFIG_STANDBY disables Motion Sensor interrupts
196:                 
197:                 void PWM_SetConfig(enum tagMotors eMotor, enum tagPWMConfigs ePWMConfig)
198:                 {
9D009604  27BDFFE8   ADDIU SP, SP, -24
9D009608  AFBF0014   SW RA, 20(SP)
9D00960C  AFBE0010   SW S8, 16(SP)
9D009610  03A0F021   ADDU S8, SP, ZERO
9D009614  AFC40018   SW A0, 24(S8)
9D009618  AFC5001C   SW A1, 28(S8)
199:                 	// in ALL cases, we want to DISABLE the PWM until the duty cycle has been set by a call to PWM_SetDutyCycle()
200:                 	// what does the PWM module output do when disabled? Does it turn back into an floating input? NOT APPROPRIATE.
201:                 
202:                 	//???											// disable the PWM timebase to stop the PWM
203:                 
204:                 	// clear the PWM Timer count register, so the next cycle will start at the beginning of a PWM cycle
205:                 	TMR2 = 0x00;
9D00961C  3C02BF80   LUI V0, -16512
9D009620  AC400810   SW ZERO, 2064(V0)
206:                 
207:                 	
208:                 	//*******************************************
209:                 	//		Check for Allowed Transition
210:                 	//*******************************************
211:                 
212:                  	// make sure the requested new configuration is an allowable change from the current configuration
213:                 	switch(pgePWMConfig[eMotor])
9D009624  3C02A000   LUI V0, -24576
9D009628  8FC30018   LW V1, 24(S8)
9D00962C  00031880   SLL V1, V1, 2
9D009630  24420204   ADDIU V0, V0, 516
9D009634  00621021   ADDU V0, V1, V0
9D009638  8C420000   LW V0, 0(V0)
9D00963C  24420001   ADDIU V0, V0, 1
9D009640  2C430006   SLTIU V1, V0, 6
9D009644  10600037   BEQ V1, ZERO, 0x9D009724
9D009648  00000000   NOP
9D00964C  3C03B400   LUI V1, -19456
9D009650  00431804   SLLV V1, V1, V0
9D009654  0460000B   BLTZ V1, 0x9D009684
9D009658  00000000   NOP
9D00965C  3C030800   LUI V1, 2048
9D009660  00431804   SLLV V1, V1, V0
9D009664  04600026   BLTZ V1, 0x9D009700
9D009668  00000000   NOP
9D00966C  3C034000   LUI V1, 16384
9D009670  00431004   SLLV V0, V1, V0
9D009674  0440000C   BLTZ V0, 0x9D0096A8
9D009678  00000000   NOP
9D00967C  0B4025C9   J 0x9D009724
9D009680  00000000   NOP
214:                 		{
215:                 		case PWM_CONFIG_UNKNOWN:					// initial state
216:                 		case PWM_CONFIG_REVERSE:
217:                 		case PWM_CONFIG_FORWARD:
218:                 		case PWM_CONFIG_BRAKE:
219:                 			if (ePWMConfig IS PWM_CONFIG_STOPPED)
9D009684  8FC2001C   LW V0, 28(S8)
9D009688  10400036   BEQ V0, ZERO, 0x9D009764
9D00968C  00000000   NOP
220:                 				{
221:                 				break;
9D009764  00000000   NOP
9D009768  0B4025DD   J 0x9D009774
9D00976C  00000000   NOP
222:                 				}
223:                 			else
224:                 				{
225:                 				// not an allowable change, so FORCE an allowable change
226:                 				ePWMConfig = PWM_CONFIG_STOPPED;
9D009690  AFC0001C   SW ZERO, 28(S8)
227:                 				RuntimeError(PWM_ERROR_INVALID_CONFIGURATION_CHANGE);
9D009694  2404008A   ADDIU A0, ZERO, 138
9D009698  0F40365E   JAL _RuntimeError
9D00969C  00000000   NOP
228:                 				}
229:                 			break;
9D0096A0  0B4025DD   J 0x9D009774
9D0096A4  00000000   NOP
230:                 
231:                 		case PWM_CONFIG_STOPPED:
232:                 			if ((ePWMConfig IS PWM_CONFIG_REVERSE) OR (ePWMConfig IS PWM_CONFIG_FORWARD) OR (ePWMConfig IS PWM_CONFIG_BRAKE) OR (ePWMConfig IS PWM_CONFIG_STANDBY))
9D0096A8  8FC3001C   LW V1, 28(S8)
9D0096AC  2402FFFF   ADDIU V0, ZERO, -1
9D0096B0  10620030   BEQ V1, V0, 0x9D009774
9D0096B4  00000000   NOP
9D0096B8  8FC3001C   LW V1, 28(S8)
9D0096BC  24020001   ADDIU V0, ZERO, 1
9D0096C0  1062002C   BEQ V1, V0, 0x9D009774
9D0096C4  00000000   NOP
9D0096C8  8FC3001C   LW V1, 28(S8)
9D0096CC  24020002   ADDIU V0, ZERO, 2
9D0096D0  10620028   BEQ V1, V0, 0x9D009774
9D0096D4  00000000   NOP
9D0096D8  8FC3001C   LW V1, 28(S8)
9D0096DC  24020003   ADDIU V0, ZERO, 3
9D0096E0  10620024   BEQ V1, V0, 0x9D009774
9D0096E4  00000000   NOP
233:                 				{
234:                 				break;
235:                 				}
236:                 			else
237:                 				{
238:                 				// not an allowable change, so FORCE an allowable change
239:                 				ePWMConfig = PWM_CONFIG_STOPPED;
9D0096E8  AFC0001C   SW ZERO, 28(S8)
240:                 				RuntimeError(PWM_ERROR_INVALID_CONFIGURATION_CHANGE);
9D0096EC  2404008A   ADDIU A0, ZERO, 138
9D0096F0  0F40365E   JAL _RuntimeError
9D0096F4  00000000   NOP
241:                 				}
242:                 			break;
9D0096F8  0B4025DD   J 0x9D009774
9D0096FC  00000000   NOP
243:                 
244:                 		case PWM_CONFIG_STANDBY:
245:                 			if (ePWMConfig IS PWM_CONFIG_STOPPED)
9D009700  8FC2001C   LW V0, 28(S8)
9D009704  1040001A   BEQ V0, ZERO, 0x9D009770
9D009708  00000000   NOP
246:                 				{
247:                 				break;
9D009770  00000000   NOP
248:                 				}
249:                 			else
250:                 				{
251:                 				// not an allowable change, so FORCE an allowable change
252:                 				ePWMConfig = PWM_CONFIG_STOPPED;
9D00970C  AFC0001C   SW ZERO, 28(S8)
253:                 				RuntimeError(PWM_ERROR_INVALID_CONFIGURATION_CHANGE);
9D009710  2404008A   ADDIU A0, ZERO, 138
9D009714  0F40365E   JAL _RuntimeError
9D009718  00000000   NOP
254:                 				}
255:                 			break;
9D00971C  0B4025DD   J 0x9D009774
9D009720  00000000   NOP
256:                 
257:                 		default:
258:                 			RuntimeError(PWM_ERROR_INVALID_DIRECTION);
9D009724  24040086   ADDIU A0, ZERO, 134
9D009728  0F40365E   JAL _RuntimeError
9D00972C  00000000   NOP
259:                 			pgePWMDirection[eMotor] = PWM_DIR_UNKNOWN;		// set project global PWM direction flag
9D009730  3C02A000   LUI V0, -24576
9D009734  8FC30018   LW V1, 24(S8)
9D009738  00031880   SLL V1, V1, 2
9D00973C  2442020C   ADDIU V0, V0, 524
9D009740  00621021   ADDU V0, V1, V0
9D009744  24030002   ADDIU V1, ZERO, 2
9D009748  AC430000   SW V1, 0(V0)
260:                 
261:                 			// not an allowable change, so FORCE an allowable change
262:                 			ePWMConfig = PWM_CONFIG_STOPPED;
9D00974C  AFC0001C   SW ZERO, 28(S8)
263:                 			RuntimeError(PWM_ERROR_INVALID_CONFIGURATION_CHANGE);
9D009750  2404008A   ADDIU A0, ZERO, 138
9D009754  0F40365E   JAL _RuntimeError
9D009758  00000000   NOP
264:                 			break;
9D00975C  0B4025DD   J 0x9D009774
9D009760  00000000   NOP
265:                 		}
266:                 
267:                 
268:                 	//*******************************************
269:                 	//			Set New Configuration
270:                 	//*******************************************
271:                 
272:                 	switch(ePWMConfig)
9D009774  8FC2001C   LW V0, 28(S8)
9D009778  24420001   ADDIU V0, V0, 1
9D00977C  2C430005   SLTIU V1, V0, 5
9D009780  1060006D   BEQ V1, ZERO, 0x9D009938
9D009784  00000000   NOP
9D009788  00021880   SLL V1, V0, 2
9D00978C  3C029D01   LUI V0, -25343
9D009790  244297A4   ADDIU V0, V0, -26716
9D009794  00621021   ADDU V0, V1, V0
9D009798  8C420000   LW V0, 0(V0)
9D00979C  00400008   JR V0
9D0097A0  00000000   NOP
273:                 		{
274:                 		case PWM_CONFIG_REVERSE:
275:                 			pgePWMDirection[eMotor] = PWM_DIR_REVERSE;		// set project global PWM direction flag
9D0097B8  3C02A000   LUI V0, -24576
9D0097BC  8FC30018   LW V1, 24(S8)
9D0097C0  00031880   SLL V1, V1, 2
9D0097C4  2442020C   ADDIU V0, V0, 524
9D0097C8  00621021   ADDU V0, V1, V0
9D0097CC  2403FFFF   ADDIU V1, ZERO, -1
9D0097D0  AC430000   SW V1, 0(V0)
276:                 			pgeMotionType[eMotor] = MOTION_STARTING;		// motion is STARTING, will be MOTION_POWERED after first MSI interrupt
9D0097D4  3C02A000   LUI V0, -24576
9D0097D8  8FC30018   LW V1, 24(S8)
9D0097DC  00031880   SLL V1, V1, 2
9D0097E0  2442026C   ADDIU V0, V0, 620
9D0097E4  00621021   ADDU V0, V1, V0
9D0097E8  24030002   ADDIU V1, ZERO, 2
9D0097EC  AC430000   SW V1, 0(V0)
277:                 
278:                 			MotionSensor_EnableInt(eMotor);					// Enable  Motion Sensor (Input Capture) interrupts
9D0097F0  8FC40018   LW A0, 24(S8)
9D0097F4  0F401A1A   JAL MotionSensor_EnableInt
9D0097F8  00000000   NOP
279:                 			Init_MotionStats(eMotor);						// initialize motion stats and info
9D0097FC  8FC40018   LW A0, 24(S8)
9D009800  0F402765   JAL Init_MotionStats
9D009804  00000000   NOP
280:                 			break;
9D009808  0B402664   J 0x9D009990
9D00980C  00000000   NOP
281:                 
282:                 		case PWM_CONFIG_FORWARD:
283:                 			pgePWMDirection[eMotor] = PWM_DIR_FORWARD;		// set project global PWM direction flag
9D009810  3C02A000   LUI V0, -24576
9D009814  8FC30018   LW V1, 24(S8)
9D009818  00031880   SLL V1, V1, 2
9D00981C  2442020C   ADDIU V0, V0, 524
9D009820  00621021   ADDU V0, V1, V0
9D009824  24030001   ADDIU V1, ZERO, 1
9D009828  AC430000   SW V1, 0(V0)
284:                 			pgeMotionType[eMotor] = MOTION_STARTING;		// motion is STARTING, will be MOTION_POWERED after first MSI interrupt
9D00982C  3C02A000   LUI V0, -24576
9D009830  8FC30018   LW V1, 24(S8)
9D009834  00031880   SLL V1, V1, 2
9D009838  2442026C   ADDIU V0, V0, 620
9D00983C  00621021   ADDU V0, V1, V0
9D009840  24030002   ADDIU V1, ZERO, 2
9D009844  AC430000   SW V1, 0(V0)
285:                 
286:                 			MotionSensor_EnableInt(eMotor);					// Enable  Motion Sensor (Input Capture) interrupts
9D009848  8FC40018   LW A0, 24(S8)
9D00984C  0F401A1A   JAL MotionSensor_EnableInt
9D009850  00000000   NOP
287:                 			Init_MotionStats(eMotor);						// initialize motion stats and info
9D009854  8FC40018   LW A0, 24(S8)
9D009858  0F402765   JAL Init_MotionStats
9D00985C  00000000   NOP
288:                 			break;
9D009860  0B402664   J 0x9D009990
9D009864  00000000   NOP
289:                 
290:                 		case PWM_CONFIG_STOPPED:
291:                 			//MOTOR_CTRL_PWM1 =								// PWM output HI
292:                 			PWM_SetDutyCycle(eMotor, PWM_DUTY_CYCLE_OFF);	// PWM OFF sets output LOW (==> perhaps not what we want?)
9D009868  8FC40018   LW A0, 24(S8)
9D00986C  00002821   ADDU A1, ZERO, ZERO
9D009870  0F402671   JAL PWM_SetDutyCycle
9D009874  00000000   NOP
293:                 
294:                 			// we do not update pgePWMDirection because PWM_DIR_STOPPED is NOT a direction
295:                 			pgwCurrentSpeed[eMotor] = 0;					// speed must now be 0
9D009878  3C02A000   LUI V0, -24576
9D00987C  8FC30018   LW V1, 24(S8)
9D009880  00031840   SLL V1, V1, 1
9D009884  244202A0   ADDIU V0, V0, 672
9D009888  00621021   ADDU V0, V1, V0
9D00988C  A4400000   SH ZERO, 0(V0)
296:                 			pgeMotionType[eMotor] = MOTION_COASTING;		// motion is COASTING
9D009890  3C02A000   LUI V0, -24576
9D009894  8FC30018   LW V1, 24(S8)
9D009898  00031880   SLL V1, V1, 2
9D00989C  2442026C   ADDIU V0, V0, 620
9D0098A0  00621021   ADDU V0, V1, V0
9D0098A4  24030004   ADDIU V1, ZERO, 4
9D0098A8  AC430000   SW V1, 0(V0)
297:                 			break;
9D0098AC  0B402664   J 0x9D009990
9D0098B0  00000000   NOP
298:                 
299:                 		case PWM_CONFIG_BRAKE:
300:                 			// Brake enables the two LOW side MOSFETs to short the motor
301:                 			// NOTE: we have checked above to make sure the current configuration is PWM_CONFIG_REVERSE OR PWM_CONFIG_FORWARD
302:                 			// PWM output can be HI or LOW
303:                 
304:                 			// we do not update pgePWMDirection because PWM_DIR_STOPPED is NOT a direction
305:                 			pgwCurrentSpeed[eMotor] = 0;					// speed must now be 0
9D0098B4  3C02A000   LUI V0, -24576
9D0098B8  8FC30018   LW V1, 24(S8)
9D0098BC  00031840   SLL V1, V1, 1
9D0098C0  244202A0   ADDIU V0, V0, 672
9D0098C4  00621021   ADDU V0, V1, V0
9D0098C8  A4400000   SH ZERO, 0(V0)
306:                 			pgeMotionType[eMotor] = MOTION_BRAKING;			// motion is BRAKING
9D0098CC  3C02A000   LUI V0, -24576
9D0098D0  8FC30018   LW V1, 24(S8)
9D0098D4  00031880   SLL V1, V1, 2
9D0098D8  2442026C   ADDIU V0, V0, 620
9D0098DC  00621021   ADDU V0, V1, V0
9D0098E0  24030005   ADDIU V1, ZERO, 5
9D0098E4  AC430000   SW V1, 0(V0)
307:                 			break;
9D0098E8  0B402664   J 0x9D009990
9D0098EC  00000000   NOP
308:                 
309:                 		case PWM_CONFIG_STANDBY:
310:                 			// Brake enables the two LOW side MOSFETs to short the motor
311:                 			// NOTE: we have checked above to make sure the current configuration is PWM_CONFIG_REVERSE OR PWM_CONFIG_FORWARD
312:                 			// PWM output can be HI or LOW
313:                 			//MOTOR_CTRL_STBY = 0;							// power off the motor controller
314:                 
315:                 			// we do not update pgePWMDirection because PWM_DIR_STOPPED is NOT a direction
316:                 			pgwCurrentSpeed[eMotor] = 0;					// speed must now be 0
9D0098F0  3C02A000   LUI V0, -24576
9D0098F4  8FC30018   LW V1, 24(S8)
9D0098F8  00031840   SLL V1, V1, 1
9D0098FC  244202A0   ADDIU V0, V0, 672
9D009900  00621021   ADDU V0, V1, V0
9D009904  A4400000   SH ZERO, 0(V0)
317:                 			pgeMotionType[eMotor] = MOTION_STOPPED;			// motion is BRAKING
9D009908  3C02A000   LUI V0, -24576
9D00990C  8FC30018   LW V1, 24(S8)
9D009910  00031880   SLL V1, V1, 2
9D009914  2442026C   ADDIU V0, V0, 620
9D009918  00621021   ADDU V0, V1, V0
9D00991C  24030001   ADDIU V1, ZERO, 1
9D009920  AC430000   SW V1, 0(V0)
318:                 			MotionSensor_DisableInt(eMotor);				// disable Motion Sensor (Input Capture) interrupts
9D009924  8FC40018   LW A0, 24(S8)
9D009928  0F401A77   JAL MotionSensor_DisableInt
9D00992C  00000000   NOP
319:                 			break;
9D009930  0B402664   J 0x9D009990
9D009934  00000000   NOP
320:                 
321:                 
322:                 		case PWM_CONFIG_UNKNOWN:					// meaningless error
323:                 		default:
324:                 			// these are errors, and should have been covered above..
325:                 			RuntimeError(PWM_ERROR_INVALID_DIRECTION);
9D009938  24040086   ADDIU A0, ZERO, 134
9D00993C  0F40365E   JAL _RuntimeError
9D009940  00000000   NOP
326:                 			pgePWMDirection[eMotor] = PWM_DIR_UNKNOWN;		// set project global PWM direction flag
9D009944  3C02A000   LUI V0, -24576
9D009948  8FC30018   LW V1, 24(S8)
9D00994C  00031880   SLL V1, V1, 2
9D009950  2442020C   ADDIU V0, V0, 524
9D009954  00621021   ADDU V0, V1, V0
9D009958  24030002   ADDIU V1, ZERO, 2
9D00995C  AC430000   SW V1, 0(V0)
327:                 			pgePWMConfig[eMotor] = PWM_CONFIG_UNKNOWN;		// set project global PWM configuration flag
9D009960  3C02A000   LUI V0, -24576
9D009964  8FC30018   LW V1, 24(S8)
9D009968  00031880   SLL V1, V1, 2
9D00996C  24420204   ADDIU V0, V0, 516
9D009970  00621021   ADDU V0, V1, V0
9D009974  24030004   ADDIU V1, ZERO, 4
9D009978  AC430000   SW V1, 0(V0)
328:                 			MotionSensor_DisableInt(eMotor);				// disable Motion Sensor (Input Capture) interrupts
9D00997C  8FC40018   LW A0, 24(S8)
9D009980  0F401A77   JAL MotionSensor_DisableInt
9D009984  00000000   NOP
329:                 			return;
9D009988  0B40266B   J 0x9D0099AC
9D00998C  00000000   NOP
330:                 		}
331:                 
332:                 	// save the new configuration to the project global PWM configuration flag
333:                 	pgePWMConfig[eMotor] = ePWMConfig;						// set project global PWM configuration flag
9D009990  3C02A000   LUI V0, -24576
9D009994  8FC30018   LW V1, 24(S8)
9D009998  00031880   SLL V1, V1, 2
9D00999C  24420204   ADDIU V0, V0, 516
9D0099A0  00621021   ADDU V0, V1, V0
9D0099A4  8FC3001C   LW V1, 28(S8)
9D0099A8  AC430000   SW V1, 0(V0)
334:                 
335:                 
336:                 	//???												// enable the PWM timebase to start the PWM
337:                 
338:                 }
9D0099AC  03C0E821   ADDU SP, S8, ZERO
9D0099B0  8FBF0014   LW RA, 20(SP)
9D0099B4  8FBE0010   LW S8, 16(SP)
9D0099B8  27BD0018   ADDIU SP, SP, 24
9D0099BC  03E00008   JR RA
9D0099C0  00000000   NOP
339:                 
340:                 
341:                 
342:                 // set PWM output duty cycle, specified as a percentage of the PWM period (0 to 100)
343:                 BOOL PWM_SetDutyCycle(enum tagMotors eMotor, unsigned int nDutyCycle)
344:                 {
9D0099C4  27BDFFE0   ADDIU SP, SP, -32
9D0099C8  AFBF001C   SW RA, 28(SP)
9D0099CC  AFBE0018   SW S8, 24(SP)
9D0099D0  03A0F021   ADDU S8, SP, ZERO
9D0099D4  AFC40020   SW A0, 32(S8)
9D0099D8  AFC50024   SW A1, 36(S8)
345:                 
346:                 	BOOL bRetVal = TRUE;
9D0099DC  24020001   ADDIU V0, ZERO, 1
9D0099E0  AFC20010   SW V0, 16(S8)
347:                 
348:                 	// the passed parameter duty cycle nDutyCycle ranges from 0 (off) to 100 (full on), although a range of values from 1 to pgwPWMDutyCycleMin (about 20) is not useful/allowed.
349:                 
350:                 	//		PIC32 Family Reference Manual, Section 16. Output Compare
351:                 	//			version DS61111E, 16.3.3 Pulse Width Modulation Mode, page 16-28
352:                 
353:                 	//	Some important boundary parameters of the PWM duty cycle include the following:
354:                 	//		â€¢ If the duty cycle register OCxR is loaded with 0x0000, the OCx pin will remain low (0% duty cycle)
355:                 	//		â€¢ If OCxR is greater than PRy (timer period register), the pin will remain high (100% duty cycle)
356:                 	//		â€¢ If OCxR is equal to PRy, the OCx pin will be low for one time base count value and high for all other count values
357:                 
358:                 	//**********************************
359:                 	// bounds check duty cycle
360:                 	//**********************************
361:                 	if (nDutyCycle > PWM_DUTY_CYCLE_MAX)
9D0099E4  8FC20024   LW V0, 36(S8)
9D0099E8  2C420063   SLTIU V0, V0, 99
9D0099EC  14400015   BNE V0, ZERO, 0x9D009A44
9D0099F0  00000000   NOP
362:                 		{
363:                 		RuntimeError(PWM_ERROR_INVALID_DUTY_CYCLE_HIGH);
9D0099F4  24040087   ADDIU A0, ZERO, 135
9D0099F8  0F40365E   JAL _RuntimeError
9D0099FC  00000000   NOP
364:                 		nDutyCycle = PWM_DUTY_CYCLE_MAX;
9D009A00  24020062   ADDIU V0, ZERO, 98
9D009A04  AFC20024   SW V0, 36(S8)
365:                 
366:                 		BITSET(efMotionEvents[eMotor], EF_MOTION_MAXIMUM_PWM);
9D009A08  3C02A000   LUI V0, -24576
9D009A0C  8FC30020   LW V1, 32(S8)
9D009A10  00031840   SLL V1, V1, 1
9D009A14  244202D8   ADDIU V0, V0, 728
9D009A18  00621021   ADDU V0, V1, V0
9D009A1C  94420000   LHU V0, 0(V0)
9D009A20  34420010   ORI V0, V0, 16
9D009A24  3043FFFF   ANDI V1, V0, -1
9D009A28  3C02A000   LUI V0, -24576
9D009A2C  8FC40020   LW A0, 32(S8)
9D009A30  00042040   SLL A0, A0, 1
9D009A34  244202D8   ADDIU V0, V0, 728
9D009A38  00821021   ADDU V0, A0, V0
9D009A3C  A4430000   SH V1, 0(V0)
367:                 		bRetVal = FALSE;									// not a valid value
9D009A40  AFC00010   SW ZERO, 16(S8)
368:                 		}
369:                 
370:                 	if ((nDutyCycle < pgwPWMDutyCycleMin[eMotor]) AND (nDutyCycle IS_NOT 0))
9D009A44  3C02A000   LUI V0, -24576
9D009A48  8FC30020   LW V1, 32(S8)
9D009A4C  00031840   SLL V1, V1, 1
9D009A50  24420214   ADDIU V0, V0, 532
9D009A54  00621021   ADDU V0, V1, V0
9D009A58  94420000   LHU V0, 0(V0)
9D009A5C  00401821   ADDU V1, V0, ZERO
9D009A60  8FC20024   LW V0, 36(S8)
9D009A64  0043102B   SLTU V0, V0, V1
9D009A68  1040001D   BEQ V0, ZERO, 0x9D009AE0
9D009A6C  00000000   NOP
9D009A70  8FC20024   LW V0, 36(S8)
9D009A74  1040001A   BEQ V0, ZERO, 0x9D009AE0
9D009A78  00000000   NOP
371:                 		{
372:                 		RuntimeError(PWM_ERROR_INVALID_DUTY_CYCLE_LOW);
9D009A7C  24040088   ADDIU A0, ZERO, 136
9D009A80  0F40365E   JAL _RuntimeError
9D009A84  00000000   NOP
373:                 		nDutyCycle = pgwPWMDutyCycleMin[eMotor];
9D009A88  3C02A000   LUI V0, -24576
9D009A8C  8FC30020   LW V1, 32(S8)
9D009A90  00031840   SLL V1, V1, 1
9D009A94  24420214   ADDIU V0, V0, 532
9D009A98  00621021   ADDU V0, V1, V0
9D009A9C  94420000   LHU V0, 0(V0)
9D009AA0  AFC20024   SW V0, 36(S8)
374:                 
375:                 		BITSET(efMotionEvents[eMotor], EF_MOTION_MINIMUM_PWM);
9D009AA4  3C02A000   LUI V0, -24576
9D009AA8  8FC30020   LW V1, 32(S8)
9D009AAC  00031840   SLL V1, V1, 1
9D009AB0  244202D8   ADDIU V0, V0, 728
9D009AB4  00621021   ADDU V0, V1, V0
9D009AB8  94420000   LHU V0, 0(V0)
9D009ABC  34420008   ORI V0, V0, 8
9D009AC0  3043FFFF   ANDI V1, V0, -1
9D009AC4  3C02A000   LUI V0, -24576
9D009AC8  8FC40020   LW A0, 32(S8)
9D009ACC  00042040   SLL A0, A0, 1
9D009AD0  244202D8   ADDIU V0, V0, 728
9D009AD4  00821021   ADDU V0, A0, V0
9D009AD8  A4430000   SH V1, 0(V0)
376:                 		bRetVal = FALSE;									// not a valid value
9D009ADC  AFC00010   SW ZERO, 16(S8)
377:                 		}
378:                 
379:                 	//**********************************
380:                 	//		update duty cycle
381:                 	//**********************************
382:                 
383:                 	pgwPWMDutyCycle[eMotor] = nDutyCycle;				// keep track of current duty cycle; for testing only
9D009AE0  8FC20024   LW V0, 36(S8)
9D009AE4  3043FFFF   ANDI V1, V0, -1
9D009AE8  3C02A000   LUI V0, -24576
9D009AEC  8FC40020   LW A0, 32(S8)
9D009AF0  00042040   SLL A0, A0, 1
9D009AF4  24420268   ADDIU V0, V0, 616
9D009AF8  00821021   ADDU V0, A0, V0
9D009AFC  A4430000   SH V1, 0(V0)
384:                 
385:                 	if (eMotor IS MOTOR_AZIMUTH)
9D009B00  8FC20020   LW V0, 32(S8)
9D009B04  1440004C   BNE V0, ZERO, 0x9D009C38
9D009B08  00000000   NOP
386:                 	{
387:                 		if (nDutyCycle IS 0)							// make sure we do not divide by 0!
9D009B0C  8FC20024   LW V0, 36(S8)
9D009B10  14400007   BNE V0, ZERO, 0x9D009B30
9D009B14  00000000   NOP
388:                 		{
389:                 			SetDCOC1PWM((UINT32)0);						// writes to OC1RS
9D009B18  3C02BF80   LUI V0, -16512
9D009B1C  AC403020   SW ZERO, 12320(V0)
390:                 			SetDCOC2PWM((UINT32)0);						// writes to OC1RS
9D009B20  3C02BF80   LUI V0, -16512
9D009B24  AC403220   SW ZERO, 12832(V0)
9D009B28  0B40275E   J 0x9D009D78
9D009B2C  00000000   NOP
391:                 		}
392:                 		else
393:                 		{
394:                 			if (pgePWMConfig[eMotor] IS PWM_CONFIG_FORWARD)
9D009B30  3C02A000   LUI V0, -24576
9D009B34  8FC30020   LW V1, 32(S8)
9D009B38  00031880   SLL V1, V1, 2
9D009B3C  24420204   ADDIU V0, V0, 516
9D009B40  00621021   ADDU V0, V1, V0
9D009B44  8C430000   LW V1, 0(V0)
9D009B48  24020001   ADDIU V0, ZERO, 1
9D009B4C  14620016   BNE V1, V0, 0x9D009BA8
9D009B50  00000000   NOP
395:                 			{
396:                 				SetDCOC1PWM((UINT32)(PWM_PERIOD / 100) * (UINT32)nDutyCycle);
9D009B54  3C02BF81   LUI V0, -16511
9D009B58  8C42F000   LW V0, -4096(V0)
9D009B5C  7C420CC0   EXT V0, V0, 19, 2
9D009B60  304200FF   ANDI V0, V0, 255
9D009B64  3C0304C4   LUI V1, 1220
9D009B68  3463B400   ORI V1, V1, -19456
9D009B6C  00431806   SRLV V1, V1, V0
9D009B70  3C02431B   LUI V0, 17179
9D009B74  3442DE83   ORI V0, V0, -8573
9D009B78  00620019   MULTU V1, V0
9D009B7C  00001012   MFLO V0
9D009B80  00001810   MFHI V1
9D009B84  00031C82   SRL V1, V1, 18
9D009B88  8FC20024   LW V0, 36(S8)
9D009B8C  70621802   MUL V1, V1, V0
9D009B90  3C02BF80   LUI V0, -16512
9D009B94  AC433020   SW V1, 12320(V0)
397:                 				SetDCOC2PWM((UINT32)0);						// writes to OC1RS
9D009B98  3C02BF80   LUI V0, -16512
9D009B9C  AC403220   SW ZERO, 12832(V0)
9D009BA0  0B40275E   J 0x9D009D78
9D009BA4  00000000   NOP
398:                 			}
399:                 			else if (pgePWMConfig[eMotor] IS PWM_CONFIG_REVERSE)
9D009BA8  3C02A000   LUI V0, -24576
9D009BAC  8FC30020   LW V1, 32(S8)
9D009BB0  00031880   SLL V1, V1, 2
9D009BB4  24420204   ADDIU V0, V0, 516
9D009BB8  00621021   ADDU V0, V1, V0
9D009BBC  8C430000   LW V1, 0(V0)
9D009BC0  2402FFFF   ADDIU V0, ZERO, -1
9D009BC4  14620016   BNE V1, V0, 0x9D009C20
9D009BC8  00000000   NOP
400:                 			{
401:                 				SetDCOC1PWM((UINT32)0);
9D009BCC  3C02BF80   LUI V0, -16512
9D009BD0  AC403020   SW ZERO, 12320(V0)
402:                 				SetDCOC2PWM((UINT32)(PWM_PERIOD / 100) * (UINT32)nDutyCycle);
9D009BD4  3C02BF81   LUI V0, -16511
9D009BD8  8C42F000   LW V0, -4096(V0)
9D009BDC  7C420CC0   EXT V0, V0, 19, 2
9D009BE0  304200FF   ANDI V0, V0, 255
9D009BE4  3C0304C4   LUI V1, 1220
9D009BE8  3463B400   ORI V1, V1, -19456
9D009BEC  00431806   SRLV V1, V1, V0
9D009BF0  3C02431B   LUI V0, 17179
9D009BF4  3442DE83   ORI V0, V0, -8573
9D009BF8  00620019   MULTU V1, V0
9D009BFC  00001012   MFLO V0
9D009C00  00001810   MFHI V1
9D009C04  00031C82   SRL V1, V1, 18
9D009C08  8FC20024   LW V0, 36(S8)
9D009C0C  70621802   MUL V1, V1, V0
9D009C10  3C02BF80   LUI V0, -16512
9D009C14  AC433220   SW V1, 12832(V0)
9D009C18  0B40275E   J 0x9D009D78
9D009C1C  00000000   NOP
403:                 			}
404:                 			else	// not a valid running config
405:                 			{
406:                 				SetDCOC1PWM((UINT32)0);
9D009C20  3C02BF80   LUI V0, -16512
9D009C24  AC403020   SW ZERO, 12320(V0)
407:                 				SetDCOC2PWM((UINT32)0);
9D009C28  3C02BF80   LUI V0, -16512
9D009C2C  AC403220   SW ZERO, 12832(V0)
9D009C30  0B40275E   J 0x9D009D78
9D009C34  00000000   NOP
408:                 			}
409:                 		}
410:                 	}
411:                 	else if (eMotor IS MOTOR_ELEVATION)
9D009C38  8FC30020   LW V1, 32(S8)
9D009C3C  24020001   ADDIU V0, ZERO, 1
9D009C40  1462004C   BNE V1, V0, 0x9D009D74
9D009C44  00000000   NOP
412:                 	{
413:                 		// writes to OC1RS
414:                 		if (nDutyCycle IS 0)							// make sure we do not divide by 0!
9D009C48  8FC20024   LW V0, 36(S8)
9D009C4C  14400007   BNE V0, ZERO, 0x9D009C6C
9D009C50  00000000   NOP
415:                 		{
416:                 			SetDCOC3PWM((UINT32)0);
9D009C54  3C02BF80   LUI V0, -16512
9D009C58  AC403420   SW ZERO, 13344(V0)
417:                 			SetDCOC4PWM((UINT32)0);
9D009C5C  3C02BF80   LUI V0, -16512
9D009C60  AC403620   SW ZERO, 13856(V0)
9D009C64  0B40275E   J 0x9D009D78
9D009C68  00000000   NOP
418:                 		}
419:                 		else
420:                 		{
421:                 			if (pgePWMConfig[eMotor] IS PWM_CONFIG_FORWARD)
9D009C6C  3C02A000   LUI V0, -24576
9D009C70  8FC30020   LW V1, 32(S8)
9D009C74  00031880   SLL V1, V1, 2
9D009C78  24420204   ADDIU V0, V0, 516
9D009C7C  00621021   ADDU V0, V1, V0
9D009C80  8C430000   LW V1, 0(V0)
9D009C84  24020001   ADDIU V0, ZERO, 1
9D009C88  14620016   BNE V1, V0, 0x9D009CE4
9D009C8C  00000000   NOP
422:                 			{
423:                 				SetDCOC3PWM((UINT32)(PWM_PERIOD / 100) * (UINT32)nDutyCycle);
9D009C90  3C02BF81   LUI V0, -16511
9D009C94  8C42F000   LW V0, -4096(V0)
9D009C98  7C420CC0   EXT V0, V0, 19, 2
9D009C9C  304200FF   ANDI V0, V0, 255
9D009CA0  3C0304C4   LUI V1, 1220
9D009CA4  3463B400   ORI V1, V1, -19456
9D009CA8  00431806   SRLV V1, V1, V0
9D009CAC  3C02431B   LUI V0, 17179
9D009CB0  3442DE83   ORI V0, V0, -8573
9D009CB4  00620019   MULTU V1, V0
9D009CB8  00001012   MFLO V0
9D009CBC  00001810   MFHI V1
9D009CC0  00031C82   SRL V1, V1, 18
9D009CC4  8FC20024   LW V0, 36(S8)
9D009CC8  70621802   MUL V1, V1, V0
9D009CCC  3C02BF80   LUI V0, -16512
9D009CD0  AC433420   SW V1, 13344(V0)
424:                 				SetDCOC4PWM((UINT32)0);
9D009CD4  3C02BF80   LUI V0, -16512
9D009CD8  AC403620   SW ZERO, 13856(V0)
9D009CDC  0B40275E   J 0x9D009D78
9D009CE0  00000000   NOP
425:                 			}
426:                 			else if (pgePWMConfig[eMotor] IS PWM_CONFIG_REVERSE)
9D009CE4  3C02A000   LUI V0, -24576
9D009CE8  8FC30020   LW V1, 32(S8)
9D009CEC  00031880   SLL V1, V1, 2
9D009CF0  24420204   ADDIU V0, V0, 516
9D009CF4  00621021   ADDU V0, V1, V0
9D009CF8  8C430000   LW V1, 0(V0)
9D009CFC  2402FFFF   ADDIU V0, ZERO, -1
9D009D00  14620016   BNE V1, V0, 0x9D009D5C
9D009D04  00000000   NOP
427:                 			{
428:                 				SetDCOC3PWM((UINT32)0);
9D009D08  3C02BF80   LUI V0, -16512
9D009D0C  AC403420   SW ZERO, 13344(V0)
429:                 				SetDCOC4PWM((UINT32)(PWM_PERIOD / 100) * (UINT32)nDutyCycle);
9D009D10  3C02BF81   LUI V0, -16511
9D009D14  8C42F000   LW V0, -4096(V0)
9D009D18  7C420CC0   EXT V0, V0, 19, 2
9D009D1C  304200FF   ANDI V0, V0, 255
9D009D20  3C0304C4   LUI V1, 1220
9D009D24  3463B400   ORI V1, V1, -19456
9D009D28  00431806   SRLV V1, V1, V0
9D009D2C  3C02431B   LUI V0, 17179
9D009D30  3442DE83   ORI V0, V0, -8573
9D009D34  00620019   MULTU V1, V0
9D009D38  00001012   MFLO V0
9D009D3C  00001810   MFHI V1
9D009D40  00031C82   SRL V1, V1, 18
9D009D44  8FC20024   LW V0, 36(S8)
9D009D48  70621802   MUL V1, V1, V0
9D009D4C  3C02BF80   LUI V0, -16512
9D009D50  AC433620   SW V1, 13856(V0)
9D009D54  0B40275E   J 0x9D009D78
9D009D58  00000000   NOP
430:                 			}
431:                 			else	// not a valid running config
432:                 			{
433:                 				SetDCOC3PWM((UINT32)0);
9D009D5C  3C02BF80   LUI V0, -16512
9D009D60  AC403420   SW ZERO, 13344(V0)
434:                 				SetDCOC4PWM((UINT32)0);
9D009D64  3C02BF80   LUI V0, -16512
9D009D68  AC403620   SW ZERO, 13856(V0)
9D009D6C  0B40275E   J 0x9D009D78
9D009D70  00000000   NOP
435:                 			}
436:                 		}
437:                 	}
438:                 	else
439:                 	{
440:                 		bRetVal = FALSE;								// not a valid motor ID
9D009D74  AFC00010   SW ZERO, 16(S8)
441:                 	}
442:                 
443:                 	return bRetVal;
9D009D78  8FC20010   LW V0, 16(S8)
444:                 }
9D009D7C  03C0E821   ADDU SP, S8, ZERO
9D009D80  8FBF001C   LW RA, 28(SP)
9D009D84  8FBE0018   LW S8, 24(SP)
9D009D88  27BD0020   ADDIU SP, SP, 32
9D009D8C  03E00008   JR RA
9D009D90  00000000   NOP
445:                 
446:                 
447:                 #ifdef NOTDEF
448:                 	void __ISR(_TIMER_2_VECTOR, ipl7) T2_IntHandler (void)
449:                 	{
450:                 		// Insert user code here
451:                 		IFS0CLR = 0x0100; // Clearing Timer2 interrupt flag
452:                 	}
453:                 #endif
454:                 
455:                 // end of MotorPWM.c
456:                 
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/MotionStats.c  -------------------
1:                   //*************************************************************************************************
2:                   //									M o t i o n S t a t s . C
3:                   //*************************************************************************************************
4:                   //*************************************************************************************************
5:                   //
6:                   //		Project:	SmartTrak Solar Panel Controller
7:                   //
8:                   //		Contains:	Motion Control statistics for debugging and analysis
9:                   //
10:                  //		001	05 Mar 13 <sek> created from gsf Code Base
11:                  //		002	16 Mar 13 <sek> changed HEI (hall effect int) to MSI (motion sensor int), support two motors
12:                  //
13:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
14:                  //					gsf Engineering	978-927-7189
15:                  //					Beverly, MA 01915
16:                  //
17:                  //		copyright (c) 2013 gsf Engineering (Beverly, MA USA)
18:                  //
19:                  //
20:                  //*************************************************************************************************
21:                  
22:                  //-------------------------------------------------------------------------------------------------------
23:                  //	Include Files
24:                  //-------------------------------------------------------------------------------------------------------
25:                  #include <GenericTypeDefs.h>
26:                  
27:                  //lint -e765					error 765: (Info -- external function could be made static)
28:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
29:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
30:                  //lint +e14
31:                  
32:                  #include <string.h>				// Microchip string functions
33:                  								// see hlpC18.chm online help for so-called documentation
34:                  #include <ctype.h>				// tolower()
35:                  
36:                  #include "gsfstd.h"				// gsf standard #defines
37:                  //#include "init.h"				// port definitions and initialization state
38:                  #include "Debug.h"
39:                  #include "SmartTrak.h"			// Project wide definitions
40:                  #include "HardwareProfile.h"
41:                  
42:                  #include "EventFlags.h"			// event flag definitions and globals
43:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
44:                  //#include "ADCRead.h"			// adc access functions
45:                  #include "MotorPWM.h"			// Motor PWM function prototypes and definitions
46:                  #include "MotionFSM.h"			// Motion Control function prototypes and definitions
47:                  #include "MotionStats.h"		// Motion Control statistics for debugging and analysis
48:                  #include "Encoder.h"			// Hall Effect Quadrature Encoder function prototypes and definitions
49:                  
50:                  //-------------------------------------------------------------------------------------------------------
51:                  // Definitions
52:                  //-------------------------------------------------------------------------------------------------------
53:                  
54:                  //-------------------------------------------------------------------------------------------------------
55:                  // Static Variables
56:                  //-------------------------------------------------------------------------------------------------------
57:                  
58:                  PRIVATE_INIT BYTE fgbMotionProfilePWMIndex = 0;			// index into motion profile table for reading PWM values; may be out of sync with index for speed values
59:                  
60:                  //-------------------------------------------------------------------------------------------------------
61:                  // Static Function Prototypes
62:                  //-------------------------------------------------------------------------------------------------------
63:                  
64:                  #ifdef MOTION_ERROR_TABLE
65:                  	void ClearMotionErrorTable(void);
66:                  #endif
67:                  
68:                  //*************************************************************************************************
69:                  //									M o t i o n S t a t s
70:                  //*************************************************************************************************
71:                  
72:                  
73:                  void Init_MotionStats(enum tagMotors eMotor)
74:                  {
9D009D94  27BDFFF8   ADDIU SP, SP, -8
9D009D98  AFBE0004   SW S8, 4(SP)
9D009D9C  03A0F021   ADDU S8, SP, ZERO
9D009DA0  AFC40008   SW A0, 8(S8)
75:                  
76:                  	pgMotionStats[eMotor].ePWMDirection = PWM_DIR_STOPPED;
9D009DA4  3C02A000   LUI V0, -24576
9D009DA8  8FC40008   LW A0, 8(S8)
9D009DAC  24030060   ADDIU V1, ZERO, 96
9D009DB0  70831802   MUL V1, A0, V1
9D009DB4  244204CC   ADDIU V0, V0, 1228
9D009DB8  00621021   ADDU V0, V1, V0
9D009DBC  AC400000   SW ZERO, 0(V0)
77:                  
78:                  	pgMotionStats[eMotor].nStartingPosition = pgnCurrentPosition[eMotor];
9D009DC0  3C02A000   LUI V0, -24576
9D009DC4  8FC30008   LW V1, 8(S8)
9D009DC8  00031880   SLL V1, V1, 2
9D009DCC  244202AC   ADDIU V0, V0, 684
9D009DD0  00621021   ADDU V0, V1, V0
9D009DD4  8C430000   LW V1, 0(V0)
9D009DD8  3C02A000   LUI V0, -24576
9D009DDC  8FC50008   LW A1, 8(S8)
9D009DE0  244404CC   ADDIU A0, V0, 1228
9D009DE4  24020060   ADDIU V0, ZERO, 96
9D009DE8  70A21002   MUL V0, A1, V0
9D009DEC  00821021   ADDU V0, A0, V0
9D009DF0  AC430004   SW V1, 4(V0)
79:                  	pgMotionStats[eMotor].nEndingPosition = 0;
9D009DF4  3C02A000   LUI V0, -24576
9D009DF8  8FC40008   LW A0, 8(S8)
9D009DFC  24030060   ADDIU V1, ZERO, 96
9D009E00  70831802   MUL V1, A0, V1
9D009E04  244204CC   ADDIU V0, V0, 1228
9D009E08  00621021   ADDU V0, V1, V0
9D009E0C  AC400008   SW ZERO, 8(V0)
80:                  	pgMotionStats[eMotor].nDistance = 0;
9D009E10  3C02A000   LUI V0, -24576
9D009E14  8FC40008   LW A0, 8(S8)
9D009E18  244304CC   ADDIU V1, V0, 1228
9D009E1C  24020060   ADDIU V0, ZERO, 96
9D009E20  70821002   MUL V0, A0, V0
9D009E24  00621021   ADDU V0, V1, V0
9D009E28  AC40000C   SW ZERO, 12(V0)
81:                  
82:                  	pgMotionStats[eMotor].wPWM_AccelDutyCycleMin = 100;			// init to maximum value so that it will be overwritten
9D009E2C  3C02A000   LUI V0, -24576
9D009E30  8FC40008   LW A0, 8(S8)
9D009E34  24030060   ADDIU V1, ZERO, 96
9D009E38  70831802   MUL V1, A0, V1
9D009E3C  244204CC   ADDIU V0, V0, 1228
9D009E40  00621021   ADDU V0, V1, V0
9D009E44  24030064   ADDIU V1, ZERO, 100
9D009E48  A4430010   SH V1, 16(V0)
83:                  	pgMotionStats[eMotor].wPWM_AccelDutyCycleMax = 0;			// init to minimum value
9D009E4C  3C02A000   LUI V0, -24576
9D009E50  8FC40008   LW A0, 8(S8)
9D009E54  24030060   ADDIU V1, ZERO, 96
9D009E58  70831802   MUL V1, A0, V1
9D009E5C  244204CC   ADDIU V0, V0, 1228
9D009E60  00621021   ADDU V0, V1, V0
9D009E64  A4400012   SH ZERO, 18(V0)
84:                  	pgMotionStats[eMotor].nPWM_AccelDutyCycleCorrectionMin = 0;	// init to minimum value
9D009E68  3C02A000   LUI V0, -24576
9D009E6C  8FC40008   LW A0, 8(S8)
9D009E70  244304CC   ADDIU V1, V0, 1228
9D009E74  24020060   ADDIU V0, ZERO, 96
9D009E78  70821002   MUL V0, A0, V0
9D009E7C  00621021   ADDU V0, V1, V0
9D009E80  AC400014   SW ZERO, 20(V0)
85:                  	pgMotionStats[eMotor].nPWM_AccelDutyCycleCorrectionMax = 0;	// init to minimum value
9D009E84  3C02A000   LUI V0, -24576
9D009E88  8FC40008   LW A0, 8(S8)
9D009E8C  24030060   ADDIU V1, ZERO, 96
9D009E90  70831802   MUL V1, A0, V1
9D009E94  244204CC   ADDIU V0, V0, 1228
9D009E98  00621021   ADDU V0, V1, V0
9D009E9C  AC400018   SW ZERO, 24(V0)
86:                  	pgMotionStats[eMotor].wPWM_RunDutyCycleMin = 100;			// init to maximum value
9D009EA0  3C02A000   LUI V0, -24576
9D009EA4  8FC40008   LW A0, 8(S8)
9D009EA8  24030060   ADDIU V1, ZERO, 96
9D009EAC  70831802   MUL V1, A0, V1
9D009EB0  244204CC   ADDIU V0, V0, 1228
9D009EB4  00621021   ADDU V0, V1, V0
9D009EB8  24030064   ADDIU V1, ZERO, 100
9D009EBC  A443001C   SH V1, 28(V0)
87:                  	pgMotionStats[eMotor].wPWM_RunDutyCycleMax= 0;				// init to minimum value
9D009EC0  3C02A000   LUI V0, -24576
9D009EC4  8FC40008   LW A0, 8(S8)
9D009EC8  24030060   ADDIU V1, ZERO, 96
9D009ECC  70831802   MUL V1, A0, V1
9D009ED0  244204CC   ADDIU V0, V0, 1228
9D009ED4  00621021   ADDU V0, V1, V0
9D009ED8  A440001E   SH ZERO, 30(V0)
88:                  	pgMotionStats[eMotor].nPWM_RunDutyCycleCorrectionMin = 0;	// init to minimum value
9D009EDC  3C02A000   LUI V0, -24576
9D009EE0  8FC40008   LW A0, 8(S8)
9D009EE4  24030060   ADDIU V1, ZERO, 96
9D009EE8  70831802   MUL V1, A0, V1
9D009EEC  244204CC   ADDIU V0, V0, 1228
9D009EF0  00621021   ADDU V0, V1, V0
9D009EF4  AC400020   SW ZERO, 32(V0)
89:                  	pgMotionStats[eMotor].nPWM_RunDutyCycleCorrectionMax = 0;	// init to minimum value
9D009EF8  3C02A000   LUI V0, -24576
9D009EFC  8FC40008   LW A0, 8(S8)
9D009F00  244304CC   ADDIU V1, V0, 1228
9D009F04  24020060   ADDIU V0, ZERO, 96
9D009F08  70821002   MUL V0, A0, V0
9D009F0C  00621021   ADDU V0, V1, V0
9D009F10  AC400024   SW ZERO, 36(V0)
90:                  	pgMotionStats[eMotor].wPWM_DecelDutyCycleMin = 100;			// init to maximum value
9D009F14  3C02A000   LUI V0, -24576
9D009F18  8FC40008   LW A0, 8(S8)
9D009F1C  24030060   ADDIU V1, ZERO, 96
9D009F20  70831802   MUL V1, A0, V1
9D009F24  244204CC   ADDIU V0, V0, 1228
9D009F28  00621021   ADDU V0, V1, V0
9D009F2C  24030064   ADDIU V1, ZERO, 100
9D009F30  A443002A   SH V1, 42(V0)
91:                  	pgMotionStats[eMotor].wPWM_DecelDutyCycleMax = 0;			// init to minimum value
9D009F34  3C02A000   LUI V0, -24576
9D009F38  8FC40008   LW A0, 8(S8)
9D009F3C  24030060   ADDIU V1, ZERO, 96
9D009F40  70831802   MUL V1, A0, V1
9D009F44  244204CC   ADDIU V0, V0, 1228
9D009F48  00621021   ADDU V0, V1, V0
9D009F4C  A4400028   SH ZERO, 40(V0)
92:                  
93:                  	pgMotionStats[eMotor].bPWMAccelMotionIndex = 0;
9D009F50  3C02A000   LUI V0, -24576
9D009F54  8FC40008   LW A0, 8(S8)
9D009F58  24030060   ADDIU V1, ZERO, 96
9D009F5C  70831802   MUL V1, A0, V1
9D009F60  244204CC   ADDIU V0, V0, 1228
9D009F64  00621021   ADDU V0, V1, V0
9D009F68  A040002C   SB ZERO, 44(V0)
94:                  	pgMotionStats[eMotor].bPWMDecelMotionIndex = 0;
9D009F6C  3C02A000   LUI V0, -24576
9D009F70  8FC40008   LW A0, 8(S8)
9D009F74  24030060   ADDIU V1, ZERO, 96
9D009F78  70831802   MUL V1, A0, V1
9D009F7C  244204CC   ADDIU V0, V0, 1228
9D009F80  00621021   ADDU V0, V1, V0
9D009F84  A040002D   SB ZERO, 45(V0)
95:                  	pgMotionStats[eMotor].bSpeedlMotionIndex = 0;
9D009F88  3C02A000   LUI V0, -24576
9D009F8C  8FC40008   LW A0, 8(S8)
9D009F90  24030060   ADDIU V1, ZERO, 96
9D009F94  70831802   MUL V1, A0, V1
9D009F98  244204CC   ADDIU V0, V0, 1228
9D009F9C  00621021   ADDU V0, V1, V0
9D009FA0  A040002E   SB ZERO, 46(V0)
96:                  
97:                  	// NOTE: speed values are count of Tcy ticks, so SMALLER is FASTER
98:                  	pgMotionStats[eMotor].wMinimumSpeed = 0;				// slower is larger
9D009FA4  3C02A000   LUI V0, -24576
9D009FA8  8FC40008   LW A0, 8(S8)
9D009FAC  24030060   ADDIU V1, ZERO, 96
9D009FB0  70831802   MUL V1, A0, V1
9D009FB4  244204CC   ADDIU V0, V0, 1228
9D009FB8  00621021   ADDU V0, V1, V0
9D009FBC  A4400030   SH ZERO, 48(V0)
99:                  	pgMotionStats[eMotor].wMaximumSpeed = 0xFFFF;			// faster is smaller
9D009FC0  3C02A000   LUI V0, -24576
9D009FC4  8FC40008   LW A0, 8(S8)
9D009FC8  24030060   ADDIU V1, ZERO, 96
9D009FCC  70831802   MUL V1, A0, V1
9D009FD0  244204CC   ADDIU V0, V0, 1228
9D009FD4  00621021   ADDU V0, V1, V0
9D009FD8  2403FFFF   ADDIU V1, ZERO, -1
9D009FDC  A4430032   SH V1, 50(V0)
100:                 	#ifdef CALC_AVERAGE_SPEED
101:                 		pgMotionStats[eMotor].wAverageSpeed = 0;
102:                 	#endif
103:                 	pgMotionStats[eMotor].wLastMotionStallTimer = 0;
9D009FE0  3C02A000   LUI V0, -24576
9D009FE4  8FC40008   LW A0, 8(S8)
9D009FE8  24030060   ADDIU V1, ZERO, 96
9D009FEC  70831802   MUL V1, A0, V1
9D009FF0  244204CC   ADDIU V0, V0, 1228
9D009FF4  00621021   ADDU V0, V1, V0
9D009FF8  A4400034   SH ZERO, 52(V0)
104:                 
105:                 	pgMotionStats[eMotor].wMSI_AccelerationCount = 0;
9D009FFC  3C02A000   LUI V0, -24576
9D00A000  8FC40008   LW A0, 8(S8)
9D00A004  24030060   ADDIU V1, ZERO, 96
9D00A008  70831802   MUL V1, A0, V1
9D00A00C  244204CC   ADDIU V0, V0, 1228
9D00A010  00621021   ADDU V0, V1, V0
9D00A014  A4400036   SH ZERO, 54(V0)
106:                 	pgMotionStats[eMotor].wMSI_ConstantSpeedCount = 0;
9D00A018  3C02A000   LUI V0, -24576
9D00A01C  8FC40008   LW A0, 8(S8)
9D00A020  24030060   ADDIU V1, ZERO, 96
9D00A024  70831802   MUL V1, A0, V1
9D00A028  244204CC   ADDIU V0, V0, 1228
9D00A02C  00621021   ADDU V0, V1, V0
9D00A030  A4400038   SH ZERO, 56(V0)
107:                 	pgMotionStats[eMotor].wMSI_DecelerationCount = 0;
9D00A034  3C02A000   LUI V0, -24576
9D00A038  8FC40008   LW A0, 8(S8)
9D00A03C  24030060   ADDIU V1, ZERO, 96
9D00A040  70831802   MUL V1, A0, V1
9D00A044  244204CC   ADDIU V0, V0, 1228
9D00A048  00621021   ADDU V0, V1, V0
9D00A04C  A440003A   SH ZERO, 58(V0)
108:                 	pgMotionStats[eMotor].wMSI_MinimumPWMCount = 0;
9D00A050  3C02A000   LUI V0, -24576
9D00A054  8FC40008   LW A0, 8(S8)
9D00A058  24030060   ADDIU V1, ZERO, 96
9D00A05C  70831802   MUL V1, A0, V1
9D00A060  244204CC   ADDIU V0, V0, 1228
9D00A064  00621021   ADDU V0, V1, V0
9D00A068  A440003C   SH ZERO, 60(V0)
109:                 	pgMotionStats[eMotor].wMSI_CoastCount = 0;
9D00A06C  3C02A000   LUI V0, -24576
9D00A070  8FC40008   LW A0, 8(S8)
9D00A074  24030060   ADDIU V1, ZERO, 96
9D00A078  70831802   MUL V1, A0, V1
9D00A07C  244204CC   ADDIU V0, V0, 1228
9D00A080  00621021   ADDU V0, V1, V0
9D00A084  A440003E   SH ZERO, 62(V0)
110:                 	pgMotionStats[eMotor].wMSI_TotalCount = 0;
9D00A088  3C02A000   LUI V0, -24576
9D00A08C  8FC40008   LW A0, 8(S8)
9D00A090  24030060   ADDIU V1, ZERO, 96
9D00A094  70831802   MUL V1, A0, V1
9D00A098  244204CC   ADDIU V0, V0, 1228
9D00A09C  00621021   ADDU V0, V1, V0
9D00A0A0  A4400040   SH ZERO, 64(V0)
111:                 
112:                 	pgMotionStats[eMotor].wAccelerationPWMAdjustmentCount = 0;
9D00A0A4  3C02A000   LUI V0, -24576
9D00A0A8  8FC40008   LW A0, 8(S8)
9D00A0AC  24030060   ADDIU V1, ZERO, 96
9D00A0B0  70831802   MUL V1, A0, V1
9D00A0B4  244204CC   ADDIU V0, V0, 1228
9D00A0B8  00621021   ADDU V0, V1, V0
9D00A0BC  A4400042   SH ZERO, 66(V0)
113:                 	pgMotionStats[eMotor].wConstantSpeedPWMAdjustmentCount = 0;
9D00A0C0  3C02A000   LUI V0, -24576
9D00A0C4  8FC40008   LW A0, 8(S8)
9D00A0C8  24030060   ADDIU V1, ZERO, 96
9D00A0CC  70831802   MUL V1, A0, V1
9D00A0D0  244204CC   ADDIU V0, V0, 1228
9D00A0D4  00621021   ADDU V0, V1, V0
9D00A0D8  A4400044   SH ZERO, 68(V0)
114:                 
115:                 	pgMotionStats[eMotor].efStartingEvent = 0;
9D00A0DC  3C02A000   LUI V0, -24576
9D00A0E0  8FC40008   LW A0, 8(S8)
9D00A0E4  24030060   ADDIU V1, ZERO, 96
9D00A0E8  70831802   MUL V1, A0, V1
9D00A0EC  244204CC   ADDIU V0, V0, 1228
9D00A0F0  00621021   ADDU V0, V1, V0
9D00A0F4  A4400052   SH ZERO, 82(V0)
116:                 	pgMotionStats[eMotor].efEndingEvent = 0;
9D00A0F8  3C02A000   LUI V0, -24576
9D00A0FC  8FC40008   LW A0, 8(S8)
9D00A100  24030060   ADDIU V1, ZERO, 96
9D00A104  70831802   MUL V1, A0, V1
9D00A108  244204CC   ADDIU V0, V0, 1228
9D00A10C  00621021   ADDU V0, V1, V0
9D00A110  A4400054   SH ZERO, 84(V0)
117:                 
118:                 	pgMotionStats[eMotor].efAccelerationMotionEvents = 0;
9D00A114  3C02A000   LUI V0, -24576
9D00A118  8FC40008   LW A0, 8(S8)
9D00A11C  24030060   ADDIU V1, ZERO, 96
9D00A120  70831802   MUL V1, A0, V1
9D00A124  244204CC   ADDIU V0, V0, 1228
9D00A128  00621021   ADDU V0, V1, V0
9D00A12C  A4400056   SH ZERO, 86(V0)
119:                 	pgMotionStats[eMotor].efConstantSpeedMotionEvents = 0;
9D00A130  3C02A000   LUI V0, -24576
9D00A134  8FC40008   LW A0, 8(S8)
9D00A138  24030060   ADDIU V1, ZERO, 96
9D00A13C  70831802   MUL V1, A0, V1
9D00A140  244204CC   ADDIU V0, V0, 1228
9D00A144  00621021   ADDU V0, V1, V0
9D00A148  A4400058   SH ZERO, 88(V0)
120:                 	pgMotionStats[eMotor].efDecelerationMotionEvents = 0;
9D00A14C  3C02A000   LUI V0, -24576
9D00A150  8FC40008   LW A0, 8(S8)
9D00A154  24030060   ADDIU V1, ZERO, 96
9D00A158  70831802   MUL V1, A0, V1
9D00A15C  244204CC   ADDIU V0, V0, 1228
9D00A160  00621021   ADDU V0, V1, V0
9D00A164  A440005A   SH ZERO, 90(V0)
121:                 	pgMotionStats[eMotor].efMinimumPWMMotionEvents = 0;
9D00A168  3C02A000   LUI V0, -24576
9D00A16C  8FC40008   LW A0, 8(S8)
9D00A170  24030060   ADDIU V1, ZERO, 96
9D00A174  70831802   MUL V1, A0, V1
9D00A178  244204CC   ADDIU V0, V0, 1228
9D00A17C  00621021   ADDU V0, V1, V0
9D00A180  A440005C   SH ZERO, 92(V0)
122:                 	pgMotionStats[eMotor].efCoastingMotionEvents = 0;
9D00A184  3C02A000   LUI V0, -24576
9D00A188  8FC40008   LW A0, 8(S8)
9D00A18C  24030060   ADDIU V1, ZERO, 96
9D00A190  70831802   MUL V1, A0, V1
9D00A194  244204CC   ADDIU V0, V0, 1228
9D00A198  00621021   ADDU V0, V1, V0
9D00A19C  A440005E   SH ZERO, 94(V0)
123:                 
124:                 	pgwMSI_AccelerationCtr[eMotor] = 0;					// MSI ticks for each of the motion phases
9D00A1A0  3C02A000   LUI V0, -24576
9D00A1A4  8FC30008   LW V1, 8(S8)
9D00A1A8  00031840   SLL V1, V1, 1
9D00A1AC  24420284   ADDIU V0, V0, 644
9D00A1B0  00621021   ADDU V0, V1, V0
9D00A1B4  A4400000   SH ZERO, 0(V0)
125:                 	pgwMSI_ConstantSpeedCtr[eMotor] = 0;
9D00A1B8  3C02A000   LUI V0, -24576
9D00A1BC  8FC30008   LW V1, 8(S8)
9D00A1C0  00031840   SLL V1, V1, 1
9D00A1C4  24420288   ADDIU V0, V0, 648
9D00A1C8  00621021   ADDU V0, V1, V0
9D00A1CC  A4400000   SH ZERO, 0(V0)
126:                 	pgwMSI_DecelerationCtr[eMotor] = 0;
9D00A1D0  3C02A000   LUI V0, -24576
9D00A1D4  8FC30008   LW V1, 8(S8)
9D00A1D8  00031840   SLL V1, V1, 1
9D00A1DC  2442028C   ADDIU V0, V0, 652
9D00A1E0  00621021   ADDU V0, V1, V0
9D00A1E4  A4400000   SH ZERO, 0(V0)
127:                 	pgwMSI_MinimumPWMCtr[eMotor] = 0;
9D00A1E8  3C02A000   LUI V0, -24576
9D00A1EC  8FC30008   LW V1, 8(S8)
9D00A1F0  00031840   SLL V1, V1, 1
9D00A1F4  24420290   ADDIU V0, V0, 656
9D00A1F8  00621021   ADDU V0, V1, V0
9D00A1FC  A4400000   SH ZERO, 0(V0)
128:                 	pgwMSI_CoastCtr[eMotor] = 0;
9D00A200  3C02A000   LUI V0, -24576
9D00A204  8FC30008   LW V1, 8(S8)
9D00A208  00031840   SLL V1, V1, 1
9D00A20C  24420294   ADDIU V0, V0, 660
9D00A210  00621021   ADDU V0, V1, V0
9D00A214  A4400000   SH ZERO, 0(V0)
129:                 	pgwMoveTotalMSICtr[eMotor] = 0;
9D00A218  3C02A000   LUI V0, -24576
9D00A21C  8FC30008   LW V1, 8(S8)
9D00A220  00031840   SLL V1, V1, 1
9D00A224  244202B8   ADDIU V0, V0, 696
9D00A228  00621021   ADDU V0, V1, V0
9D00A22C  A4400000   SH ZERO, 0(V0)
130:                 
131:                 	pgMotionStats[eMotor].wStartTime = 0;									// timer snapshots
9D00A230  3C02A000   LUI V0, -24576
9D00A234  8FC40008   LW A0, 8(S8)
9D00A238  24030060   ADDIU V1, ZERO, 96
9D00A23C  70831802   MUL V1, A0, V1
9D00A240  244204CC   ADDIU V0, V0, 1228
9D00A244  00621021   ADDU V0, V1, V0
9D00A248  A4400046   SH ZERO, 70(V0)
132:                 	pgMotionStats[eMotor].wAccelerationEndTime = 0;
9D00A24C  3C02A000   LUI V0, -24576
9D00A250  8FC40008   LW A0, 8(S8)
9D00A254  24030060   ADDIU V1, ZERO, 96
9D00A258  70831802   MUL V1, A0, V1
9D00A25C  244204CC   ADDIU V0, V0, 1228
9D00A260  00621021   ADDU V0, V1, V0
9D00A264  A4400048   SH ZERO, 72(V0)
133:                 	pgMotionStats[eMotor].wConstantSpeedEndTime = 0;
9D00A268  3C02A000   LUI V0, -24576
9D00A26C  8FC40008   LW A0, 8(S8)
9D00A270  24030060   ADDIU V1, ZERO, 96
9D00A274  70831802   MUL V1, A0, V1
9D00A278  244204CC   ADDIU V0, V0, 1228
9D00A27C  00621021   ADDU V0, V1, V0
9D00A280  A440004A   SH ZERO, 74(V0)
134:                 	pgMotionStats[eMotor].wDecelerationEndTime = 0;
9D00A284  3C02A000   LUI V0, -24576
9D00A288  8FC40008   LW A0, 8(S8)
9D00A28C  24030060   ADDIU V1, ZERO, 96
9D00A290  70831802   MUL V1, A0, V1
9D00A294  244204CC   ADDIU V0, V0, 1228
9D00A298  00621021   ADDU V0, V1, V0
9D00A29C  A440004C   SH ZERO, 76(V0)
135:                 	pgMotionStats[eMotor].wMinimumPWMEndTime = 0;
9D00A2A0  3C02A000   LUI V0, -24576
9D00A2A4  8FC40008   LW A0, 8(S8)
9D00A2A8  24030060   ADDIU V1, ZERO, 96
9D00A2AC  70831802   MUL V1, A0, V1
9D00A2B0  244204CC   ADDIU V0, V0, 1228
9D00A2B4  00621021   ADDU V0, V1, V0
9D00A2B8  A440004E   SH ZERO, 78(V0)
136:                 	pgMotionStats[eMotor].wCoastEndTime = 0;
9D00A2BC  3C02A000   LUI V0, -24576
9D00A2C0  8FC40008   LW A0, 8(S8)
9D00A2C4  24030060   ADDIU V1, ZERO, 96
9D00A2C8  70831802   MUL V1, A0, V1
9D00A2CC  244204CC   ADDIU V0, V0, 1228
9D00A2D0  00621021   ADDU V0, V1, V0
9D00A2D4  A4400050   SH ZERO, 80(V0)
137:                 
138:                 // see MotionFSM.h	pgMotionStats[eMotor].eMoveType = MOVE_NONE;
139:                 
140:                 }
9D00A2D8  03C0E821   ADDU SP, S8, ZERO
9D00A2DC  8FBE0004   LW S8, 4(SP)
9D00A2E0  27BD0008   ADDIU SP, SP, 8
9D00A2E4  03E00008   JR RA
9D00A2E8  00000000   NOP
141:                 
142:                 // copy global data to MotionStats structure, and clean up some values..
143:                 
144:                 void Finish_MotionStats(enum tagMotors eMotor)
145:                 {
9D00A2EC  27BDFFF8   ADDIU SP, SP, -8
9D00A2F0  AFBE0004   SW S8, 4(SP)
9D00A2F4  03A0F021   ADDU S8, SP, ZERO
9D00A2F8  AFC40008   SW A0, 8(S8)
146:                 
147:                 	pgMotionStats[eMotor].ePWMDirection = pgePWMDirection[eMotor];
9D00A2FC  3C02A000   LUI V0, -24576
9D00A300  8FC30008   LW V1, 8(S8)
9D00A304  00031880   SLL V1, V1, 2
9D00A308  2442020C   ADDIU V0, V0, 524
9D00A30C  00621021   ADDU V0, V1, V0
9D00A310  8C430000   LW V1, 0(V0)
9D00A314  3C02A000   LUI V0, -24576
9D00A318  8FC50008   LW A1, 8(S8)
9D00A31C  24040060   ADDIU A0, ZERO, 96
9D00A320  70A42002   MUL A0, A1, A0
9D00A324  244204CC   ADDIU V0, V0, 1228
9D00A328  00821021   ADDU V0, A0, V0
9D00A32C  AC430000   SW V1, 0(V0)
148:                 	pgMotionStats[eMotor].nEndingPosition = pgnCurrentPosition[eMotor];
9D00A330  3C02A000   LUI V0, -24576
9D00A334  8FC30008   LW V1, 8(S8)
9D00A338  00031880   SLL V1, V1, 2
9D00A33C  244202AC   ADDIU V0, V0, 684
9D00A340  00621021   ADDU V0, V1, V0
9D00A344  8C430000   LW V1, 0(V0)
9D00A348  3C02A000   LUI V0, -24576
9D00A34C  8FC50008   LW A1, 8(S8)
9D00A350  24040060   ADDIU A0, ZERO, 96
9D00A354  70A42002   MUL A0, A1, A0
9D00A358  244204CC   ADDIU V0, V0, 1228
9D00A35C  00821021   ADDU V0, A0, V0
9D00A360  AC430008   SW V1, 8(V0)
149:                 	pgMotionStats[eMotor].nDistance = pgMotionStats[eMotor].nEndingPosition - pgMotionStats[eMotor].nStartingPosition;
9D00A364  3C02A000   LUI V0, -24576
9D00A368  8FC40008   LW A0, 8(S8)
9D00A36C  24030060   ADDIU V1, ZERO, 96
9D00A370  70831802   MUL V1, A0, V1
9D00A374  244204CC   ADDIU V0, V0, 1228
9D00A378  00621021   ADDU V0, V1, V0
9D00A37C  8C430008   LW V1, 8(V0)
9D00A380  3C02A000   LUI V0, -24576
9D00A384  8FC50008   LW A1, 8(S8)
9D00A388  244404CC   ADDIU A0, V0, 1228
9D00A38C  24020060   ADDIU V0, ZERO, 96
9D00A390  70A21002   MUL V0, A1, V0
9D00A394  00821021   ADDU V0, A0, V0
9D00A398  8C420004   LW V0, 4(V0)
9D00A39C  00621823   SUBU V1, V1, V0
9D00A3A0  3C02A000   LUI V0, -24576
9D00A3A4  8FC50008   LW A1, 8(S8)
9D00A3A8  244404CC   ADDIU A0, V0, 1228
9D00A3AC  24020060   ADDIU V0, ZERO, 96
9D00A3B0  70A21002   MUL V0, A1, V0
9D00A3B4  00821021   ADDU V0, A0, V0
9D00A3B8  AC43000C   SW V1, 12(V0)
150:                 
151:                 	pgMotionStats[eMotor].wLastMotionStallTimer = pgwLastMotionStallTimer[eMotor];
9D00A3BC  3C02A000   LUI V0, -24576
9D00A3C0  8FC30008   LW V1, 8(S8)
9D00A3C4  00031840   SLL V1, V1, 1
9D00A3C8  244202C0   ADDIU V0, V0, 704
9D00A3CC  00621021   ADDU V0, V1, V0
9D00A3D0  94430000   LHU V1, 0(V0)
9D00A3D4  3C02A000   LUI V0, -24576
9D00A3D8  8FC50008   LW A1, 8(S8)
9D00A3DC  24040060   ADDIU A0, ZERO, 96
9D00A3E0  70A42002   MUL A0, A1, A0
9D00A3E4  244204CC   ADDIU V0, V0, 1228
9D00A3E8  00821021   ADDU V0, A0, V0
9D00A3EC  A4430034   SH V1, 52(V0)
152:                 	#ifdef CALC_AVERAGE_SPEED
153:                 		pgMotionStats[eMotor].wAverageSpeed = pgwAverageSpeed[eMotor];
154:                 	#endif
155:                 
156:                 	pgMotionStats[eMotor].wMSI_AccelerationCount = pgwMSI_AccelerationCtr[eMotor];
9D00A3F0  3C02A000   LUI V0, -24576
9D00A3F4  8FC30008   LW V1, 8(S8)
9D00A3F8  00031840   SLL V1, V1, 1
9D00A3FC  24420284   ADDIU V0, V0, 644
9D00A400  00621021   ADDU V0, V1, V0
9D00A404  94430000   LHU V1, 0(V0)
9D00A408  3C02A000   LUI V0, -24576
9D00A40C  8FC50008   LW A1, 8(S8)
9D00A410  24040060   ADDIU A0, ZERO, 96
9D00A414  70A42002   MUL A0, A1, A0
9D00A418  244204CC   ADDIU V0, V0, 1228
9D00A41C  00821021   ADDU V0, A0, V0
9D00A420  A4430036   SH V1, 54(V0)
157:                 	pgMotionStats[eMotor].wMSI_ConstantSpeedCount = pgwMSI_ConstantSpeedCtr[eMotor];
9D00A424  3C02A000   LUI V0, -24576
9D00A428  8FC30008   LW V1, 8(S8)
9D00A42C  00031840   SLL V1, V1, 1
9D00A430  24420288   ADDIU V0, V0, 648
9D00A434  00621021   ADDU V0, V1, V0
9D00A438  94430000   LHU V1, 0(V0)
9D00A43C  3C02A000   LUI V0, -24576
9D00A440  8FC50008   LW A1, 8(S8)
9D00A444  24040060   ADDIU A0, ZERO, 96
9D00A448  70A42002   MUL A0, A1, A0
9D00A44C  244204CC   ADDIU V0, V0, 1228
9D00A450  00821021   ADDU V0, A0, V0
9D00A454  A4430038   SH V1, 56(V0)
158:                 	pgMotionStats[eMotor].wMSI_DecelerationCount = pgwMSI_DecelerationCtr[eMotor];
9D00A458  3C02A000   LUI V0, -24576
9D00A45C  8FC30008   LW V1, 8(S8)
9D00A460  00031840   SLL V1, V1, 1
9D00A464  2442028C   ADDIU V0, V0, 652
9D00A468  00621021   ADDU V0, V1, V0
9D00A46C  94430000   LHU V1, 0(V0)
9D00A470  3C02A000   LUI V0, -24576
9D00A474  8FC50008   LW A1, 8(S8)
9D00A478  24040060   ADDIU A0, ZERO, 96
9D00A47C  70A42002   MUL A0, A1, A0
9D00A480  244204CC   ADDIU V0, V0, 1228
9D00A484  00821021   ADDU V0, A0, V0
9D00A488  A443003A   SH V1, 58(V0)
159:                 	pgMotionStats[eMotor].wMSI_MinimumPWMCount = pgwMSI_MinimumPWMCtr[eMotor];
9D00A48C  3C02A000   LUI V0, -24576
9D00A490  8FC30008   LW V1, 8(S8)
9D00A494  00031840   SLL V1, V1, 1
9D00A498  24420290   ADDIU V0, V0, 656
9D00A49C  00621021   ADDU V0, V1, V0
9D00A4A0  94430000   LHU V1, 0(V0)
9D00A4A4  3C02A000   LUI V0, -24576
9D00A4A8  8FC50008   LW A1, 8(S8)
9D00A4AC  24040060   ADDIU A0, ZERO, 96
9D00A4B0  70A42002   MUL A0, A1, A0
9D00A4B4  244204CC   ADDIU V0, V0, 1228
9D00A4B8  00821021   ADDU V0, A0, V0
9D00A4BC  A443003C   SH V1, 60(V0)
160:                 	pgMotionStats[eMotor].wMSI_CoastCount = pgwMSI_CoastCtr[eMotor];
9D00A4C0  3C02A000   LUI V0, -24576
9D00A4C4  8FC30008   LW V1, 8(S8)
9D00A4C8  00031840   SLL V1, V1, 1
9D00A4CC  24420294   ADDIU V0, V0, 660
9D00A4D0  00621021   ADDU V0, V1, V0
9D00A4D4  94430000   LHU V1, 0(V0)
9D00A4D8  3C02A000   LUI V0, -24576
9D00A4DC  8FC50008   LW A1, 8(S8)
9D00A4E0  24040060   ADDIU A0, ZERO, 96
9D00A4E4  70A42002   MUL A0, A1, A0
9D00A4E8  244204CC   ADDIU V0, V0, 1228
9D00A4EC  00821021   ADDU V0, A0, V0
9D00A4F0  A443003E   SH V1, 62(V0)
161:                 	pgMotionStats[eMotor].wMSI_TotalCount = pgwMoveTotalMSICtr[eMotor];
9D00A4F4  3C02A000   LUI V0, -24576
9D00A4F8  8FC30008   LW V1, 8(S8)
9D00A4FC  00031840   SLL V1, V1, 1
9D00A500  244202B8   ADDIU V0, V0, 696
9D00A504  00621021   ADDU V0, V1, V0
9D00A508  94430000   LHU V1, 0(V0)
9D00A50C  3C02A000   LUI V0, -24576
9D00A510  8FC50008   LW A1, 8(S8)
9D00A514  24040060   ADDIU A0, ZERO, 96
9D00A518  70A42002   MUL A0, A1, A0
9D00A51C  244204CC   ADDIU V0, V0, 1228
9D00A520  00821021   ADDU V0, A0, V0
9D00A524  A4430040   SH V1, 64(V0)
162:                 
163:                 //	pgMotionStats[eMotor].bSpeedlMotionIndex = pgbMotionProfileSpeedIndex;
164:                 
165:                 	// adjust times; some segments may not occur
166:                 	if (pgMotionStats[eMotor].wConstantSpeedEndTime IS (WORD)0)
9D00A528  3C02A000   LUI V0, -24576
9D00A52C  8FC40008   LW A0, 8(S8)
9D00A530  24030060   ADDIU V1, ZERO, 96
9D00A534  70831802   MUL V1, A0, V1
9D00A538  244204CC   ADDIU V0, V0, 1228
9D00A53C  00621021   ADDU V0, V1, V0
9D00A540  9442004A   LHU V0, 74(V0)
9D00A544  1440000F   BNE V0, ZERO, 0x9D00A584
9D00A548  00000000   NOP
167:                 		pgMotionStats[eMotor].wConstantSpeedEndTime = pgMotionStats[eMotor].wAccelerationEndTime;
9D00A54C  3C02A000   LUI V0, -24576
9D00A550  8FC40008   LW A0, 8(S8)
9D00A554  24030060   ADDIU V1, ZERO, 96
9D00A558  70831802   MUL V1, A0, V1
9D00A55C  244204CC   ADDIU V0, V0, 1228
9D00A560  00621021   ADDU V0, V1, V0
9D00A564  94430048   LHU V1, 72(V0)
9D00A568  3C02A000   LUI V0, -24576
9D00A56C  8FC50008   LW A1, 8(S8)
9D00A570  24040060   ADDIU A0, ZERO, 96
9D00A574  70A42002   MUL A0, A1, A0
9D00A578  244204CC   ADDIU V0, V0, 1228
9D00A57C  00821021   ADDU V0, A0, V0
9D00A580  A443004A   SH V1, 74(V0)
168:                 
169:                 	if (pgMotionStats[eMotor].wDecelerationEndTime IS (WORD)0)
9D00A584  3C02A000   LUI V0, -24576
9D00A588  8FC40008   LW A0, 8(S8)
9D00A58C  24030060   ADDIU V1, ZERO, 96
9D00A590  70831802   MUL V1, A0, V1
9D00A594  244204CC   ADDIU V0, V0, 1228
9D00A598  00621021   ADDU V0, V1, V0
9D00A59C  9442004C   LHU V0, 76(V0)
9D00A5A0  1440000F   BNE V0, ZERO, 0x9D00A5E0
9D00A5A4  00000000   NOP
170:                 		pgMotionStats[eMotor].wDecelerationEndTime = pgMotionStats[eMotor].wConstantSpeedEndTime;
9D00A5A8  3C02A000   LUI V0, -24576
9D00A5AC  8FC40008   LW A0, 8(S8)
9D00A5B0  24030060   ADDIU V1, ZERO, 96
9D00A5B4  70831802   MUL V1, A0, V1
9D00A5B8  244204CC   ADDIU V0, V0, 1228
9D00A5BC  00621021   ADDU V0, V1, V0
9D00A5C0  9443004A   LHU V1, 74(V0)
9D00A5C4  3C02A000   LUI V0, -24576
9D00A5C8  8FC50008   LW A1, 8(S8)
9D00A5CC  24040060   ADDIU A0, ZERO, 96
9D00A5D0  70A42002   MUL A0, A1, A0
9D00A5D4  244204CC   ADDIU V0, V0, 1228
9D00A5D8  00821021   ADDU V0, A0, V0
9D00A5DC  A443004C   SH V1, 76(V0)
171:                 
172:                 	if (pgMotionStats[eMotor].wMinimumPWMEndTime IS (WORD)0)
9D00A5E0  3C02A000   LUI V0, -24576
9D00A5E4  8FC40008   LW A0, 8(S8)
9D00A5E8  24030060   ADDIU V1, ZERO, 96
9D00A5EC  70831802   MUL V1, A0, V1
9D00A5F0  244204CC   ADDIU V0, V0, 1228
9D00A5F4  00621021   ADDU V0, V1, V0
9D00A5F8  9442004E   LHU V0, 78(V0)
9D00A5FC  1440000F   BNE V0, ZERO, 0x9D00A63C
9D00A600  00000000   NOP
173:                 		pgMotionStats[eMotor].wMinimumPWMEndTime = pgMotionStats[eMotor].wDecelerationEndTime;
9D00A604  3C02A000   LUI V0, -24576
9D00A608  8FC40008   LW A0, 8(S8)
9D00A60C  24030060   ADDIU V1, ZERO, 96
9D00A610  70831802   MUL V1, A0, V1
9D00A614  244204CC   ADDIU V0, V0, 1228
9D00A618  00621021   ADDU V0, V1, V0
9D00A61C  9443004C   LHU V1, 76(V0)
9D00A620  3C02A000   LUI V0, -24576
9D00A624  8FC50008   LW A1, 8(S8)
9D00A628  24040060   ADDIU A0, ZERO, 96
9D00A62C  70A42002   MUL A0, A1, A0
9D00A630  244204CC   ADDIU V0, V0, 1228
9D00A634  00821021   ADDU V0, A0, V0
9D00A638  A443004E   SH V1, 78(V0)
174:                 
175:                 	if (pgMotionStats[eMotor].wCoastEndTime IS (WORD)0)
9D00A63C  3C02A000   LUI V0, -24576
9D00A640  8FC40008   LW A0, 8(S8)
9D00A644  24030060   ADDIU V1, ZERO, 96
9D00A648  70831802   MUL V1, A0, V1
9D00A64C  244204CC   ADDIU V0, V0, 1228
9D00A650  00621021   ADDU V0, V1, V0
9D00A654  94420050   LHU V0, 80(V0)
9D00A658  1440000F   BNE V0, ZERO, 0x9D00A698
9D00A65C  00000000   NOP
176:                 		pgMotionStats[eMotor].wCoastEndTime  = pgMotionStats[eMotor].wMinimumPWMEndTime;
9D00A660  3C02A000   LUI V0, -24576
9D00A664  8FC40008   LW A0, 8(S8)
9D00A668  24030060   ADDIU V1, ZERO, 96
9D00A66C  70831802   MUL V1, A0, V1
9D00A670  244204CC   ADDIU V0, V0, 1228
9D00A674  00621021   ADDU V0, V1, V0
9D00A678  9443004E   LHU V1, 78(V0)
9D00A67C  3C02A000   LUI V0, -24576
9D00A680  8FC50008   LW A1, 8(S8)
9D00A684  24040060   ADDIU A0, ZERO, 96
9D00A688  70A42002   MUL A0, A1, A0
9D00A68C  244204CC   ADDIU V0, V0, 1228
9D00A690  00821021   ADDU V0, A0, V0
9D00A694  A4430050   SH V1, 80(V0)
177:                 
178:                 // see MotionFSM.h	pgMotionStats[eMotor].eMoveType = eMoveType;
179:                 
180:                 }
9D00A698  03C0E821   ADDU SP, S8, ZERO
9D00A69C  8FBE0004   LW S8, 4(SP)
9D00A6A0  27BD0008   ADDIU SP, SP, 8
9D00A6A4  03E00008   JR RA
9D00A6A8  00000000   NOP
181:                 
182:                 
183:                 #ifdef MOTION_ERROR_TABLE
184:                 	void ClearMotionErrorTable()
185:                 	{
186:                 		BYTE i;
187:                 	
188:                 		for (i = 0; i < SPEED_ERROR_TABLE_LEN; i++)
189:                 			{
190:                 			pgnMotionProfileSpeedError[i] = 0;
191:                 			}
192:                 	
193:                 	}
194:                 #endif
195:                 
196:                 // end of MotionStats.c
197:                 
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/MotionSensor.c  ------------------
1:                   //*************************************************************************************************
2:                   //									M o t i o n S e n s o r . c
3:                   //*************************************************************************************************
4:                   //		Project:	SmartTrak Solar Panel Controller
5:                   //
6:                   //		Contains:	Motion Sensor measure, read functions, for 2 axis
7:                   //
8:                   //		001	15 Mar 13 <sek> created from gsf Code Base
9:                   //		002	18 Mar 13 <sek> disabling Motion Capture interrupts clears Input Capture FIFOS
10:                  //
11:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
12:                  //					gsf Engineering	978-927-7189
13:                  //					Beverly, MA 01915
14:                  //
15:                  //		copyright (c) 2013 gsf Engineering
16:                  //
17:                  //*************************************************************************************************
18:                  
19:                  // some of this code is derived from the Microchip example code incap_capture_event.c
20:                  // which, like most Microchip demo code, was full of errors
21:                  
22:                  //-------------------------------------------------------------------------------------------------------
23:                  //	Include Files
24:                  //-------------------------------------------------------------------------------------------------------
25:                  #include <GenericTypeDefs.h>
26:                  
27:                  //lint -e765					error 765: (Info -- external function could be made static)
28:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
29:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
30:                  #include <legacy\int_3xx_4xx_legacy.h>	// required for Input Capture interrupt handlers
31:                  //lint +e14
32:                  
33:                  //#include <string.h>				// Microchip string functions
34:                  								// see hlpC18.chm online help for so-called documentation
35:                  //#include <ctype.h>				// tolower()
36:                  
37:                  #include "gsfstd.h"				// gsf standard #defines
38:                  //#include "init.h"				// port definitions and initialization state
39:                  #include "Debug.h"
40:                  #include "SmartTrak.h"			// Project wide definitions
41:                  #include "HardwareProfile.h"
42:                  
43:                  #include "EventFlags.h"			// event flag definitions and globals
44:                  #include "MotorPWM.h"			// Motor PWM function prototypes and definitions
45:                  #include "MotionSensor.h"		// Hall Effect Motion Sensor (Quadrature Encoder) function prototypes and definitions
46:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
47:                  //#include "ADCRead.h"			// adc access functions
48:                  
49:                  #include "MenuFSM.h"
50:                  //#include "CommandFSM.h"			// Movement Command FSM functions
51:                  #include "MotionFSM.h"			// Motion FSM functions, MotionType enum
52:                  //#include "MotionLimits.h"
53:                  #include "MotionStats.h"		// motion statistics for reporting
54:                  //#include "MotionProfile.h"		// motion data table
55:                  
56:                  #include "Stubs.h"
57:                  
58:                  #ifdef DEFINE_GLOBALS
59:                  	#error "DEFINE_GLOBALS not expected here"
60:                  #endif
61:                  
62:                  
63:                  //-------------------------------------------------------------------------------------------------------
64:                  // Definitions
65:                  //-------------------------------------------------------------------------------------------------------
66:                  
67:                  enum tagMotionSensorErrors
68:                  {
69:                  	MTN_SENSOR_ERROR_NONE = MTN_SENSOR_ERROR_BASE,
70:                  	MTN_SENSOR_ERROR_UNEXPECTED_TICK,			// 1 unexpected sensor tick event
71:                  	MTN_SENSOR_ERROR_UNEXPECTED_EVENT,			// 2 unexpected event
72:                  	MTN_SENSOR_ERROR_INVALID_STATE,				// 3 not a valid state
73:                  	MTN_SENSOR_ERROR_INVALID_SUBSTATE,			// 4 not a valid state
74:                  	MTN_SENSOR_ERROR_INVALID_MOTION_PHASE,		// 5 motion phase not valid during interrupt
75:                  	MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK,	// 6 motion type not valid during interrupt
76:                  	MTN_SENSOR_ERROR_COASTING_INT,				// 7 interrupt generated during coasting
77:                  	MTN_SENSOR_ERROR_FOREGROUND_TICK_OVERRUN,	// 8 foreground tick processing overrun
78:                  	MTN_SENSOR_ERROR_MSI_COUNT_DONE_OVERRUN,	// 9 event overrun
79:                  	MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_INT,	// A motion type not valid during interrupt
80:                  	MTN_SENSOR_ERROR_NO_EVENT_GENERATED,		// B no event generated during MotionSensor_Tick()
81:                  	MTN_SENSOR_ERROR_INVALID_AXIS,				// C no event generated during MotionSensor_Tick()
82:                  	MTN_SENSOR_ERROR_UNEXPECTED_INT	,			// D unexpected sensor tick event
83:                  
84:                  	MTN_SENSOR_UNPROCESSED_EVENT = MTN_SENSOR_ERROR_BASE + 0x0F
85:                  };
86:                  
87:                  
88:                  //-------------------------------------------------------------------------------------------------------
89:                  // File-Global Data Definitions
90:                  //-------------------------------------------------------------------------------------------------------
91:                  
92:                  PRIVATE_INIT WORD	fgwLastTimerValue[NUM_MOTORS] = {0xFFFF, 0xFFFF};
93:                  
94:                  #ifdef CALC_AVERAGE_SPEED
95:                  	PRIVATE_INIT WORD	fgwSumOfSpeeds[NUM_MOTORS] = {0, 0};
96:                  	PRIVATE_INIT WORD	fgwSampleCtr[NUM_MOTORS] = {0, 0};
97:                  	PRIVATE_INIT WORD	fgwLastSpeed[NUM_MOTORS] = {0, 0};
98:                  #endif
99:                  
100:                 PRIVATE_INIT WORD	fgwExpectedSpeed[NUM_MOTORS] = {0, 0};
101:                 
102:                 void MotionSensorInterruptHandler(enum tagMotors eMotor);
103:                 
104:                 
105:                 //*****************************************************************************
106:                 //					M o t i o n S e n s o r _ I n i t ( )
107:                 //*****************************************************************************
108:                 
109:                 void MotionSensor_Init(void)
110:                 {
9D006710  27BDFFE8   ADDIU SP, SP, -24
9D006714  AFBF0014   SW RA, 20(SP)
9D006718  AFBE0010   SW S8, 16(SP)
9D00671C  03A0F021   ADDU S8, SP, ZERO
111:                 
112:                 	// ********************************
113:                 	//		Enable Interrupts
114:                 	// ********************************
115:                 
116:                 	// clear any pending interrupt requests
117:                 	mIC1ClearIntFlag();
9D006720  3C02BF88   LUI V0, -16504
9D006724  24030020   ADDIU V1, ZERO, 32
9D006728  AC431034   SW V1, 4148(V0)
118:                 	mIC2ClearIntFlag();
9D00672C  3C02BF88   LUI V0, -16504
9D006730  24030200   ADDIU V1, ZERO, 512
9D006734  AC431034   SW V1, 4148(V0)
119:                 
120:                 	// Setup Timer 3
121:                 	//	Timer 3 ON
122:                 	//	Divide by 256 (note timer input is 80MHZ; sample code was 10MHZ)
123:                 	//  Internal source
124:                 	// This should provide a tick of 0.5mS. The shortest Input Capture cycle we are likely to measure is 15mS
125:                 
126:                 	//		   <<-------------T3CON------------->>   PR3	TMR3 = 0
127:                     OpenTimer3(T3_ON | T3_PS_1_256 | T3_SOURCE_INT, 0xFFFF);
9D006738  3C02BF80   LUI V0, -16512
9D00673C  24030070   ADDIU V1, ZERO, 112
9D006740  AC430A00   SW V1, 2560(V0)
9D006744  3C02BF80   LUI V0, -16512
9D006748  AC400A10   SW ZERO, 2576(V0)
9D00674C  3C02BF80   LUI V0, -16512
9D006750  3403FFFF   ORI V1, ZERO, -1
9D006754  AC430A20   SW V1, 2592(V0)
9D006758  3C02BF80   LUI V0, -16512
9D00675C  34038000   ORI V1, ZERO, -32768
9D006760  AC430A08   SW V1, 2568(V0)
128:                 
129:                 	// Set I/O pin direction
130:                 	// from PIC32 Family Reference Manual Section 15. Input Capture page 15-18:
131:                 	// When the Input Capture module is enabled, the user application must ensure that the I/O pin
132:                 	//		direction is configured for an input by setting the associated TRIS bit. The pin direction is not set
133:                 	//		when the Input Capture module is enabled. Furthermore, all other peripherals multiplexed with
134:                 	//		the input pin must be disabled.
135:                 	//	IC1: RD8
136:                 	//	IC2: RD9
137:                 	InitMotionSensorPins();
138:                 
139:                 	// Enable Input Capture Modules 1,2
140:                 	// - IC_EVERY_RISE_EDGE		Capture Every RISING edge
141:                 	// - IC_CAP_16BIT			16 bit counter
142:                 	// - IC_INT_1CAPTURE		Enable capture interrupts on each capture
143:                 	// - IC_TIMER3_SRC			Use Timer 3 source
144:                 	// - IC_FEDGE_RISE			Capture rising edge first
145:                 	// - IC_IDLE_STOP			IC stop in sleep mode (debug?)
146:                 	// - IC_ON					input capture ON
147:                 	OpenCapture1(IC_EVERY_RISE_EDGE | IC_CAP_16BIT | IC_INT_1CAPTURE | IC_TIMER3_SRC | IC_FEDGE_RISE | IC_ON);
9D006784  3C02BF80   LUI V0, -16512
9D006788  34038203   ORI V1, ZERO, -32253
9D00678C  AC432000   SW V1, 8192(V0)
148:                 	OpenCapture2(IC_EVERY_RISE_EDGE | IC_CAP_16BIT | IC_INT_1CAPTURE | IC_TIMER3_SRC | IC_FEDGE_RISE | IC_ON);
9D006790  3C02BF80   LUI V0, -16512
9D006794  34038203   ORI V1, ZERO, -32253
9D006798  AC432200   SW V1, 8704(V0)
149:                 
150:                 	// ==>> kludge until MotionFSM() is in place
151:                 	pgeMotionPhase[MOTOR_AZIMUTH] = PHASE_CONSTANT_SPEED;
9D00679C  3C02A000   LUI V0, -24576
9D0067A0  24030003   ADDIU V1, ZERO, 3
9D0067A4  AC430274   SW V1, 628(V0)
152:                 	pgeMotionPhase[MOTOR_ELEVATION] = PHASE_CONSTANT_SPEED;
9D0067A8  3C02A000   LUI V0, -24576
9D0067AC  24420274   ADDIU V0, V0, 628
9D0067B0  24030003   ADDIU V1, ZERO, 3
9D0067B4  AC430004   SW V1, 4(V0)
153:                 
154:                 	// Input Capture interrupts are enabled when PWM configuration changes and starts motion
155:                 
156:                 }
9D0067B8  03C0E821   ADDU SP, S8, ZERO
9D0067BC  8FBF0014   LW RA, 20(SP)
9D0067C0  8FBE0010   LW S8, 16(SP)
9D0067C4  27BD0018   ADDIU SP, SP, 24
9D0067C8  03E00008   JR RA
9D0067CC  00000000   NOP
157:                 
158:                 //*****************************************************************************
159:                 //					M o t i o n S e n s o r _ T i c k ( )
160:                 //*****************************************************************************
161:                 // called from the foreground loop to process the current speed and generate PWM change flags
162:                 
163:                 void MotionSensor_Tick(enum tagMotors eMotor)
164:                 {
9D0067D0  27BDFFE8   ADDIU SP, SP, -24
9D0067D4  AFBF0014   SW RA, 20(SP)
9D0067D8  AFBE0010   SW S8, 16(SP)
9D0067DC  03A0F021   ADDU S8, SP, ZERO
9D0067E0  AFC40018   SW A0, 24(S8)
165:                 
166:                 	// make sure the expected calling flag is in fact SET
167:                 	if (IS_BITCLEAR(efMotionSensorEvents[eMotor], EF_MOTION_SENSOR_TICK))
9D0067E4  3C02A000   LUI V0, -24576
9D0067E8  8FC30018   LW V1, 24(S8)
9D0067EC  00031840   SLL V1, V1, 1
9D0067F0  244202C8   ADDIU V0, V0, 712
9D0067F4  00621021   ADDU V0, V1, V0
9D0067F8  94420000   LHU V0, 0(V0)
9D0067FC  30420002   ANDI V0, V0, 2
9D006800  14400004   BNE V0, ZERO, 0x9D006814
9D006804  00000000   NOP
168:                 		{
169:                 		RuntimeError(MTN_SENSOR_ERROR_UNEXPECTED_TICK);
9D006808  24040091   ADDIU A0, ZERO, 145
9D00680C  0F40365E   JAL _RuntimeError
9D006810  00000000   NOP
170:                 		}
171:                 
172:                 	// clear the calling event flag
173:                 	BITCLEAR(efMotionSensorEvents[eMotor], EF_MOTION_SENSOR_TICK);
9D006814  3C02A000   LUI V0, -24576
9D006818  8FC30018   LW V1, 24(S8)
9D00681C  00031840   SLL V1, V1, 1
9D006820  244202C8   ADDIU V0, V0, 712
9D006824  00621021   ADDU V0, V1, V0
9D006828  94430000   LHU V1, 0(V0)
9D00682C  2402FFFD   ADDIU V0, ZERO, -3
9D006830  00621024   AND V0, V1, V0
9D006834  3043FFFF   ANDI V1, V0, -1
9D006838  3C02A000   LUI V0, -24576
9D00683C  8FC40018   LW A0, 24(S8)
9D006840  00042040   SLL A0, A0, 1
9D006844  244202C8   ADDIU V0, V0, 712
9D006848  00821021   ADDU V0, A0, V0
9D00684C  A4430000   SH V1, 0(V0)
174:                 
175:                 #ifdef NOTDEF
176:                 
177:                 #ifdef NOTDEF
178:                 	// check for End-of-Travel OUT sensor, only relevant when moving OUT
179:                 	if ((ADC_ReadValue(ADC_CH_EOT_OUT) < ADC_EOT_THRESHOLD) AND pgePWMDirection IS PWM_DIR_REVERSE)
180:                 		{
181:                 		// we are moving OUT over the EOT sensor, so tell the Motion FSM to STOP
182:                 		BITSET(efMotionEvents[eMotor], EF_MOTION_END_OF_TRAVEL);
183:                 
184:                 		// Motion FSM will report STOPPED up to the Command FSM
185:                 		}
186:                 #endif
187:                 
188:                 	// speed handling depends on the motion phase
189:                 	switch(pgeMotionPhase[eMotor])
190:                 		{
191:                 		case PHASE_STOPPED:					// motion has actually STOPPED (Motion sensor tick timeout), includes STALLED
192:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_PHASE);
193:                 			break;
194:                 
195:                 		case PHASE_ACCELERATION:			// accelerating speed
196:                 			switch(pgeMotionType[eMotor])
197:                 				{
198:                 				case MOTION_STARTING:
199:                 					// this is the FIRST MSI tick after starting up, so we cannot do any calculations yet
200:                 					// pgMotionStats.wAccelerationPWMAdjustmentCount = 0;
201:                 
202:                 					// in acceleration, every MSI tick results in a PWM value update
203:                 					BITSET(efMotionEvents[eMotor], EF_MOTION_PWM_UPDATE);
204:                 
205:                 					// we have now gone through ONE MSI interrupt and ONE MSI Tick routine, so on the NEXT MSI Tick, we can process the measured speed
206:                 					pgeMotionType[eMotor] = MOTION_POWERED;
207:                 					break;
208:                 
209:                 				case MOTION_POWERED:
210:                 					// we have been in motion, so we can calculate speed
211:                 					// we are NOW past the very first MSI tick, for which we do NOT have any speed info
212:                 
213:                 					// bump index into motion profile table of expected speed values
214:                 					// calculate new motion profile index, and look expected speed value (in Tcy counts)
215:                 					if (pgbMotionProfileSpeedIndex <= (pgbMotionProfileIndexMax - pgbMotionProfileIndexIncrement))
216:                 						{
217:                 						// bump motion profile table index
218:                 						pgbMotionProfileSpeedIndex += pgbMotionProfileIndexIncrement;
219:                 
220:                 						// read expected speed from motion profile table
221:                 						fgwExpectedSpeed = MotionProfileSpeedAndPWM[(pgbMotionProfileSpeedIndex * 2) + MSI_SPEED_OFFSET];
222:                 
223:                 						#ifdef MOTION_ERROR_TABLE
224:                 							// note: this array is never read by software; it exists only to allow viewing with the debugger
225:                 							// RAM table is shorter than ROM (Flash) Motion Profile table due to Microchip's antiquated paging system
226:                 							if (pgbMotionProfileSpeedIndex < SPEED_ERROR_TABLE_LEN)
227:                 								pgnMotionProfileSpeedError[pgbMotionProfileSpeedIndex] = (int)fgwExpectedSpeed - (int)pgwCurrentSpeed;
228:                 						#endif
229:                 
230:                 						// keep track of speed error for status display
231:                 						pgnSpeedError = (int)fgwExpectedSpeed - (int)pgwCurrentSpeed[eMotor];
232:                 
233:                 						// compare current speed to expected maximum speed. 
234:                 						// Speed is measured as a count of Tcy ticks, between MSI ticks, so smaller is faster
235:                 						if (pgwCurrentSpeed[eMotor] < (fgwExpectedSpeed - MTN_SENSOR_SPEED_TOLERANCE))		// smaller is faster
236:                 							{
237:                 							// set event flag for motion FSM
238:                 							BITSET(efMotionEvents[eMotor], EF_MOTION_TOO_FAST);
239:                 							}
240:                 						else if (pgwCurrentSpeed[eMotor] > (fgwExpectedSpeed + MTN_SENSOR_SPEED_TOLERANCE))
241:                 							{
242:                 							// set event flag for motion FSM
243:                 							BITSET(efMotionEvents[eMotor], EF_MOTION_TOO_SLOW);
244:                 							}
245:                 						else
246:                 							{
247:                 							// in acceleration, every MSI tick results in a PWM value update of SOME type
248:                 							BITSET(efMotionEvents[eMotor], EF_MOTION_PWM_UPDATE);
249:                 							}
250:                 						}
251:                 					else
252:                 						{
253:                 						RuntimeError(MTN_SENSOR_ERROR_NO_EVENT_GENERATED);
254:                 						}
255:                 
256:                 					break;
257:                 
258:                 				// NONE of these motion types should occur during PHASE_ACCELERATION
259:                 				case MOTION_INIT:				// initial state, only at power up
260:                 				case MOTION_COASTING:			// motor is OFF, some coasting MAY occur
261:                 				case MOTION_BRAKING:			// motor is OFF, brake is on, some coasting MAY occur
262:                 				case MOTION_STOPPED:			// motion has actually STOPPED (Motion Sensor tick timeout)
263:                 				case MOTION_STALLED:			// system has STALLED; no exit
264:                 				default:
265:                 					RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK);
266:                 					break;
267:                 
268:                 				}		// end 	switch(pgeMotionType[eMotor])
269:                 			break;
270:                 
271:                 		case PHASE_CONSTANT_SPEED:			// constant speed operation
272:                 			if (pgeMotionType[eMotor] IS MOTION_POWERED)
273:                 				{
274:                 
275:                 				// NOTE that index into motion profile table of expected speed values does NOT change during the Constant Speed phase
276:                 				// calculate new motion profile index, and look up expected speed value (in Tcy counts)
277:                 				fgwExpectedSpeed = MotionProfileSpeedAndPWM[(pgbMotionProfileSpeedIndex * 2) + MSI_SPEED_OFFSET];
278:                 
279:                 				// keep track of speed error for status display
280:                 				pgnSpeedError = (int)fgwExpectedSpeed - (int)pgwCurrentSpeed[eMotor];
281:                 
282:                 				// compare current speed to expected maximum speed. 
283:                 				// Speed is measured as a count of Tcy ticks, between MSI ticks, so smaller is faster
284:                 				if (pgwCurrentSpeed[eMotor] < (fgwExpectedSpeed - MTN_SENSOR_SPEED_TOLERANCE))		// smaller is faster
285:                 					{
286:                 					// set event flag for motion FSM
287:                 					BITSET(efMotionEvents[eMotor], EF_MOTION_TOO_FAST);
288:                 					}
289:                 				else if (pgwCurrentSpeed[eMotor] > (fgwExpectedSpeed + MTN_SENSOR_SPEED_TOLERANCE))
290:                 					{
291:                 					// set event flag for motion FSM
292:                 					BITSET(efMotionEvents[eMotor], EF_MOTION_TOO_SLOW);
293:                 					}
294:                 				}
295:                 			else
296:                 				{
297:                 				// not a valid MOTION_xxx type
298:                 				RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK);
299:                 				}
300:                 			break;
301:                 
302:                 		case PHASE_DECELERATION:			// decelerating
303:                 			// pgMotionStats.wQDecelerationPWMAdjustmentCount = 0;
304:                 
305:                 			// we are no longer adjusting speed, so there is no error to measure
306:                 			pgnSpeedError = 0;
307:                 
308:                 			if (pgeMotionType[eMotor] IS MOTION_POWERED)
309:                 				{
310:                 				// in deceleration, every MSI tick results in a PWM value update
311:                 				BITSET(efMotionEvents[eMotor], EF_MOTION_PWM_UPDATE);
312:                 				}
313:                 			else
314:                 				{
315:                 				// not a valid MOTION_xxx type
316:                 				RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK);
317:                 				}
318:                 			break;
319:                 
320:                 		case PHASE_MINIMUM_PWM:				// constant speed at minimum PMW
321:                 			// pgMotionStats.wQDecelerationPWMAdjustmentCount = 0;
322:                 			if (pgeMotionType[eMotor] IS MOTION_POWERED)
323:                 				{
324:                 				;
325:                 				}
326:                 			else
327:                 				{
328:                 				// not a valid MOTION_xxx type
329:                 				RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK);
330:                 				}
331:                 			break;
332:                 
333:                 		case PHASE_COASTING:				// motor is OFF, some coasting MAY occur
334:                 			if ((pgeMotionType[eMotor] IS MOTION_COASTING) OR (pgeMotionType[eMotor] IS MOTION_BRAKING))
335:                 				{
336:                 				;
337:                 				}
338:                 			else
339:                 				{
340:                 				// not a valid MOTION_xxx type
341:                 				RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_TICK);
342:                 				}
343:                 			break;
344:                 
345:                 		case PHASE_INIT:					// not even valid here
346:                 		default:
347:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_PHASE);
348:                 			break;
349:                 		}
350:                 
351:                 	// NOTE: we do not make a general check for unprocessed efADCEvents events here, because there is only ONE event type
352:                 	// (EF_MTN_SENSOR_QUADRATURE_TICK) and it is interrupt generated - so another event may occur at ANY time.
353:                 
354:                 #endif
355:                 	
356:                 
357:                 }
9D006850  03C0E821   ADDU SP, S8, ZERO
9D006854  8FBF0014   LW RA, 20(SP)
9D006858  8FBE0010   LW S8, 16(SP)
9D00685C  27BD0018   ADDIU SP, SP, 24
9D006860  03E00008   JR RA
9D006864  00000000   NOP
358:                 
359:                 
360:                 
361:                 //*****************************************************************************
362:                 //						M o t i o n S e n s o r _ R e a d ( )
363:                 //*****************************************************************************
364:                 
365:                 // enable or disable Motion Sensor interrupts
366:                 // we need to turn off the interrupts AFTER a motion stall, so that we do not get any additional interrupts until intentional motion starts again
367:                 
368:                 // Enable Encoder interrupts
369:                 // Called from MotionFSM() upon entering ST_MOTION_ACCELERATE and during ST_MOTION_SOFT_STALL
370:                 void MotionSensor_EnableInt(enum tagAxis eAxis)
371:                 {
9D006868  27BDFFE0   ADDIU SP, SP, -32
9D00686C  AFBF001C   SW RA, 28(SP)
9D006870  AFBE0018   SW S8, 24(SP)
9D006874  03A0F021   ADDU S8, SP, ZERO
9D006878  AFC40020   SW A0, 32(S8)
372:                 
373:                 	WORD wDummy;
374:                 
375:                 	switch(eAxis)
9D00687C  8FC20020   LW V0, 32(S8)
9D006880  10400006   BEQ V0, ZERO, 0x9D00689C
9D006884  00000000   NOP
9D006888  24030001   ADDIU V1, ZERO, 1
9D00688C  10430026   BEQ V0, V1, 0x9D006928
9D006890  00000000   NOP
9D006894  0B401A6D   J 0x9D0069B4
9D006898  00000000   NOP
376:                 	{
377:                 		case AXIS_AZIMUTH:
378:                 			// clear any pending interrupt requests
379:                 			mIC1ClearIntFlag();
9D00689C  3C02BF88   LUI V0, -16504
9D0068A0  24030020   ADDIU V1, ZERO, 32
9D0068A4  AC431034   SW V1, 4148(V0)
380:                 
381:                 			while (IC1CONbits.ICBNE)		// flush FIFO by reading all available data
9D0068A8  0B401A2F   J 0x9D0068BC
9D0068AC  00000000   NOP
9D0068BC  3C02BF80   LUI V0, -16512
9D0068C0  8C422000   LW V0, 8192(V0)
9D0068C4  30420008   ANDI V0, V0, 8
9D0068C8  1440FFF9   BNE V0, ZERO, 0x9D0068B0
9D0068CC  00000000   NOP
382:                 				wDummy = IC1BUF;			// reads the input capture buffer
9D0068B0  3C02BF80   LUI V0, -16512
9D0068B4  8C422010   LW V0, 8208(V0)
9D0068B8  A7C20010   SH V0, 16(S8)
383:                 
384:                 			// Setup Input Capture 1 Interrupts
385:                 			// IC_INT_ON			Enable input capture interrupt  IC_INT_ON
386:                 			// IC_INT_PRIOR_3		Set priority for level 3
387:                 			// IC_INT_SUB_PRIOR_0	Set sub priority for level 0
388:                 
389:                 			ConfigIntCapture1(IC_INT_ON | IC_INT_PRIOR_3 | IC_INT_SUB_PRIOR_0);
9D0068D0  3C02BF88   LUI V0, -16504
9D0068D4  24030020   ADDIU V1, ZERO, 32
9D0068D8  AC431034   SW V1, 4148(V0)
9D0068DC  3C02BF88   LUI V0, -16504
9D0068E0  24031C00   ADDIU V1, ZERO, 7168
9D0068E4  AC4310A4   SW V1, 4260(V0)
9D0068E8  3C02BF88   LUI V0, -16504
9D0068EC  24030C00   ADDIU V1, ZERO, 3072
9D0068F0  AC4310A8   SW V1, 4264(V0)
9D0068F4  3C02BF88   LUI V0, -16504
9D0068F8  24030300   ADDIU V1, ZERO, 768
9D0068FC  AC4310A4   SW V1, 4260(V0)
9D006900  3C02BF88   LUI V0, -16504
9D006904  AC4010A8   SW ZERO, 4264(V0)
9D006908  3C02BF88   LUI V0, -16504
9D00690C  24030020   ADDIU V1, ZERO, 32
9D006910  AC431064   SW V1, 4196(V0)
9D006914  3C02BF88   LUI V0, -16504
9D006918  24030020   ADDIU V1, ZERO, 32
9D00691C  AC431068   SW V1, 4200(V0)
390:                 
391:                 			// enabling interrupts clears Input Capture FIFO
392:                 			break;
9D006920  0B401A71   J 0x9D0069C4
9D006924  00000000   NOP
393:                 
394:                 		case AXIS_ELEVATION:
395:                 			// clear any pending interrupt requests
396:                 			mIC2ClearIntFlag();
9D006928  3C02BF88   LUI V0, -16504
9D00692C  24030200   ADDIU V1, ZERO, 512
9D006930  AC431034   SW V1, 4148(V0)
397:                 
398:                 			while (IC2CONbits.ICBNE)		// flush FIFO by reading all available data
9D006934  0B401A52   J 0x9D006948
9D006938  00000000   NOP
9D006948  3C02BF80   LUI V0, -16512
9D00694C  8C422200   LW V0, 8704(V0)
9D006950  30420008   ANDI V0, V0, 8
9D006954  1440FFF9   BNE V0, ZERO, 0x9D00693C
9D006958  00000000   NOP
399:                 				wDummy = IC2BUF;			// reads the input capture buffer
9D00693C  3C02BF80   LUI V0, -16512
9D006940  8C422210   LW V0, 8720(V0)
9D006944  A7C20010   SH V0, 16(S8)
400:                 
401:                 			// Setup Input Capture 1 Interrupts
402:                 			// IC_INT_ON			Enable input capture interrupt  IC_INT_ON
403:                 			// IC_INT_PRIOR_3		Set priority for level 3
404:                 			// IC_INT_SUB_PRIOR_0	Set sub priority for level 0
405:                 
406:                 			ConfigIntCapture2(IC_INT_ON | IC_INT_PRIOR_3 | IC_INT_SUB_PRIOR_1);
9D00695C  3C02BF88   LUI V0, -16504
9D006960  24030200   ADDIU V1, ZERO, 512
9D006964  AC431034   SW V1, 4148(V0)
9D006968  3C02BF88   LUI V0, -16504
9D00696C  24030300   ADDIU V1, ZERO, 768
9D006970  AC4310B4   SW V1, 4276(V0)
9D006974  3C02BF88   LUI V0, -16504
9D006978  24030C00   ADDIU V1, ZERO, 3072
9D00697C  AC4310B8   SW V1, 4280(V0)
9D006980  3C02BF88   LUI V0, -16504
9D006984  24030300   ADDIU V1, ZERO, 768
9D006988  AC4310B4   SW V1, 4276(V0)
9D00698C  3C02BF88   LUI V0, -16504
9D006990  AC4010B8   SW ZERO, 4280(V0)
9D006994  3C02BF88   LUI V0, -16504
9D006998  24030200   ADDIU V1, ZERO, 512
9D00699C  AC431064   SW V1, 4196(V0)
9D0069A0  3C02BF88   LUI V0, -16504
9D0069A4  24030200   ADDIU V1, ZERO, 512
9D0069A8  AC431068   SW V1, 4200(V0)
407:                 
408:                 			// enabling interrupts clears Input Capture FIFO
409:                 			break;
9D0069AC  0B401A71   J 0x9D0069C4
9D0069B0  00000000   NOP
410:                 
411:                 		default:
412:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_AXIS);
9D0069B4  2404009C   ADDIU A0, ZERO, 156
9D0069B8  0F40365E   JAL _RuntimeError
9D0069BC  00000000   NOP
413:                 			break;
9D0069C0  00000000   NOP
414:                 	}
415:                 
416:                 }
9D0069C4  03C0E821   ADDU SP, S8, ZERO
9D0069C8  8FBF001C   LW RA, 28(SP)
9D0069CC  8FBE0018   LW S8, 24(SP)
9D0069D0  27BD0020   ADDIU SP, SP, 32
9D0069D4  03E00008   JR RA
9D0069D8  00000000   NOP
417:                 
418:                 // Disable Encoder interrupts
419:                 // Called from MotionFSM() upon entering ST_MOTION_STOPPED
420:                 void MotionSensor_DisableInt(enum tagAxis eAxis)
421:                 {
9D0069DC  27BDFFE0   ADDIU SP, SP, -32
9D0069E0  AFBF001C   SW RA, 28(SP)
9D0069E4  AFBE0018   SW S8, 24(SP)
9D0069E8  03A0F021   ADDU S8, SP, ZERO
9D0069EC  AFC40020   SW A0, 32(S8)
422:                 	WORD wDummy;
423:                 
424:                 	switch(eAxis)
9D0069F0  8FC20020   LW V0, 32(S8)
9D0069F4  10400006   BEQ V0, ZERO, 0x9D006A10
9D0069F8  00000000   NOP
9D0069FC  24030001   ADDIU V1, ZERO, 1
9D006A00  10430024   BEQ V0, V1, 0x9D006A94
9D006A04  00000000   NOP
9D006A08  0B401AC6   J 0x9D006B18
9D006A0C  00000000   NOP
425:                 	{
426:                 		case AXIS_AZIMUTH:
427:                 			// clear any pending interrupt requests
428:                 			mIC1ClearIntFlag();
9D006A10  3C02BF88   LUI V0, -16504
9D006A14  24030020   ADDIU V1, ZERO, 32
9D006A18  AC431034   SW V1, 4148(V0)
429:                 
430:                 			// Disable Input Capture 1 interrupts
431:                 			// IC_INT_OFF			Enable input capture interrupt  IC_INT_ON
432:                 			ConfigIntCapture1(IC_INT_OFF);
9D006A1C  3C02BF88   LUI V0, -16504
9D006A20  24030020   ADDIU V1, ZERO, 32
9D006A24  AC431034   SW V1, 4148(V0)
9D006A28  3C02BF88   LUI V0, -16504
9D006A2C  24031C00   ADDIU V1, ZERO, 7168
9D006A30  AC4310A4   SW V1, 4260(V0)
9D006A34  3C02BF88   LUI V0, -16504
9D006A38  AC4010A8   SW ZERO, 4264(V0)
9D006A3C  3C02BF88   LUI V0, -16504
9D006A40  24030300   ADDIU V1, ZERO, 768
9D006A44  AC4310A4   SW V1, 4260(V0)
9D006A48  3C02BF88   LUI V0, -16504
9D006A4C  AC4010A8   SW ZERO, 4264(V0)
9D006A50  3C02BF88   LUI V0, -16504
9D006A54  24030020   ADDIU V1, ZERO, 32
9D006A58  AC431064   SW V1, 4196(V0)
9D006A5C  3C02BF88   LUI V0, -16504
9D006A60  AC401068   SW ZERO, 4200(V0)
433:                 
434:                 			// discard any remaining Motion Capture (Input Capture) FIFO data
435:                 			while (IC1CONbits.ICBNE)		// if data is available
9D006A64  0B401A9E   J 0x9D006A78
9D006A68  00000000   NOP
9D006A78  3C02BF80   LUI V0, -16512
9D006A7C  8C422000   LW V0, 8192(V0)
9D006A80  30420008   ANDI V0, V0, 8
9D006A84  1440FFF9   BNE V0, ZERO, 0x9D006A6C
9D006A88  00000000   NOP
436:                 				wDummy = IC1BUF;			// reads the input capture buffer
9D006A6C  3C02BF80   LUI V0, -16512
9D006A70  8C422010   LW V0, 8208(V0)
9D006A74  A7C20010   SH V0, 16(S8)
437:                 
438:                 			break;
9D006A8C  0B401ACA   J 0x9D006B28
9D006A90  00000000   NOP
439:                 
440:                 		case AXIS_ELEVATION:
441:                 			// clear any pending interrupt requests
442:                 			mIC2ClearIntFlag();
9D006A94  3C02BF88   LUI V0, -16504
9D006A98  24030200   ADDIU V1, ZERO, 512
9D006A9C  AC431034   SW V1, 4148(V0)
443:                 
444:                 			// Disable Input Capture 2 interrupts
445:                 			// IC_INT_OFF			Enable input capture interrupt  IC_INT_ON
446:                 			ConfigIntCapture2(IC_INT_OFF);
9D006AA0  3C02BF88   LUI V0, -16504
9D006AA4  24030200   ADDIU V1, ZERO, 512
9D006AA8  AC431034   SW V1, 4148(V0)
9D006AAC  3C02BF88   LUI V0, -16504
9D006AB0  24030300   ADDIU V1, ZERO, 768
9D006AB4  AC4310B4   SW V1, 4276(V0)
9D006AB8  3C02BF88   LUI V0, -16504
9D006ABC  AC4010B8   SW ZERO, 4280(V0)
9D006AC0  3C02BF88   LUI V0, -16504
9D006AC4  24030300   ADDIU V1, ZERO, 768
9D006AC8  AC4310B4   SW V1, 4276(V0)
9D006ACC  3C02BF88   LUI V0, -16504
9D006AD0  AC4010B8   SW ZERO, 4280(V0)
9D006AD4  3C02BF88   LUI V0, -16504
9D006AD8  24030200   ADDIU V1, ZERO, 512
9D006ADC  AC431064   SW V1, 4196(V0)
9D006AE0  3C02BF88   LUI V0, -16504
9D006AE4  AC401068   SW ZERO, 4200(V0)
447:                 
448:                 			// discard any remaining Motion Capture (Input Capture) FIFO data
449:                 			while (IC2CONbits.ICBNE)		// if data is available
9D006AE8  0B401ABF   J 0x9D006AFC
9D006AEC  00000000   NOP
9D006AFC  3C02BF80   LUI V0, -16512
9D006B00  8C422200   LW V0, 8704(V0)
9D006B04  30420008   ANDI V0, V0, 8
9D006B08  1440FFF9   BNE V0, ZERO, 0x9D006AF0
9D006B0C  00000000   NOP
450:                 				wDummy = IC2BUF;			// reads the input capture buffer
9D006AF0  3C02BF80   LUI V0, -16512
9D006AF4  8C422210   LW V0, 8720(V0)
9D006AF8  A7C20010   SH V0, 16(S8)
451:                 
452:                 			break;
9D006B10  0B401ACA   J 0x9D006B28
9D006B14  00000000   NOP
453:                 
454:                 		default:
455:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_AXIS);
9D006B18  2404009C   ADDIU A0, ZERO, 156
9D006B1C  0F40365E   JAL _RuntimeError
9D006B20  00000000   NOP
456:                 			break;
9D006B24  00000000   NOP
457:                 	}
458:                 
459:                 }
9D006B28  03C0E821   ADDU SP, S8, ZERO
9D006B2C  8FBF001C   LW RA, 28(SP)
9D006B30  8FBE0018   LW S8, 24(SP)
9D006B34  27BD0020   ADDIU SP, SP, 32
9D006B38  03E00008   JR RA
9D006B3C  00000000   NOP
460:                 
461:                 
462:                 // returns calculated speed
463:                 // used ONLY for serial menus MenuFSM.c
464:                 unsigned int CurrentSpeed_Read(enum tagMotors eMotor)
465:                 {
9D006B40  27BDFFF8   ADDIU SP, SP, -8
9D006B44  AFBE0004   SW S8, 4(SP)
9D006B48  03A0F021   ADDU S8, SP, ZERO
9D006B4C  AFC40008   SW A0, 8(S8)
466:                 	return pgwCurrentSpeed[eMotor];
9D006B50  3C02A000   LUI V0, -24576
9D006B54  8FC30008   LW V1, 8(S8)
9D006B58  00031840   SLL V1, V1, 1
9D006B5C  244202A0   ADDIU V0, V0, 672
9D006B60  00621021   ADDU V0, V1, V0
9D006B64  94420000   LHU V0, 0(V0)
467:                 }
9D006B68  03C0E821   ADDU SP, S8, ZERO
9D006B6C  8FBE0004   LW S8, 4(SP)
9D006B70  27BD0008   ADDIU SP, SP, 8
9D006B74  03E00008   JR RA
9D006B78  00000000   NOP
468:                 
469:                 /*
470:                 // returns calculated average speed
471:                 unsigned int AverageSpeed_Read( void )
472:                 {
473:                 	return pgwAverageSpeed;
474:                 }
475:                 */
476:                 
477:                 // this function is called when a STALL occurs, so that speed will be reported as ZERO
478:                 // ==> is this really necessary now? should this just be merged into MotionFSM.c: Init_MotionStats()?
479:                 // (only called AFTER Finish_MotionStats() )
480:                 void CurrentSpeed_Write(enum tagMotors eMotor, unsigned int wNewSpeed)
481:                 {
9D006B7C  27BDFFF8   ADDIU SP, SP, -8
9D006B80  AFBE0004   SW S8, 4(SP)
9D006B84  03A0F021   ADDU S8, SP, ZERO
9D006B88  AFC40008   SW A0, 8(S8)
9D006B8C  AFC5000C   SW A1, 12(S8)
482:                 	if (wNewSpeed IS ZERO)
9D006B90  8FC2000C   LW V0, 12(S8)
9D006B94  14400021   BNE V0, ZERO, 0x9D006C1C
9D006B98  00000000   NOP
483:                 		{
484:                 		// writing speed to 0 means we are STOPPED, so clear all speed related variables
485:                 		fgwLastTimerValue[eMotor] = 0xFFFF;
9D006B9C  8FC20008   LW V0, 8(S8)
9D006BA0  00021840   SLL V1, V0, 1
9D006BA4  2782804C   ADDIU V0, GP, -32692
9D006BA8  00621021   ADDU V0, V1, V0
9D006BAC  2403FFFF   ADDIU V1, ZERO, -1
9D006BB0  A4430000   SH V1, 0(V0)
486:                 
487:                 		pgwCurrentSpeed[eMotor] = 0;
9D006BB4  3C02A000   LUI V0, -24576
9D006BB8  8FC30008   LW V1, 8(S8)
9D006BBC  00031840   SLL V1, V1, 1
9D006BC0  244202A0   ADDIU V0, V0, 672
9D006BC4  00621021   ADDU V0, V1, V0
9D006BC8  A4400000   SH ZERO, 0(V0)
488:                 		pgnSpeedError[eMotor] = 0;
9D006BCC  3C02A000   LUI V0, -24576
9D006BD0  8FC30008   LW V1, 8(S8)
9D006BD4  00031880   SLL V1, V1, 2
9D006BD8  244202A4   ADDIU V0, V0, 676
9D006BDC  00621021   ADDU V0, V1, V0
9D006BE0  AC400000   SW ZERO, 0(V0)
489:                 		#ifdef CALC_AVERAGE_SPEED
490:                 			fgwSumOfSpeeds[eMotor] = 0;
491:                 			fgwSampleCtr[eMotor] = 0;
492:                 			fgwLastSpeed[eMotor] = 0;
493:                 			pgwAverageSpeed[eMotor] = 0;
494:                 			pgnErrorFromAverage[eMotor] = 0;
495:                 			pgnErrorFromSample[eMotor] = 0;
496:                 		#endif
497:                 
498:                 		pgwMoveTotalMSICtr[eMotor] = 0;			// Total motion sensor ticks in move ctr;
9D006BE4  3C02A000   LUI V0, -24576
9D006BE8  8FC30008   LW V1, 8(S8)
9D006BEC  00031840   SLL V1, V1, 1
9D006BF0  244202B8   ADDIU V0, V0, 696
9D006BF4  00621021   ADDU V0, V1, V0
9D006BF8  A4400000   SH ZERO, 0(V0)
499:                 		pgwStateMSICtr[eMotor] = 0;
9D006BFC  3C02A000   LUI V0, -24576
9D006C00  8FC30008   LW V1, 8(S8)
9D006C04  00031840   SLL V1, V1, 1
9D006C08  244202B4   ADDIU V0, V0, 692
9D006C0C  00621021   ADDU V0, V1, V0
9D006C10  A4400000   SH ZERO, 0(V0)
9D006C14  0B401B0F   J 0x9D006C3C
9D006C18  00000000   NOP
500:                 
501:                 		// note that we do NOT clear:
502:                 		//	pgnCurrentPosition - so we can maintain position when motion restarts
503:                 
504:                 		}
505:                 	else
506:                 		{
507:                 		pgwCurrentSpeed[eMotor] = wNewSpeed;
9D006C1C  8FC2000C   LW V0, 12(S8)
9D006C20  3043FFFF   ANDI V1, V0, -1
9D006C24  3C02A000   LUI V0, -24576
9D006C28  8FC40008   LW A0, 8(S8)
9D006C2C  00042040   SLL A0, A0, 1
9D006C30  244202A0   ADDIU V0, V0, 672
9D006C34  00821021   ADDU V0, A0, V0
9D006C38  A4430000   SH V1, 0(V0)
508:                 		}
509:                 }
9D006C3C  03C0E821   ADDU SP, S8, ZERO
9D006C40  8FBE0004   LW S8, 4(SP)
9D006C44  27BD0008   ADDIU SP, SP, 8
9D006C48  03E00008   JR RA
9D006C4C  00000000   NOP
510:                 
511:                 // read the current position counter value
512:                 // used ONLY for serial menus MenuFSM.c
513:                 
514:                 int CurrentPosition_Read(enum tagMotors eMotor)
515:                 {
9D006C50  27BDFFF8   ADDIU SP, SP, -8
9D006C54  AFBE0004   SW S8, 4(SP)
9D006C58  03A0F021   ADDU S8, SP, ZERO
9D006C5C  AFC40008   SW A0, 8(S8)
516:                 	return pgnCurrentPosition[eMotor];
9D006C60  3C02A000   LUI V0, -24576
9D006C64  8FC30008   LW V1, 8(S8)
9D006C68  00031880   SLL V1, V1, 2
9D006C6C  244202AC   ADDIU V0, V0, 684
9D006C70  00621021   ADDU V0, V1, V0
9D006C74  8C420000   LW V0, 0(V0)
517:                 }
9D006C78  03C0E821   ADDU SP, S8, ZERO
9D006C7C  8FBE0004   LW S8, 4(SP)
9D006C80  27BD0008   ADDIU SP, SP, 8
9D006C84  03E00008   JR RA
9D006C88  00000000   NOP
518:                 
519:                 
520:                 //---------------------------------------------------------------------
521:                 // Read current state of Optical Wheel Interface Pins
522:                 // this is implemented as a hardware-specific input, generalized output routine 
523:                 
524:                 // used ONLY for serial menus MenuFSM.c
525:                 
526:                 // b0	Optical Wheel sensor (active LOW)
527:                 // b1	End-of-travel OUT sensor 
528:                 // b2	End-of-travel IN sensor 
529:                 // b3	Optical sensor power enable (active LOW)
530:                 
531:                 UINT16 GetMotionSensorState( void )
532:                 {
9D006C8C  27BDFFE0   ADDIU SP, SP, -32
9D006C90  AFBF001C   SW RA, 28(SP)
9D006C94  AFBE0018   SW S8, 24(SP)
9D006C98  03A0F021   ADDU S8, SP, ZERO
533:                 
534:                 	BYTE	cSensorState = 0;
9D006C9C  A3C00010   SB ZERO, 16(S8)
535:                 
536:                 	return ReadMotionSensorPins();
537:                 #ifdef NOTDEF
538:                 //	if (WHEEL_SENSE IS_TRUE)			// actually active LOW
539:                 //		cSensorState += 0x01;
540:                 
541:                 	if (EOT_IN_SENSE IS_TRUE)
542:                 		cSensorState += 0x04;
543:                 #endif
544:                 
545:                 }
9D006CB4  03C0E821   ADDU SP, S8, ZERO
9D006CB8  8FBF001C   LW RA, 28(SP)
9D006CBC  8FBE0018   LW S8, 24(SP)
9D006CC0  27BD0020   ADDIU SP, SP, 32
9D006CC4  03E00008   JR RA
9D006CC8  00000000   NOP
546:                 
547:                 
548:                 //*****************************************************************************
549:                 //			M o t i o n S e n s o r I n t e r r u p t H a n d l e r( )
550:                 //*****************************************************************************
551:                 
552:                 // this is a very low speed interrupt handler (less than 100 Hz)
553:                 // it is currently called from the high priority interrupt handler (see Interrupt.c)
554:                 // Perhaps it could just be moved to the foreground loop?
555:                 
556:                 void __ISR( _INPUT_CAPTURE_1_VECTOR, ipl3) Capture1(void)
557:                 {
9D006CCC  415DE800   RDPGPR SP, SP
9D006CD0  401A7000   MFC0 K0, EPC
9D006CD4  401B6000   MFC0 K1, Status
9D006CD8  27BDFF90   ADDIU SP, SP, -112
9D006CDC  AFBA006C   SW K0, 108(SP)
9D006CE0  AFBB0068   SW K1, 104(SP)
9D006CE4  7C1B7844   INS K1, ZERO, 1, 15
9D006CE8  377B0C00   ORI K1, K1, 3072
9D006CEC  409B6000   MTC0 K1, Status
9D006CF0  AFBF005C   SW RA, 92(SP)
9D006CF4  AFBE0058   SW S8, 88(SP)
9D006CF8  AFB90054   SW T9, 84(SP)
9D006CFC  AFB80050   SW T8, 80(SP)
9D006D00  AFAF004C   SW T7, 76(SP)
9D006D04  AFAE0048   SW T6, 72(SP)
9D006D08  AFAD0044   SW T5, 68(SP)
9D006D0C  AFAC0040   SW T4, 64(SP)
9D006D10  AFAB003C   SW T3, 60(SP)
9D006D14  AFAA0038   SW T2, 56(SP)
9D006D18  AFA90034   SW T1, 52(SP)
9D006D1C  AFA80030   SW T0, 48(SP)
9D006D20  AFA7002C   SW A3, 44(SP)
9D006D24  AFA60028   SW A2, 40(SP)
9D006D28  AFA50024   SW A1, 36(SP)
9D006D2C  AFA40020   SW A0, 32(SP)
9D006D30  AFA3001C   SW V1, 28(SP)
9D006D34  AFA20018   SW V0, 24(SP)
9D006D38  AFA10014   SW AT, 20(SP)
9D006D3C  00001012   MFLO V0
9D006D40  AFA20064   SW V0, 100(SP)
9D006D44  00001810   MFHI V1
9D006D48  AFA30060   SW V1, 96(SP)
9D006D4C  03A0F021   ADDU S8, SP, ZERO
558:                 	MotionSensorInterruptHandler(MOTOR_AZIMUTH);
9D006D50  00002021   ADDU A0, ZERO, ZERO
9D006D54  0F401BC3   JAL MotionSensorInterruptHandler
9D006D58  00000000   NOP
559:                 	
560:                 	// clear interrupt flag to allow next Input Capture interrupt
561:                 	mIC1ClearIntFlag();
9D006D5C  3C02BF88   LUI V0, -16504
9D006D60  24030020   ADDIU V1, ZERO, 32
9D006D64  AC431034   SW V1, 4148(V0)
562:                 }
9D006D68  03C0E821   ADDU SP, S8, ZERO
9D006D6C  8FA20064   LW V0, 100(SP)
9D006D70  00400013   MTLO V0
9D006D74  8FA30060   LW V1, 96(SP)
9D006D78  00600011   MTHI V1
9D006D7C  8FBF005C   LW RA, 92(SP)
9D006D80  8FBE0058   LW S8, 88(SP)
9D006D84  8FB90054   LW T9, 84(SP)
9D006D88  8FB80050   LW T8, 80(SP)
9D006D8C  8FAF004C   LW T7, 76(SP)
9D006D90  8FAE0048   LW T6, 72(SP)
9D006D94  8FAD0044   LW T5, 68(SP)
9D006D98  8FAC0040   LW T4, 64(SP)
9D006D9C  8FAB003C   LW T3, 60(SP)
9D006DA0  8FAA0038   LW T2, 56(SP)
9D006DA4  8FA90034   LW T1, 52(SP)
9D006DA8  8FA80030   LW T0, 48(SP)
9D006DAC  8FA7002C   LW A3, 44(SP)
9D006DB0  8FA60028   LW A2, 40(SP)
9D006DB4  8FA50024   LW A1, 36(SP)
9D006DB8  8FA40020   LW A0, 32(SP)
9D006DBC  8FA3001C   LW V1, 28(SP)
9D006DC0  8FA20018   LW V0, 24(SP)
9D006DC4  8FA10014   LW AT, 20(SP)
9D006DC8  41606000   DI ZERO
9D006DCC  000000C0   EHB
9D006DD0  8FBA006C   LW K0, 108(SP)
9D006DD4  8FBB0068   LW K1, 104(SP)
9D006DD8  409A7000   MTC0 K0, EPC
9D006DDC  27BD0070   ADDIU SP, SP, 112
9D006DE0  41DDE800   WRPGPR SP, SP
9D006DE4  409B6000   MTC0 K1, Status
9D006DE8  42000018   ERET
563:                 
564:                 void __ISR( _INPUT_CAPTURE_2_VECTOR, ipl3) Capture2(void)
565:                 {
9D006DEC  415DE800   RDPGPR SP, SP
9D006DF0  401A7000   MFC0 K0, EPC
9D006DF4  401B6000   MFC0 K1, Status
9D006DF8  27BDFF90   ADDIU SP, SP, -112
9D006DFC  AFBA006C   SW K0, 108(SP)
9D006E00  AFBB0068   SW K1, 104(SP)
9D006E04  7C1B7844   INS K1, ZERO, 1, 15
9D006E08  377B0C00   ORI K1, K1, 3072
9D006E0C  409B6000   MTC0 K1, Status
9D006E10  AFBF005C   SW RA, 92(SP)
9D006E14  AFBE0058   SW S8, 88(SP)
9D006E18  AFB90054   SW T9, 84(SP)
9D006E1C  AFB80050   SW T8, 80(SP)
9D006E20  AFAF004C   SW T7, 76(SP)
9D006E24  AFAE0048   SW T6, 72(SP)
9D006E28  AFAD0044   SW T5, 68(SP)
9D006E2C  AFAC0040   SW T4, 64(SP)
9D006E30  AFAB003C   SW T3, 60(SP)
9D006E34  AFAA0038   SW T2, 56(SP)
9D006E38  AFA90034   SW T1, 52(SP)
9D006E3C  AFA80030   SW T0, 48(SP)
9D006E40  AFA7002C   SW A3, 44(SP)
9D006E44  AFA60028   SW A2, 40(SP)
9D006E48  AFA50024   SW A1, 36(SP)
9D006E4C  AFA40020   SW A0, 32(SP)
9D006E50  AFA3001C   SW V1, 28(SP)
9D006E54  AFA20018   SW V0, 24(SP)
9D006E58  AFA10014   SW AT, 20(SP)
9D006E5C  00001012   MFLO V0
9D006E60  AFA20064   SW V0, 100(SP)
9D006E64  00001810   MFHI V1
9D006E68  AFA30060   SW V1, 96(SP)
9D006E6C  03A0F021   ADDU S8, SP, ZERO
566:                 	MotionSensorInterruptHandler(MOTOR_ELEVATION);
9D006E70  24040001   ADDIU A0, ZERO, 1
9D006E74  0F401BC3   JAL MotionSensorInterruptHandler
9D006E78  00000000   NOP
567:                 
568:                 	// clear interrupt flag to allow next Input Capture interrupt
569:                 	mIC2ClearIntFlag();
9D006E7C  3C02BF88   LUI V0, -16504
9D006E80  24030200   ADDIU V1, ZERO, 512
9D006E84  AC431034   SW V1, 4148(V0)
570:                 }
9D006E88  03C0E821   ADDU SP, S8, ZERO
9D006E8C  8FA20064   LW V0, 100(SP)
9D006E90  00400013   MTLO V0
9D006E94  8FA30060   LW V1, 96(SP)
9D006E98  00600011   MTHI V1
9D006E9C  8FBF005C   LW RA, 92(SP)
9D006EA0  8FBE0058   LW S8, 88(SP)
9D006EA4  8FB90054   LW T9, 84(SP)
9D006EA8  8FB80050   LW T8, 80(SP)
9D006EAC  8FAF004C   LW T7, 76(SP)
9D006EB0  8FAE0048   LW T6, 72(SP)
9D006EB4  8FAD0044   LW T5, 68(SP)
9D006EB8  8FAC0040   LW T4, 64(SP)
9D006EBC  8FAB003C   LW T3, 60(SP)
9D006EC0  8FAA0038   LW T2, 56(SP)
9D006EC4  8FA90034   LW T1, 52(SP)
9D006EC8  8FA80030   LW T0, 48(SP)
9D006ECC  8FA7002C   LW A3, 44(SP)
9D006ED0  8FA60028   LW A2, 40(SP)
9D006ED4  8FA50024   LW A1, 36(SP)
9D006ED8  8FA40020   LW A0, 32(SP)
9D006EDC  8FA3001C   LW V1, 28(SP)
9D006EE0  8FA20018   LW V0, 24(SP)
9D006EE4  8FA10014   LW AT, 20(SP)
9D006EE8  41606000   DI ZERO
9D006EEC  000000C0   EHB
9D006EF0  8FBA006C   LW K0, 108(SP)
9D006EF4  8FBB0068   LW K1, 104(SP)
9D006EF8  409A7000   MTC0 K0, EPC
9D006EFC  27BD0070   ADDIU SP, SP, 112
9D006F00  41DDE800   WRPGPR SP, SP
9D006F04  409B6000   MTC0 K1, Status
9D006F08  42000018   ERET
571:                 
572:                 
573:                 void MotionSensorInterruptHandler(enum tagMotors eMotor)
574:                 {
9D006F0C  27BDFFE0   ADDIU SP, SP, -32
9D006F10  AFBF001C   SW RA, 28(SP)
9D006F14  AFBE0018   SW S8, 24(SP)
9D006F18  03A0F021   ADDU S8, SP, ZERO
9D006F1C  AFC40020   SW A0, 32(S8)
575:                 
576:                 	WORD wCurrentTimerValue[NUM_MOTORS];
577:                 
578:                 	//********************************************
579:                 	//		track overall MSI Ticks
580:                 	//********************************************
581:                 	// bump MSI ticks-in-current-motion-phase and total-ticks-in-move counters
582:                 	// (this ABSOLUTELY needs to be in the ISR)
583:                 	++pgwStateMSICtr[eMotor];							// increment count of QE ticks in current motion state; always checked for >= LIMIT
9D006F20  3C02A000   LUI V0, -24576
9D006F24  8FC30020   LW V1, 32(S8)
9D006F28  00031840   SLL V1, V1, 1
9D006F2C  244202B4   ADDIU V0, V0, 692
9D006F30  00621021   ADDU V0, V1, V0
9D006F34  94420000   LHU V0, 0(V0)
9D006F38  24420001   ADDIU V0, V0, 1
9D006F3C  3043FFFF   ANDI V1, V0, -1
9D006F40  3C02A000   LUI V0, -24576
9D006F44  8FC40020   LW A0, 32(S8)
9D006F48  00042040   SLL A0, A0, 1
9D006F4C  244202B4   ADDIU V0, V0, 692
9D006F50  00821021   ADDU V0, A0, V0
9D006F54  A4430000   SH V1, 0(V0)
584:                 	++pgwMoveTotalMSICtr[eMotor];						// count total QE ticks in move
9D006F58  3C02A000   LUI V0, -24576
9D006F5C  8FC30020   LW V1, 32(S8)
9D006F60  00031840   SLL V1, V1, 1
9D006F64  244202B8   ADDIU V0, V0, 696
9D006F68  00621021   ADDU V0, V1, V0
9D006F6C  94420000   LHU V0, 0(V0)
9D006F70  24420001   ADDIU V0, V0, 1
9D006F74  3043FFFF   ANDI V1, V0, -1
9D006F78  3C02A000   LUI V0, -24576
9D006F7C  8FC40020   LW A0, 32(S8)
9D006F80  00042040   SLL A0, A0, 1
9D006F84  244202B8   ADDIU V0, V0, 696
9D006F88  00821021   ADDU V0, A0, V0
9D006F8C  A4430000   SH V1, 0(V0)
585:                 
586:                 #ifdef NOTDEF
587:                 	// test for completed MSI ticks in motion phase
588:                 	// (this should be in the ISR to avoid latency issues)
589:                 	if (pgwStateMSICtr[eMotor] >= pgwStateMSILimit[eMotor])				// if we have completed the MSI ticks for the motion phase
590:                 		{
591:                 		// check for flag overrun, which could occur if we are coasting to a stop
592:                 		if (IS_BITSET(efMotionEvents[eMotor], EF_MOTION_MSI_COUNT_DONE))
593:                 			{
594:                 			RuntimeError(MTN_SENSOR_ERROR_MSI_COUNT_DONE_OVERRUN);
595:                 			}
596:                 		BITSET(efMotionEvents[eMotor], EF_MOTION_MSI_COUNT_DONE);	// set event flag for faster processing
597:                 		}
598:                 #endif
599:                 	// read the free running timer
600:                 	// (this ABSOLUTELY needs to be in the ISR)
601:                 	wCurrentTimerValue[eMotor] = ReadMSITimer(eMotor);
9D006F90  8FC40020   LW A0, 32(S8)
9D006F94  0F40335A   JAL ReadMSITimer
9D006F98  00000000   NOP
9D006F9C  00401821   ADDU V1, V0, ZERO
9D006FA0  8FC20020   LW V0, 32(S8)
9D006FA4  00021040   SLL V0, V0, 1
9D006FA8  27C40010   ADDIU A0, S8, 16
9D006FAC  00821021   ADDU V0, A0, V0
9D006FB0  A4430000   SH V1, 0(V0)
602:                 
603:                 	//********************************************
604:                 	//			Start EOT Sensor ADC
605:                 	//********************************************
606:                 	// start A/C conversion for the End-of-Travel OUT sensor
607:                 	// result will actually be read during MotionSensor_Tick()
608:                 	//ADC_Start(ADC_CH_EOT_OUT);
609:                 
610:                 	//********************************************
611:                 	//		Track Position by counting ticks
612:                 	//********************************************
613:                 	// keep track of the current position by bumping pgnCurrentPosition on each optical wheel tick.
614:                 	// NOTE: the 0 point is arbitrary; we do not presently have a 'move center' capability
615:                 
616:                 	switch(pgePWMDirection[eMotor])
9D006FB4  3C02A000   LUI V0, -24576
9D006FB8  8FC30020   LW V1, 32(S8)
9D006FBC  00031880   SLL V1, V1, 2
9D006FC0  2442020C   ADDIU V0, V0, 524
9D006FC4  00621021   ADDU V0, V1, V0
9D006FC8  8C420000   LW V0, 0(V0)
9D006FCC  2403FFFF   ADDIU V1, ZERO, -1
9D006FD0  10430006   BEQ V0, V1, 0x9D006FEC
9D006FD4  00000000   NOP
9D006FD8  24030001   ADDIU V1, ZERO, 1
9D006FDC  10430012   BEQ V0, V1, 0x9D007028
9D006FE0  00000000   NOP
9D006FE4  0B401C19   J 0x9D007064
9D006FE8  00000000   NOP
617:                 		{
618:                 		case PWM_DIR_REVERSE:
619:                 			--pgnCurrentPosition[eMotor];
9D006FEC  3C02A000   LUI V0, -24576
9D006FF0  8FC30020   LW V1, 32(S8)
9D006FF4  00031880   SLL V1, V1, 2
9D006FF8  244202AC   ADDIU V0, V0, 684
9D006FFC  00621021   ADDU V0, V1, V0
9D007000  8C420000   LW V0, 0(V0)
9D007004  2443FFFF   ADDIU V1, V0, -1
9D007008  3C02A000   LUI V0, -24576
9D00700C  8FC40020   LW A0, 32(S8)
9D007010  00042080   SLL A0, A0, 2
9D007014  244202AC   ADDIU V0, V0, 684
9D007018  00821021   ADDU V0, A0, V0
9D00701C  AC430000   SW V1, 0(V0)
620:                 			break;
9D007020  0B401C1D   J 0x9D007074
9D007024  00000000   NOP
621:                 
622:                 		case PWM_DIR_FORWARD:
623:                 			++pgnCurrentPosition[eMotor];
9D007028  3C02A000   LUI V0, -24576
9D00702C  8FC30020   LW V1, 32(S8)
9D007030  00031880   SLL V1, V1, 2
9D007034  244202AC   ADDIU V0, V0, 684
9D007038  00621021   ADDU V0, V1, V0
9D00703C  8C420000   LW V0, 0(V0)
9D007040  24430001   ADDIU V1, V0, 1
9D007044  3C02A000   LUI V0, -24576
9D007048  8FC40020   LW A0, 32(S8)
9D00704C  00042080   SLL A0, A0, 2
9D007050  244202AC   ADDIU V0, V0, 684
9D007054  00821021   ADDU V0, A0, V0
9D007058  AC430000   SW V1, 0(V0)
624:                 			break;
9D00705C  0B401C1D   J 0x9D007074
9D007060  00000000   NOP
625:                 
626:                 		case PWM_DIR_STOPPED:
627:                 		case PWM_DIR_UNKNOWN:							// error value
628:                 		default:
629:                 			// if we do not have a direction as above, we should not get a motion sensor tick!
630:                 			RuntimeError(MTN_SENSOR_ERROR_UNEXPECTED_INT);
9D007064  2404009D   ADDIU A0, ZERO, 157
9D007068  0F40365E   JAL _RuntimeError
9D00706C  00000000   NOP
631:                 			break;
9D007070  00000000   NOP
632:                 		}
633:                 
634:                 
635:                 	//********************************************
636:                 	//		track per-motion-phase MSI Ticks
637:                 	//********************************************
638:                 	// keep track of Optical Wheel ticks per motion phase
639:                 	// this is done for debug logging, and is NOT required for the final system
640:                 	// (this should be in the ISR to avoid latency issues)
641:                 	switch(pgeMotionPhase[eMotor])
9D007074  3C02A000   LUI V0, -24576
9D007078  8FC30020   LW V1, 32(S8)
9D00707C  00031880   SLL V1, V1, 2
9D007080  24420274   ADDIU V0, V0, 628
9D007084  00621021   ADDU V0, V1, V0
9D007088  8C420000   LW V0, 0(V0)
9D00708C  2C430007   SLTIU V1, V0, 7
9D007090  10600082   BEQ V1, ZERO, 0x9D00729C
9D007094  00000000   NOP
9D007098  00021880   SLL V1, V0, 2
9D00709C  3C029D00   LUI V0, -25344
9D0070A0  244270B4   ADDIU V0, V0, 28852
9D0070A4  00621021   ADDU V0, V1, V0
9D0070A8  8C420000   LW V0, 0(V0)
9D0070AC  00400008   JR V0
9D0070B0  00000000   NOP
642:                 		{
643:                 		case PHASE_STOPPED:						// motion has actually STOPPED (Motion Sensor tick timeout), includes STALLED
644:                 			// this is a bit of a kludge, because we CERTAINLY do not exit the STOPPED state based on a state MSI tick count!
645:                 			BITCLEAR(efMotionEvents[eMotor], EF_MOTION_MSI_COUNT_DONE);		// unconditionally clear flag
9D0070D0  3C02A000   LUI V0, -24576
9D0070D4  8FC30020   LW V1, 32(S8)
9D0070D8  00031840   SLL V1, V1, 1
9D0070DC  244202D8   ADDIU V0, V0, 728
9D0070E0  00621021   ADDU V0, V1, V0
9D0070E4  94430000   LHU V1, 0(V0)
9D0070E8  2402FDFF   ADDIU V0, ZERO, -513
9D0070EC  00621024   AND V0, V1, V0
9D0070F0  3043FFFF   ANDI V1, V0, -1
9D0070F4  3C02A000   LUI V0, -24576
9D0070F8  8FC40020   LW A0, 32(S8)
9D0070FC  00042040   SLL A0, A0, 1
9D007100  244202D8   ADDIU V0, V0, 728
9D007104  00821021   ADDU V0, A0, V0
9D007108  A4430000   SH V1, 0(V0)
646:                 
647:                 			RuntimeError(MTN_SENSOR_ERROR_UNEXPECTED_EVENT);
9D00710C  24040092   ADDIU A0, ZERO, 146
9D007110  0F40365E   JAL _RuntimeError
9D007114  00000000   NOP
648:                 			break;
9D007118  0B401CAB   J 0x9D0072AC
9D00711C  00000000   NOP
649:                 
650:                 		case PHASE_ACCELERATION:				// accelerating speed
651:                 			++pgwMSI_AccelerationCtr[eMotor];	// MSI ticks for each of the motion phases
9D007120  3C02A000   LUI V0, -24576
9D007124  8FC30020   LW V1, 32(S8)
9D007128  00031840   SLL V1, V1, 1
9D00712C  24420284   ADDIU V0, V0, 644
9D007130  00621021   ADDU V0, V1, V0
9D007134  94420000   LHU V0, 0(V0)
9D007138  24420001   ADDIU V0, V0, 1
9D00713C  3043FFFF   ANDI V1, V0, -1
9D007140  3C02A000   LUI V0, -24576
9D007144  8FC40020   LW A0, 32(S8)
9D007148  00042040   SLL A0, A0, 1
9D00714C  24420284   ADDIU V0, V0, 644
9D007150  00821021   ADDU V0, A0, V0
9D007154  A4430000   SH V1, 0(V0)
652:                 			break;
9D007158  0B401CAB   J 0x9D0072AC
9D00715C  00000000   NOP
653:                 
654:                 		case PHASE_CONSTANT_SPEED:			// constant speed operation
655:                 			++pgwMSI_ConstantSpeedCtr[eMotor];
9D007160  3C02A000   LUI V0, -24576
9D007164  8FC30020   LW V1, 32(S8)
9D007168  00031840   SLL V1, V1, 1
9D00716C  24420288   ADDIU V0, V0, 648
9D007170  00621021   ADDU V0, V1, V0
9D007174  94420000   LHU V0, 0(V0)
9D007178  24420001   ADDIU V0, V0, 1
9D00717C  3043FFFF   ANDI V1, V0, -1
9D007180  3C02A000   LUI V0, -24576
9D007184  8FC40020   LW A0, 32(S8)
9D007188  00042040   SLL A0, A0, 1
9D00718C  24420288   ADDIU V0, V0, 648
9D007190  00821021   ADDU V0, A0, V0
9D007194  A4430000   SH V1, 0(V0)
656:                 			break;
9D007198  0B401CAB   J 0x9D0072AC
9D00719C  00000000   NOP
657:                 
658:                 		case PHASE_DECELERATION:			// decelerating
659:                 			++pgwMSI_DecelerationCtr[eMotor];
9D0071A0  3C02A000   LUI V0, -24576
9D0071A4  8FC30020   LW V1, 32(S8)
9D0071A8  00031840   SLL V1, V1, 1
9D0071AC  2442028C   ADDIU V0, V0, 652
9D0071B0  00621021   ADDU V0, V1, V0
9D0071B4  94420000   LHU V0, 0(V0)
9D0071B8  24420001   ADDIU V0, V0, 1
9D0071BC  3043FFFF   ANDI V1, V0, -1
9D0071C0  3C02A000   LUI V0, -24576
9D0071C4  8FC40020   LW A0, 32(S8)
9D0071C8  00042040   SLL A0, A0, 1
9D0071CC  2442028C   ADDIU V0, V0, 652
9D0071D0  00821021   ADDU V0, A0, V0
9D0071D4  A4430000   SH V1, 0(V0)
660:                 			break;
9D0071D8  0B401CAB   J 0x9D0072AC
9D0071DC  00000000   NOP
661:                 
662:                 		case PHASE_MINIMUM_PWM:				// constant speed at minimum PMW
663:                 			++pgwMSI_MinimumPWMCtr[eMotor];
9D0071E0  3C02A000   LUI V0, -24576
9D0071E4  8FC30020   LW V1, 32(S8)
9D0071E8  00031840   SLL V1, V1, 1
9D0071EC  24420290   ADDIU V0, V0, 656
9D0071F0  00621021   ADDU V0, V1, V0
9D0071F4  94420000   LHU V0, 0(V0)
9D0071F8  24420001   ADDIU V0, V0, 1
9D0071FC  3043FFFF   ANDI V1, V0, -1
9D007200  3C02A000   LUI V0, -24576
9D007204  8FC40020   LW A0, 32(S8)
9D007208  00042040   SLL A0, A0, 1
9D00720C  24420290   ADDIU V0, V0, 656
9D007210  00821021   ADDU V0, A0, V0
9D007214  A4430000   SH V1, 0(V0)
664:                 
665:                 			// this is a bit of a kludge, because we do not exit the MINIMUM_PWM state based on a state MSI tick count
666:                 			// (we don't really know how many ticks will occur in this state; it is just whatever did not get done during deceleration.)
667:                 //////			BITCLEAR(efMotionEvents[eMotor], EF_MOTION_MSI_COUNT_DONE);		// unconditionally clear flag
668:                 			break;
9D007218  0B401CAB   J 0x9D0072AC
9D00721C  00000000   NOP
669:                 
670:                 		case PHASE_COASTING:				// motor is OFF, some coasting MAY occur
671:                 			++pgwMSI_CoastCtr[eMotor];
9D007220  3C02A000   LUI V0, -24576
9D007224  8FC30020   LW V1, 32(S8)
9D007228  00031840   SLL V1, V1, 1
9D00722C  24420294   ADDIU V0, V0, 660
9D007230  00621021   ADDU V0, V1, V0
9D007234  94420000   LHU V0, 0(V0)
9D007238  24420001   ADDIU V0, V0, 1
9D00723C  3043FFFF   ANDI V1, V0, -1
9D007240  3C02A000   LUI V0, -24576
9D007244  8FC40020   LW A0, 32(S8)
9D007248  00042040   SLL A0, A0, 1
9D00724C  24420294   ADDIU V0, V0, 660
9D007250  00821021   ADDU V0, A0, V0
9D007254  A4430000   SH V1, 0(V0)
672:                 
673:                 			// this is a bit of a kludge, because we do not exit the COASTING state based on a state MSI tick count
674:                 			BITCLEAR(efMotionEvents[eMotor], EF_MOTION_MSI_COUNT_DONE);		// unconditionally clear flag
9D007258  3C02A000   LUI V0, -24576
9D00725C  8FC30020   LW V1, 32(S8)
9D007260  00031840   SLL V1, V1, 1
9D007264  244202D8   ADDIU V0, V0, 728
9D007268  00621021   ADDU V0, V1, V0
9D00726C  94430000   LHU V1, 0(V0)
9D007270  2402FDFF   ADDIU V0, ZERO, -513
9D007274  00621024   AND V0, V1, V0
9D007278  3043FFFF   ANDI V1, V0, -1
9D00727C  3C02A000   LUI V0, -24576
9D007280  8FC40020   LW A0, 32(S8)
9D007284  00042040   SLL A0, A0, 1
9D007288  244202D8   ADDIU V0, V0, 728
9D00728C  00821021   ADDU V0, A0, V0
9D007290  A4430000   SH V1, 0(V0)
675:                 			break;
9D007294  0B401CAB   J 0x9D0072AC
9D007298  00000000   NOP
676:                 
677:                 		case PHASE_INIT:					// not even valid here
678:                 		default:
679:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_PHASE);
9D00729C  24040095   ADDIU A0, ZERO, 149
9D0072A0  0F40365E   JAL _RuntimeError
9D0072A4  00000000   NOP
680:                 			break;
9D0072A8  00000000   NOP
681:                 		}
682:                 
683:                 
684:                 
685:                 	//********************************************
686:                 	//			Calculate Speed
687:                 	//********************************************
688:                 	// (this does not involve any more measurements, so it does not HAVE to be in the ISR)
689:                 
690:                 	switch(pgeMotionType[eMotor])
9D0072AC  3C02A000   LUI V0, -24576
9D0072B0  8FC30020   LW V1, 32(S8)
9D0072B4  00031880   SLL V1, V1, 2
9D0072B8  2442026C   ADDIU V0, V0, 620
9D0072BC  00621021   ADDU V0, V1, V0
9D0072C0  8C420000   LW V0, 0(V0)
9D0072C4  24030003   ADDIU V1, ZERO, 3
9D0072C8  10430021   BEQ V0, V1, 0x9D007350
9D0072CC  00000000   NOP
9D0072D0  2C430004   SLTIU V1, V0, 4
9D0072D4  10600006   BEQ V1, ZERO, 0x9D0072F0
9D0072D8  00000000   NOP
9D0072DC  24030002   ADDIU V1, ZERO, 2
9D0072E0  10430008   BEQ V0, V1, 0x9D007304
9D0072E4  00000000   NOP
9D0072E8  0B401D5B   J 0x9D00756C
9D0072EC  00000000   NOP
9D0072F0  2C420006   SLTIU V0, V0, 6
9D0072F4  1040009D   BEQ V0, ZERO, 0x9D00756C
9D0072F8  00000000   NOP
9D0072FC  0B401D55   J 0x9D007554
9D007300  00000000   NOP
691:                 		{
692:                 		case MOTION_STARTING:
693:                 			// this is the FIRST MSI tick after starting up, so we cannot do any speed calculations yet
694:                 			// fgwLastTimerValue is set below
695:                 
696:                 			// this must be the first encoder interrupt after being STOPPED, so we cannot calculate speed
697:                 			pgwCurrentSpeed[eMotor] = 0;
9D007304  3C02A000   LUI V0, -24576
9D007308  8FC30020   LW V1, 32(S8)
9D00730C  00031840   SLL V1, V1, 1
9D007310  244202A0   ADDIU V0, V0, 672
9D007314  00621021   ADDU V0, V1, V0
9D007318  A4400000   SH ZERO, 0(V0)
698:                 
699:                 			// update stall counter to 1.5 times longest expected interval to avoid a motion stall during startup
700:                 			SetMotionStallCtr(eMotor, MTN_SENSOR_STARTUP_STALL_PERIOD);
9D00731C  8FC40020   LW A0, 32(S8)
9D007320  2405600F   ADDIU A1, ZERO, 24591
9D007324  0F403332   JAL SetMotionStallCtr
9D007328  00000000   NOP
701:                 
702:                 			pgeMotionType[eMotor] = MOTION_POWERED;
9D00732C  3C02A000   LUI V0, -24576
9D007330  8FC30020   LW V1, 32(S8)
9D007334  00031880   SLL V1, V1, 2
9D007338  2442026C   ADDIU V0, V0, 620
9D00733C  00621021   ADDU V0, V1, V0
9D007340  24030003   ADDIU V1, ZERO, 3
9D007344  AC430000   SW V1, 0(V0)
703:                 //	<sek>	pgeMotionType[eMotor] = MOTION_POWERED;
704:                 			break;
9D007348  0B401D5F   J 0x9D00757C
9D00734C  00000000   NOP
705:                 
706:                 		case MOTION_POWERED:
707:                 			// we have been in motion, so we can calculate speed
708:                 
709:                 			#ifdef CALC_AVERAGE_SPEED
710:                 				// keep the previous speed value
711:                 				fgwLastSpeed[eMotor] = pgwCurrentSpeed[eMotor];
712:                 			#endif
713:                 
714:                 			//*********************************
715:                 			//			track speed
716:                 			//*********************************
717:                 			// update the speed value (in 34.7uS ticks)
718:                 			// check for (free running) counter rollover during the timed interval
719:                 			if (wCurrentTimerValue[eMotor] > fgwLastTimerValue[eMotor])
9D007350  8FC20020   LW V0, 32(S8)
9D007354  00021040   SLL V0, V0, 1
9D007358  27C30010   ADDIU V1, S8, 16
9D00735C  00621021   ADDU V0, V1, V0
9D007360  94430000   LHU V1, 0(V0)
9D007364  8FC20020   LW V0, 32(S8)
9D007368  00022040   SLL A0, V0, 1
9D00736C  2782804C   ADDIU V0, GP, -32692
9D007370  00821021   ADDU V0, A0, V0
9D007374  94420000   LHU V0, 0(V0)
9D007378  0043102B   SLTU V0, V0, V1
9D00737C  10400015   BEQ V0, ZERO, 0x9D0073D4
9D007380  00000000   NOP
720:                 				{
721:                 				// no counter rollover
722:                 				// calculate speed (number of counter ticks) since last interrupt, counter INCREMENTS
723:                 				pgwCurrentSpeed[eMotor] = wCurrentTimerValue[eMotor] - fgwLastTimerValue[eMotor];
9D007384  8FC20020   LW V0, 32(S8)
9D007388  00021040   SLL V0, V0, 1
9D00738C  27C30010   ADDIU V1, S8, 16
9D007390  00621021   ADDU V0, V1, V0
9D007394  94430000   LHU V1, 0(V0)
9D007398  8FC20020   LW V0, 32(S8)
9D00739C  00022040   SLL A0, V0, 1
9D0073A0  2782804C   ADDIU V0, GP, -32692
9D0073A4  00821021   ADDU V0, A0, V0
9D0073A8  94420000   LHU V0, 0(V0)
9D0073AC  00621023   SUBU V0, V1, V0
9D0073B0  3043FFFF   ANDI V1, V0, -1
9D0073B4  3C02A000   LUI V0, -24576
9D0073B8  8FC40020   LW A0, 32(S8)
9D0073BC  00042040   SLL A0, A0, 1
9D0073C0  244202A0   ADDIU V0, V0, 672
9D0073C4  00821021   ADDU V0, A0, V0
9D0073C8  A4430000   SH V1, 0(V0)
9D0073CC  0B401D09   J 0x9D007424
9D0073D0  00000000   NOP
724:                 				}
725:                 			else
726:                 				{
727:                 				// counter has rolled over
728:                 				pgwCurrentSpeed[eMotor] = wCurrentTimerValue[eMotor] + (STALL_TMR_MAX_VALUE - fgwLastTimerValue[eMotor]);
9D0073D4  8FC20020   LW V0, 32(S8)
9D0073D8  00021040   SLL V0, V0, 1
9D0073DC  27C30010   ADDIU V1, S8, 16
9D0073E0  00621021   ADDU V0, V1, V0
9D0073E4  94430000   LHU V1, 0(V0)
9D0073E8  8FC20020   LW V0, 32(S8)
9D0073EC  00022040   SLL A0, V0, 1
9D0073F0  2782804C   ADDIU V0, GP, -32692
9D0073F4  00821021   ADDU V0, A0, V0
9D0073F8  94420000   LHU V0, 0(V0)
9D0073FC  00021027   NOR V0, ZERO, V0
9D007400  3042FFFF   ANDI V0, V0, -1
9D007404  00621021   ADDU V0, V1, V0
9D007408  3043FFFF   ANDI V1, V0, -1
9D00740C  3C02A000   LUI V0, -24576
9D007410  8FC40020   LW A0, 32(S8)
9D007414  00042040   SLL A0, A0, 1
9D007418  244202A0   ADDIU V0, V0, 672
9D00741C  00821021   ADDU V0, A0, V0
9D007420  A4430000   SH V1, 0(V0)
729:                 				}
730:                 
731:                 			// keep track of maximum speed - NOTE: speed is measured as a count of Tcy, so smaller is faster
732:                 			if  (pgwCurrentSpeed[eMotor] < pgMotionStats[eMotor].wMaximumSpeed)
9D007424  3C02A000   LUI V0, -24576
9D007428  8FC30020   LW V1, 32(S8)
9D00742C  00031840   SLL V1, V1, 1
9D007430  244202A0   ADDIU V0, V0, 672
9D007434  00621021   ADDU V0, V1, V0
9D007438  94430000   LHU V1, 0(V0)
9D00743C  3C02A000   LUI V0, -24576
9D007440  8FC50020   LW A1, 32(S8)
9D007444  24040060   ADDIU A0, ZERO, 96
9D007448  70A42002   MUL A0, A1, A0
9D00744C  244204CC   ADDIU V0, V0, 1228
9D007450  00821021   ADDU V0, A0, V0
9D007454  94420032   LHU V0, 50(V0)
9D007458  0062102B   SLTU V0, V1, V0
9D00745C  1040000E   BEQ V0, ZERO, 0x9D007498
9D007460  00000000   NOP
733:                 				{
734:                 				pgMotionStats[eMotor].wMaximumSpeed = pgwCurrentSpeed[eMotor];
9D007464  3C02A000   LUI V0, -24576
9D007468  8FC30020   LW V1, 32(S8)
9D00746C  00031840   SLL V1, V1, 1
9D007470  244202A0   ADDIU V0, V0, 672
9D007474  00621021   ADDU V0, V1, V0
9D007478  94430000   LHU V1, 0(V0)
9D00747C  3C02A000   LUI V0, -24576
9D007480  8FC50020   LW A1, 32(S8)
9D007484  24040060   ADDIU A0, ZERO, 96
9D007488  70A42002   MUL A0, A1, A0
9D00748C  244204CC   ADDIU V0, V0, 1228
9D007490  00821021   ADDU V0, A0, V0
9D007494  A4430032   SH V1, 50(V0)
735:                 				}
736:                 
737:                 			// keep track of minimum speed
738:                 			if  (pgwCurrentSpeed[eMotor] > pgMotionStats[eMotor].wMinimumSpeed)
9D007498  3C02A000   LUI V0, -24576
9D00749C  8FC30020   LW V1, 32(S8)
9D0074A0  00031840   SLL V1, V1, 1
9D0074A4  244202A0   ADDIU V0, V0, 672
9D0074A8  00621021   ADDU V0, V1, V0
9D0074AC  94430000   LHU V1, 0(V0)
9D0074B0  3C02A000   LUI V0, -24576
9D0074B4  8FC50020   LW A1, 32(S8)
9D0074B8  24040060   ADDIU A0, ZERO, 96
9D0074BC  70A42002   MUL A0, A1, A0
9D0074C0  244204CC   ADDIU V0, V0, 1228
9D0074C4  00821021   ADDU V0, A0, V0
9D0074C8  94420030   LHU V0, 48(V0)
9D0074CC  0043102B   SLTU V0, V0, V1
9D0074D0  1040000E   BEQ V0, ZERO, 0x9D00750C
9D0074D4  00000000   NOP
739:                 				{
740:                 				pgMotionStats[eMotor].wMinimumSpeed = pgwCurrentSpeed[eMotor];
9D0074D8  3C02A000   LUI V0, -24576
9D0074DC  8FC30020   LW V1, 32(S8)
9D0074E0  00031840   SLL V1, V1, 1
9D0074E4  244202A0   ADDIU V0, V0, 672
9D0074E8  00621021   ADDU V0, V1, V0
9D0074EC  94430000   LHU V1, 0(V0)
9D0074F0  3C02A000   LUI V0, -24576
9D0074F4  8FC50020   LW A1, 32(S8)
9D0074F8  24040060   ADDIU A0, ZERO, 96
9D0074FC  70A42002   MUL A0, A1, A0
9D007500  244204CC   ADDIU V0, V0, 1228
9D007504  00821021   ADDU V0, A0, V0
9D007508  A4430030   SH V1, 48(V0)
741:                 				}
742:                 
743:                 			// update stall counter to 1.5 times the current speed value
744:                 			// ==> WARNING: this should check for value wrap; calculation is (x) * 3 / 2
745:                 			SetMotionStallCtr(eMotor, MTN_SENSOR_MOTION_STALL_PERIOD(pgwCurrentSpeed[eMotor]));
9D00750C  3C02A000   LUI V0, -24576
9D007510  8FC30020   LW V1, 32(S8)
9D007514  00031840   SLL V1, V1, 1
9D007518  244202A0   ADDIU V0, V0, 672
9D00751C  00621021   ADDU V0, V1, V0
9D007520  94420000   LHU V0, 0(V0)
9D007524  00401821   ADDU V1, V0, ZERO
9D007528  24020003   ADDIU V0, ZERO, 3
9D00752C  70621002   MUL V0, V1, V0
9D007530  00021FC2   SRL V1, V0, 31
9D007534  00621021   ADDU V0, V1, V0
9D007538  00021043   SRA V0, V0, 1
9D00753C  8FC40020   LW A0, 32(S8)
9D007540  00402821   ADDU A1, V0, ZERO
9D007544  0F403332   JAL SetMotionStallCtr
9D007548  00000000   NOP
746:                 
747:                 			#ifdef CALC_AVERAGE_SPEED
748:                 				// calculate the average speed
749:                 				++fgwSampleCtr;
750:                 				if (fgwSampleCtr > 100)
751:                 					{
752:                 					// restart all sampling
753:                 					fgwSampleCtr = 1;
754:                 					fgwSumOfSpeeds = 0;
755:                 					fgwLastSpeed = pgwCurrentSpeed;		// to prevent meaningless Error From Sample values	
756:                 					}
757:                 	
758:                 				fgwSumOfSpeeds += pgwCurrentSpeed;
759:                 				pgwAverageSpeed = fgwSumOfSpeeds / fgwSampleCtr;		// note that sampleCtr is at LEAST 1
760:                 	
761:                 				// calculate error from average speed
762:                 				pgnErrorFromAverage = (int)pgwAverageSpeed - (int)pgwCurrentSpeed;
763:                 	
764:                 				// calculate error from most recent sample
765:                 				pgnErrorFromSample = (int)fgwLastSpeed - (int)pgwCurrentSpeed;
766:                 			#endif
767:                 
768:                 			break;
9D00754C  0B401D5F   J 0x9D00757C
9D007550  00000000   NOP
769:                 
770:                 		case MOTION_COASTING:			// motor is OFF, some coasting MAY occur
771:                 		case MOTION_BRAKING:
772:                 			// power is off, and we are COASTING, this is processed just see how long we coast!
773:                 
774:                 			// this must be the first encoder interrupt after being STOPPED, so we cannot calculate speed
775:                 //			pgwCurrentSpeed = 0;
776:                 
777:                 			// update stall counter to 1.5 times longest expected interval
778:                 			SetMotionStallCtr(eMotor, MTN_SENSOR_COASTING_STALL_PERIOD);
9D007554  8FC40020   LW A0, 32(S8)
9D007558  24053007   ADDIU A1, ZERO, 12295
9D00755C  0F403332   JAL SetMotionStallCtr
9D007560  00000000   NOP
779:                 
780:                 			////RuntimeError(MTN_SENSOR_ERROR_COASTING_INT);		// this is an event, not an error!
781:                 			break;
9D007564  0B401D5F   J 0x9D00757C
9D007568  00000000   NOP
782:                 
783:                 		case MOTION_INIT:				// initial state, only at power up
784:                 		case MOTION_STOPPED:			// motion has actually STOPPED (Optical Wheel tick timeout)
785:                 		case MOTION_STALLED:			// system has STALLED; no exit
786:                 		default:
787:                 			RuntimeError(MTN_SENSOR_ERROR_INVALID_MOTION_TYPE_INT);
9D00756C  2404009A   ADDIU A0, ZERO, 154
9D007570  0F40365E   JAL _RuntimeError
9D007574  00000000   NOP
788:                 			break;
9D007578  00000000   NOP
789:                 		}		// end 	switch(pgeMotionType[eMotor])
790:                 
791:                 
792:                 	// update stored timer value for next interrupt calculation
793:                 	fgwLastTimerValue[eMotor] = wCurrentTimerValue[eMotor];
9D00757C  8FC20020   LW V0, 32(S8)
9D007580  00021040   SLL V0, V0, 1
9D007584  27C30010   ADDIU V1, S8, 16
9D007588  00621021   ADDU V0, V1, V0
9D00758C  94430000   LHU V1, 0(V0)
9D007590  8FC20020   LW V0, 32(S8)
9D007594  00022040   SLL A0, V0, 1
9D007598  2782804C   ADDIU V0, GP, -32692
9D00759C  00821021   ADDU V0, A0, V0
9D0075A0  A4430000   SH V1, 0(V0)
794:                 
795:                 
796:                 	//********************************************
797:                 	//		foreground processing flag
798:                 	//********************************************
799:                 	// check for MSI tick overrun (if the flag is still set from the previous interrupt, the foreground loop did not process the flag in time)
800:                 	// (this ABSOLUTELY needs to be in the ISR)
801:                 	if (IS_BITSET(efMotionSensorEvents[eMotor], EF_MOTION_SENSOR_TICK))
9D0075A4  3C02A000   LUI V0, -24576
9D0075A8  8FC30020   LW V1, 32(S8)
9D0075AC  00031840   SLL V1, V1, 1
9D0075B0  244202C8   ADDIU V0, V0, 712
9D0075B4  00621021   ADDU V0, V1, V0
9D0075B8  94420000   LHU V0, 0(V0)
9D0075BC  30420002   ANDI V0, V0, 2
9D0075C0  10400004   BEQ V0, ZERO, 0x9D0075D4
9D0075C4  00000000   NOP
802:                 		{
803:                 		RuntimeError(MTN_SENSOR_ERROR_FOREGROUND_TICK_OVERRUN);
9D0075C8  24040098   ADDIU A0, ZERO, 152
9D0075CC  0F40365E   JAL _RuntimeError
9D0075D0  00000000   NOP
804:                 		}
805:                 
806:                 	// set event flag for foreground loop processing
807:                 	BITSET(efMotionSensorEvents[eMotor], EF_MOTION_SENSOR_TICK);
9D0075D4  3C02A000   LUI V0, -24576
9D0075D8  8FC30020   LW V1, 32(S8)
9D0075DC  00031840   SLL V1, V1, 1
9D0075E0  244202C8   ADDIU V0, V0, 712
9D0075E4  00621021   ADDU V0, V1, V0
9D0075E8  94420000   LHU V0, 0(V0)
9D0075EC  34420002   ORI V0, V0, 2
9D0075F0  3043FFFF   ANDI V1, V0, -1
9D0075F4  3C02A000   LUI V0, -24576
9D0075F8  8FC40020   LW A0, 32(S8)
9D0075FC  00042040   SLL A0, A0, 1
9D007600  244202C8   ADDIU V0, V0, 712
9D007604  00821021   ADDU V0, A0, V0
9D007608  A4430000   SH V1, 0(V0)
808:                 
809:                 }
9D00760C  03C0E821   ADDU SP, S8, ZERO
9D007610  8FBF001C   LW RA, 28(SP)
9D007614  8FBE0018   LW S8, 24(SP)
9D007618  27BD0020   ADDIU SP, SP, 32
9D00761C  03E00008   JR RA
9D007620  00000000   NOP
810:                 
811:                 
812:                 // end of Encoder.
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/MenuFSM.c  -----------------------
1:                   //*************************************************************************************************
2:                   //										M e n u F S M . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Debug Serial Menu
8:                   //
9:                   //		001	19 Feb 13 <sek> created from gsf Code Base
10:                  //		002	06 Feb 13 <sek> PWM value readback
11:                  //		003	06 Feb 13 <sek> all timer values
12:                  //		004	09 Feb 13 <sek> OpenLoopMoveMenu(), ClosedLoopMoveMenu()
13:                  //		005	09 Mar 13 <sek> handle two motors
14:                  //		006	16 Mar 13 <sek> changed HEI (hall effect int) to MSI (motion sensor int)
15:                  //		007 18 Mar 13 <sek> replaced fixed SYS_FREQ with GetPeripheralClock() to allow prescaler for peripheral clock
16:                  //
17:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
18:                  //					gsf Engineering	978-927-7189
19:                  //					Beverly, MA 01915
20:                  //
21:                  //		copyright (c) 2013 gsf Engineering (Beverly, MA USA) for SmartTrak Solar Systems Pvt, Hyderabad, AP, India
22:                  //
23:                  //*************************************************************************************************
24:                  
25:                  #include <GenericTypeDefs.h>
26:                  
27:                  //lint -e765					error 765: (Info -- external function could be made static)
28:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
29:                  #include <plib.h>						// Microchip PIC32 peripheral library main header
30:                  //lint +e14
31:                  
32:                  #include <string.h>				// Microchip string functions
33:                  								// see hlpC18.chm online help for so-called documentation
34:                  #include <ctype.h>				// tolower()
35:                  
36:                  #include "gsfstd.h"				// gsf standard #defines
37:                  #include "Debug.h"
38:                  #include "SmartTrak.h"			// Project wide definitions
39:                  #include "HardwareProfile.h"
40:                  
41:                  #include "EventFlags.h"			// event flag definitions and globals
42:                  #include "SerialPort.h"
43:                  #include "SerialDisplay.h"		// display functions for menus
44:                  #include "MenuFSM.h"
45:                  #include "StrConversions.h"		// ASCII string <==> numeric conversions
46:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
47:                  
48:                  //#include "ADCRead.h"			// adc access functions
49:                  //#include "Debounce.h"			// Input Switch debounce functions
50:                  #include "MotionSensor.h"		// Motion (Hall) Sensor functions
51:                  #include "MotorPWM.h"			// Motor PWM function prototypes
52:                  #include "MotionFSM.h"			// Motion FSM state strings
53:                  //#include "MoveSequenceFSM.h"	// Move Sequence FSM function prototypes, Move-to-end FSM state strings
54:                  //#include "CommandFSM.h"		// eMoveType
55:                  //#include "MotionStats.h"		// MotionStats structure
56:                  //#include "MotionLimits.h"		// Motion Limits functions, variables
57:                  
58:                  #include "Stubs.h"
59:                  
60:                  #ifdef DEFINE_GLOBALS
61:                  	#error "DEFINE_GLOBALS not expected here"
62:                  #endif
63:                  
64:                  
65:                  //-------------------------------------------------------------------------------------------------------
66:                  // Definitions
67:                  //-------------------------------------------------------------------------------------------------------
68:                  
69:                  enum tagMenuFSMErrors
70:                  {
71:                  	MENU_FSM_ERROR_NONE = MENU_FSM_ERROR_BASE,
72:                  	MENU_FSM_ERROR_UNEXPECTED_TICK,			// 1 unexpected timer tick event
73:                  	MENU_FSM_ERROR_UNEXPECTED_EVENT,		// 2 unexpected event
74:                  	MENU_FSM_ERROR_INVALID_STATE,			// 3 not a valid state
75:                  	MENU_FSM_ERROR_INVALID_SUBSTATE,		// 4 not a valid state
76:                  	MENU_FSM_ERROR_INVALID_SELECTION,		// 5 not a valid selection
77:                  	MENU_FSM_ERROR_UNKNOWN_COMMAND,			// 6 not a valid command
78:                  	MENU_FSM_ERROR_INVALID_PARAMETER,		// 7 not a valid parameter selection
79:                  	MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER,	// 8 not a valid parameter selection
80:                  	MENU_FSM_ERROR_INVALID_MENU,			// 9 not a valid state
81:                  	MENU_FSM_ERROR_BUFFER_OVERFLOW,			// 10 menu string too long
82:                  	MENU_FSM_ERROR_COMMAND_OVERRUN,			// 11 command not executed or complete overrun
83:                  
84:                  	MENU_FSM_UNPROCESSED_EVENT = MENU_FSM_ERROR_BASE + 0x0F
85:                  
86:                  };
87:                  
88:                  
89:                  //-------------------------------------------------------------------------------------------------------
90:                  // Forward References - File Local function Definitions
91:                  //-------------------------------------------------------------------------------------------------------
92:                  
93:                  // menu functions
94:                  BOOL DisplayMenu(UART_MODULE UARTid);
95:                  BOOL DisplayStatus(UART_MODULE UARTid);
96:                  BOOL DisplayResult(UART_MODULE UARTid);
97:                  
98:                  int MainMenu(char);
99:                  int StatusMenu(char);
100:                 int MotionSettingsMenu(UART_MODULE UARTid, char);
101:                 int OpenLoopMoveMenu(UART_MODULE UARTid, char);
102:                 int ClosedLoopMoveMenu(UART_MODULE UARTid, char);
103:                 int MoveSequenceMenu(char);
104:                 int SystemParametersMenu(char);
105:                 int LocationParametersMenu(UART_MODULE UARTid, char);
106:                 int AzimuthParametersMenu(UART_MODULE UARTid, char);
107:                 int ElevationParametersMenu(UART_MODULE UARTid, char);
108:                 int ReadInputsMenu(char);
109:                 
110:                 //-------------------------------------------------------------------------------------------------------
111:                 // File Local - Global Variables
112:                 //-------------------------------------------------------------------------------------------------------
113:                 
114:                 FILE_GLOBAL	SmartTrakOrientation CurrentOrientation;
115:                 
116:                 FILE_GLOBAL_INIT float	fgfCLMoveDistance = 0.0;
117:                 
118:                 FILE_GLOBAL_INIT WORD	gwErrorDisplayIndex = 0;
119:                 
120:                 //-----------------------------------------------
121:                 // Keep track of Menu selection
122:                 PRIVATE_INIT BYTE bMenuFSMSequenceCtr = 0;					// substate sequence counter
123:                 PRIVATE_INIT BYTE fSubStateStatus = SUBSTATE_NOT_DONE;		// substate status flag
124:                 
125:                 #define	NOTHING_SELECTED			0
126:                 #define MENU_SELECTED				1
127:                 #define COMMAND_SELECTED			2
128:                 #define PARAMETER_SELECTED			3
129:                 #define DATA_STREAM_SELECTED		4
130:                 #define REALTIME_DATA_SELECTED		5
131:                 
132:                 
133:                 PRIVATE_INIT int fSelection = MENU_SELECTED;
134:                 
135:                 
136:                 //-----------------------------------------------
137:                 // Motion Control FSM states
138:                 enum tagMenuStates
139:                 {
140:                     ST_MENU_INIT,						// initial state, only at power up
141:                 
142:                     ST_MENU_DISPLAY_MENU,
143:                 	ST_MENU_WAIT_FOR_KEYSTROKE,			// waiting for menu (or command) selection keystroke
144:                 	ST_MENU_WAIT_FOR_PARAMETER_AND_CR,	// collecting keystrokes and waiting for CR terminator
145:                 //	ST_MENU_WAIT_FOR_CR,
146:                 	ST_MENU_PROCESS_COMMAND,
147:                 	ST_MENU_DISPLAY_STREAMING_DATA,		// streaming data is generated by MenuFSM(), and may appear as under-sampled data (i.e not all data is displayed)
148:                 	ST_MENU_CHECK_FOR_TERMINATING_KEYSTROKE,
149:                 	ST_MENU_DISPLAY_REALTIME_DATA,		// realtime streaming data is generated elsewhere, and is only controlled (on/off) by MenuFSM
150:                 	ST_MENU_DISPLAY_RESULT
151:                 
152:                 };
153:                 
154:                 PRIVATE_INIT enum tagMenuStates stMenuState = ST_MENU_INIT;
155:                 
156:                 
157:                 //-----------------------------------------------
158:                 // keep track of selected menu
159:                 enum tagMenus
160:                 {
161:                     MAIN_MENU,
162:                 	STATUS_MENU,
163:                     MOTION_SETTINGS_MENU,
164:                 	OPEN_LOOP_MOVE_MENU,
165:                 	CLOSED_LOOP_MOVE_MENU,
166:                 	MOVE_SEQUENCE_MENU,
167:                 	SYSTEM_PARAMETERS_MENU,
168:                 	LOCATION_PARAMETERS_MENU,
169:                 	AZIMUTH_PARAMETERS_MENU,
170:                 	ELEVATION_PARAMETERS_MENU,
171:                 	READ_INPUTS_MENU
172:                 };
173:                 
174:                 PRIVATE_INIT enum tagMenus eCurrentMenu = MAIN_MENU;
175:                 
176:                 
177:                 //-----------------------------------------------
178:                 // substate to keep track of multi-line menu display
179:                 // only one line displayed per call to MenuFSM()
180:                 enum tagMenuLine
181:                 {
182:                     MENU_SINGLE_LINE,				// menu display has just one line (not actually possible)
183:                 	MENU_LINE,						// line 1 to n
184:                     MENU_LAST_LINE					// last line to display
185:                 };
186:                 
187:                 
188:                 PRIVATE_INIT enum tagMenuLine eMenuLine = MENU_LINE;
189:                 
190:                 
191:                 //-----------------------------------------------
192:                 // substate to keep track of multi-line result display
193:                 enum tagResultLine
194:                 {
195:                     RESULT_SINGLE_LINE,				// result display has just one line
196:                 	RESULT_LINE,					// line 1 to n
197:                     RESULT_LAST_LINE				// last line to display
198:                 };
199:                 
200:                 
201:                 PRIVATE_INIT enum tagResultLine eResultLine = RESULT_LINE;
202:                 PRIVATE WORD fgwDisplayLineCtr;
203:                 
204:                 // specify which multi-line output block to display
205:                 enum tagResultDisplay
206:                 {
207:                     RESULT_NONE,
208:                     RESULT_STATUS_LAST_MOVEMENT,
209:                 	RESULT_READ_REGISTERS_MTN_SENSOR_SETTINGS,
210:                 	RESULT_READ_REGISTERS_PWM_SETTINGS,
211:                     RESULT_MOTOR_PWM_WIDTHS,
212:                     RESULT_READ_INPUTS_MOTION_SENSORS,
213:                     RESULT_READ_REGISTERS_TIMERS,
214:                     RESULT_READ_REGISTERS_ADC_SETTINGS,
215:                     RESULT_READ_INPUTS_ADC,
216:                     RESULT_READ_INPUTS_SWITCHES
217:                 
218:                 };
219:                 
220:                 
221:                 PRIVATE_INIT enum tagResultDisplay eResultType = RESULT_NONE;
222:                 
223:                 //-----------------------------------------------
224:                 // keep track of selected streaming data type
225:                 enum tagStatus
226:                 {
227:                     FSM_STATUS,					// continuous until a serial terminal key hit
228:                     MOTOR_STATUS,				// continuous until a serial terminal key hit
229:                 	INPUT_SWITCH_STATUS,		// continuous until a serial terminal key hit
230:                 	RUNTIME_ERROR_STATUS		// until out of data OR serial terminal key hit
231:                 };
232:                 
233:                 PRIVATE_INIT enum tagStatus eCurrentStatus = FSM_STATUS;
234:                 
235:                 
236:                 //-----------------------------------------------
237:                 // substate to keep track of status display
238:                 enum tagStreamLine
239:                 {
240:                     STREAM_FIRST_LINE,
241:                 	STREAM_LINE,
242:                     STREAM_LAST_LINE
243:                 };
244:                 
245:                 PRIVATE_INIT enum tagStreamLine eStreamLine = STREAM_FIRST_LINE;
246:                 
247:                 //-----------------------------------------------
248:                 // keep track of parameter to update
249:                 
250:                 enum tagParameter
251:                 {
252:                 	PARAMETER_NONE,
253:                 
254:                 	PARAMETER_LATITUDE,
255:                 	PARAMETER_LONGITUDE,
256:                 	PARAMETER_ELEVATION,
257:                 	PARAMETER_REFRACTION,
258:                 	PARAMETER_TIMEZONE,
259:                 	PARAMETER_TRACKER_STATE,
260:                 
261:                 	PARAMETER_ELEVATION_DUTY_CYCLE,
262:                 	PARAMETER_AZIMUTH_DUTY_CYCLE,
263:                 	PARAMETER_MOVE_DISTANCE
264:                 };
265:                 
266:                 PRIVATE_INIT enum tagParameter eParameter = PARAMETER_NONE;
267:                 
268:                 BOOL UpdateParameter(enum tagParameter eParameterToUpdate);
269:                 
270:                 
271:                 //-----------------------------------------------
272:                 
273:                 //-------------------------------------------------------------------------------------------------------
274:                 // Menu Display Functions, including fixed Menu Strings
275:                 //-------------------------------------------------------------------------------------------------------
276:                 
277:                 // starts with:
278:                 //		Clear screen: ESC [ 2 J
279:                 //		Home cursor: ESC [ ROW ; COL H 
280:                 
281:                 // note this is a pointer to an array of pointers
282:                 FILE_GLOBAL	const char **fgpMenuText;
283:                 
284:                 // this is setup as an array of pointers
285:                 FILE_GLOBAL ARRAY  const char *pstrMainMenuText[] =
286:                 	{
287:                 	"\x1B[2J\x1B[0;0H==SmartTrak Solar Panel Controller: (" __DATE__ "," __TIME__ ")",
288:                 	"1) Status",
289:                 	"2) Motion Settings",
290:                 	"3) Open Loop Move",
291:                 	"4) Closed Loop Move",
292:                 	"5) Move Sequence",
293:                 	"6) System Parameters",
294:                 	"7) Read Inputs",
295:                 	""
296:                 	};
297:                 
298:                 	FILE_GLOBAL ARRAY  const char *pstrStatusMenuText[] =
299:                 		{
300:                 		"\n\r",
301:                 		"1) last move",
302:                 		"2) stream FSM States",
303:                 		"3) stream Motion Status",
304:                 		"4) stream Input Switches",
305:                 		"5) stream Runtime Errors",
306:                 		" x) Exit Menu",
307:                 		""
308:                 		};
309:                 
310:                 	FILE_GLOBAL ARRAY  const char *pstrMotionSettingsMenuText[] =
311:                 		{
312:                 		"\n\r",
313:                 		"1) Motion Sensor (Input Capture) register values",
314:                 		"2) PWM (Output Capture) register values",
315:                 		"3) current PWM duty cycles",
316:                 		"4) change Elevation PWM duty cycle",
317:                 		"5) change Azimuth PWM duty cycle",
318:                 		" x) Exit Menu",
319:                 		""
320:                 		};
321:                 
322:                 	FILE_GLOBAL ARRAY const char *pstrOpenLoopMoveMenuText[] =
323:                 		{
324:                 		"\n\r",
325:                 		"1) change Elevation PWM duty cycle",
326:                 		"2) run up",
327:                 		"3) run down",
328:                 		"4) change Azimuth PWM duty cycle",
329:                 		"5) run right",
330:                 		"6) run left",
331:                 		"s) stop",
332:                 		"r) reset (NOT in Debug)",
333:                 		" x) Exit Menu",
334:                 		""
335:                 		};
336:                 
337:                 	FILE_GLOBAL ARRAY const char *pstrClosedLoopMoveMenuText[] =
338:                 		{
339:                 		"\n\r",
340:                 		"1) set move distance (degrees)",
341:                 		"2) move (distance) up",
342:                 		"3) move (distance) down",
343:                 		"4) move (distance) right",
344:                 		"5) move (distance) left",
345:                 		"6) move up to end",
346:                 		"7) move down to end",
347:                 		"8) move right to end",
348:                 		"9) move left to end",
349:                 		"a) one (encoder) rotation up",
350:                 		"b) one (encoder) rotation down",
351:                 		"c) one (encoder) rotation right",
352:                 		"f) one (encoder) rotation left",
353:                 		"s) stop",
354:                 		"r) reset (NOT in Debug)",
355:                 		" x) Exit Menu",
356:                 		""
357:                 		};
358:                 
359:                 	FILE_GLOBAL ARRAY  const char *pstrMoveSequenceMenuText[] =
360:                 		{
361:                 		"\n\r",
362:                 		"1) find end points",
363:                 		"2) move to center position",
364:                 		"3) move to Night Stow",
365:                 		"4) move to Wind Stow",
366:                 		"5) move to SPA track",
367:                 		"6) move 0.5 degree up",
368:                 		"7) move 0.5 degree down",
369:                 		"8) move 0.5 degree right",
370:                 		"9) move 0.5 degree left",
371:                 		"a) move 1 degree up",
372:                 		"b) move 1 degree up",
373:                 		"c) move 1 degree up",
374:                 		"d) move 1 degree up",
375:                 		"s) stop",
376:                 		"r) reset (NOT in Debug)",
377:                 		" x) Exit Menu",
378:                 		""
379:                 		};
380:                 
381:                 	FILE_GLOBAL ARRAY  const char *pstrSystemParametersMenuText[] =
382:                 		{
383:                 		"\n\r",
384:                 		"1) Unit Location",
385:                 		"2) Azimuth Settings",
386:                 		"3) Elevation Settings",
387:                 		"4) Write Parameters to Flash",
388:                 		" x) Exit Menu",
389:                 		""
390:                 		};
391:                 
392:                 		FILE_GLOBAL ARRAY  const char *pstrUnitLocationParametersMenuText[] =
393:                 			{
394:                 			"\n\r",
395:                 			"1) fLatitude",			// R/W, In degrees. Range = +90 degrees to -90 degrees, Positive for north of the equator.
396:                 			"2) fLongitude",		// R/W, In degrees. Range = -180 to +180deg, Positive for east of GMT
397:                 			"3) fElevation",		// Float R/W In meters. Above sea level.
398:                 			"4) fRefraction",		// Float R/W No units. Value is around 1.
399:                 			"5) fTimeZone",			// Float R/W Offset from GMT (like 5.5 for India)
400:                 			"6) ucTracker_State",	// Int (enum) R/W Values: Tracking, Night Stow, Wind Stow
401:                 									// TBD: make it read only? May need write permission for testing purpose
402:                 			" x) Exit Menu",
403:                 			""
404:                 			};
405:                 
406:                 		FILE_GLOBAL ARRAY  const char *pstrAzimuthParametersMenuText[] =
407:                 			{
408:                 			"\n\r",
409:                 			"1) unAZ_PulsesPerRot",			// Int R/W Motor setting. Number of hall pulses to complete 360deg rotation of the azimuth drive.
410:                 			"2) fAZ_SoftLim_Min",			// Float R/W Azimuth soft limit minimum. Units: degrees
411:                 			"3) fAZ_SoftLim_Max",			// Float R/W Azimuth soft limit maximum. Units: degrees
412:                 			"4) fAZ_DeadBand",				// Float R/W TBD
413:                 			"5) fAZ_NightStow",				// Float R/W Default = 0 (remain in place)
414:                 			"6) fAZ_WindStow",				// Float R/W Default = 0 (remain in place)
415:                 			"7) fAZ_SetPoint",				// Float R/W This comes from SPA_calc, but limited by soft limits
416:                 			"8) fAZ_PVpos",					// Float R only This is the present position of the PV panel. This is calculated based on AZ_PulseCount.
417:                 			"9) unAZ_PulseCount",			// Int R only This is the number of hall pulses.
418:                 			"a) bAZ_En_AutoCal",			// Bool R/W
419:                 			"b) bAZ_AutoMove",				// Bool, R/W	True: Move the motor to AZ_SetPoint
420:                 											//				False: Move the motor only upon soft/hard joystick operation (soft= cmds; hard =push buttons)
421:                 			"c) fAZ_cal_param1",			// Float R/W TBD: could be needed for cal correction
422:                 			"d) fAZ_cal_param2",			// Float R/W TBD: could be needed for cal correction
423:                 			" x) Exit Menu",
424:                 			""
425:                 			};
426:                 
427:                 		FILE_GLOBAL ARRAY  const char *pstrElevationParametersMenuText[] =
428:                 			{
429:                 			"\n\r",
430:                 			"1) unEL_PulsesPerRot",			// Int R/W Motor setting. Number of hall pulses to complete 360deg rotation of the azimuth drive.
431:                 			"2) fEL_SoftLim_Min",			// Float R/W Azimuth soft limit minimum. Units: degrees
432:                 			"3) fEL_SoftLim_Max",			// Float R/W Azimuth soft limit maximum. Units: degrees
433:                 			"4) fEL_DeadBand",				// Float R/W TBD
434:                 			"5) fEL_NightStow",				// Float R/W Default = 0 (remain in place)
435:                 			"6) fEL_WindStow",				// Float R/W Default = 0 (remain in place)
436:                 			"7) fEL_SetPoint",				// Float R/W This comes from SPA_calc, but limited by soft limits
437:                 			"8) fEL_PVpos",					// Float R only This is the present position of the PV panel. This is calculated based on EL_PulseCount.
438:                 			"9) unEL_PulseCount",			// Int R only This is the number of hall pulses.
439:                 			"a) bEL_En_AutoCal",			// Bool R/W
440:                 			"b) bEL_AutoMove",				// Bool, R/W	True: Move the motor to EL_SetPoint
441:                 											//				False: Move the motor only upon soft/hard joystick operation (soft= cmds; hard =push buttons)
442:                 			"c) fEL_cal_param1",			// Float R/W TBD: could be needed for cal correction
443:                 			"d) fEL_cal_param2",			// Float R/W TBD: could be needed for cal correction
444:                 			" x) Exit Menu",
445:                 			""
446:                 			};
447:                 
448:                 
449:                 
450:                 	FILE_GLOBAL ARRAY  const char *pstrReadInputsMenuText[] =
451:                 		{
452:                 		"\n\r",
453:                 		"1) Motion (Hall) Sensor Inputs",
454:                 		"2) Motion (Hall) Sensor counter values",
455:                 		"3) Timer values",
456:                 		"4) ADC register values",
457:                 		"5) ADC Measurement values",
458:                 		"6) Switch Input values",
459:                 		" x) Exit Menu",
460:                 		""
461:                 		};
462:                 
463:                 
464:                 //*****************************************************************************
465:                 //								M e n u F S M ( ) 
466:                 //*****************************************************************************
467:                 
468:                 // this is the TOP level menu function, called every 25mS from the sequencer
469:                 
470:                 void MenuFSM(UART_MODULE UARTid)
471:                 {
9D000020  27BDFFD8   ADDIU SP, SP, -40
9D000024  AFBF0024   SW RA, 36(SP)
9D000028  AFBE0020   SW S8, 32(SP)
9D00002C  AFB0001C   SW S0, 28(SP)
9D000030  03A0F021   ADDU S8, SP, ZERO
9D000034  AFC40028   SW A0, 40(S8)
472:                 
473:                 	PERSISTENT_LOCAL_INIT UINT8 bInputBufferIndex = 0;
474:                 	BOOL bValueValid;
475:                 
476:                     // *************************************************
477:                     //		    State Transition
478:                     // *************************************************
479:                     // state transitions are based on:
480:                     //
481:                 	//	    external events
482:                     //		state complete
483:                     //
484:                     // state transitions handle setting up everything BEFORE entering the new state
485:                     // if there is no need for a transition, we just stay in the current state
486:                 
487:                 	// external events may indicate multiple, contradictory state transitions.
488:                 	// the order of processing of external events determines their absolute priority; the FIRST successfully processed transition will actually occur
489:                 
490:                 	switch(stMenuState)
9D000038  8F828108   LW V0, -32504(GP)
9D00003C  2C430009   SLTIU V1, V0, 9
9D000040  106000E8   BEQ V1, ZERO, 0x9D0003E4
9D000044  00000000   NOP
9D000048  00021880   SLL V1, V0, 2
9D00004C  3C029D00   LUI V0, -25344
9D000050  24420064   ADDIU V0, V0, 100
9D000054  00621021   ADDU V0, V1, V0
9D000058  8C420000   LW V0, 0(V0)
9D00005C  00400008   JR V0
9D000060  00000000   NOP
491:                 		{
492:                 		case ST_MENU_INIT:				// initial state, only at power up
493:                 			stMenuState = ST_MENU_DISPLAY_MENU;
9D000088  24020001   ADDIU V0, ZERO, 1
9D00008C  AF828108   SW V0, -32504(GP)
494:                 			fSubStateStatus = SUBSTATE_NOT_DONE;
9D000090  A3808107   SB ZERO, -32505(GP)
495:                             bMenuFSMSequenceCtr = 0;
9D000094  A3808106   SB ZERO, -32506(GP)
496:                 			eCurrentMenu = MAIN_MENU;
9D000098  AF80810C   SW ZERO, -32500(GP)
497:                 			eSerialOutputMode = SER_MODE_MENU;
9D00009C  24020001   ADDIU V0, ZERO, 1
9D0000A0  AF828070   SW V0, -32656(GP)
498:                 			break;
9D0000A4  0B40011D   J 0x9D000474
9D0000A8  00000000   NOP
499:                 
500:                 		case ST_MENU_DISPLAY_MENU:
501:                 			// check for menu display complete
502:                         	if ((fSubStateStatus IS SUBSTATE_DONE) AND (eMenuLine IS MENU_LINE))
9D0000AC  93838107   LBU V1, -32505(GP)
9D0000B0  24020001   ADDIU V0, ZERO, 1
9D0000B4  1462000A   BNE V1, V0, 0x9D0000E0
9D0000B8  00000000   NOP
9D0000BC  8F838044   LW V1, -32700(GP)
9D0000C0  24020001   ADDIU V0, ZERO, 1
9D0000C4  14620006   BNE V1, V0, 0x9D0000E0
9D0000C8  00000000   NOP
503:                 				{
504:                 				// we are done with displaying ONE line, but we are not done with ALL lines
505:                 				// restart state AFTER initialization substate, so we do not restart display line counter
506:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D0000CC  A3808107   SB ZERO, -32505(GP)
507:                 				bMenuFSMSequenceCtr = 1;
9D0000D0  24020001   ADDIU V0, ZERO, 1
9D0000D4  A3828106   SB V0, -32506(GP)
508:                 				}
509:                 
510:                 			// check for done with all available data
511:                         	else if ((fSubStateStatus IS SUBSTATE_DONE) AND (eMenuLine IS MENU_LAST_LINE))
9D0000E0  93838107   LBU V1, -32505(GP)
9D0000E4  24020001   ADDIU V0, ZERO, 1
9D0000E8  146200C3   BNE V1, V0, 0x9D0003F8
9D0000EC  00000000   NOP
9D0000F0  8F838044   LW V1, -32700(GP)
9D0000F4  24020002   ADDIU V0, ZERO, 2
9D0000F8  146200C2   BNE V1, V0, 0x9D000404
9D0000FC  00000000   NOP
512:                 				{
513:                                 // we are done with last line and sequence is complete, so bump state
514:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000100  A3808107   SB ZERO, -32505(GP)
515:                 				bMenuFSMSequenceCtr = 0;
9D000104  A3808106   SB ZERO, -32506(GP)
516:                 				stMenuState = ST_MENU_WAIT_FOR_KEYSTROKE;
9D000108  24020002   ADDIU V0, ZERO, 2
9D00010C  AF828108   SW V0, -32504(GP)
517:                 				}
518:                 			// else display is not complete, so no state change
519:                 			break;
9D0000D8  0B40011D   J 0x9D000474
9D0000DC  00000000   NOP
9D000110  0B40011D   J 0x9D000474
9D000114  00000000   NOP
9D0003F8  00000000   NOP
9D0003FC  0B40011D   J 0x9D000474
9D000400  00000000   NOP
9D000404  00000000   NOP
9D000408  0B40011D   J 0x9D000474
9D00040C  00000000   NOP
520:                 
521:                 		case ST_MENU_WAIT_FOR_KEYSTROKE:
522:                 			// check for keystroke received
523:                         	if (fSubStateStatus IS SUBSTATE_DONE)
9D000118  93838107   LBU V1, -32505(GP)
9D00011C  24020001   ADDIU V0, ZERO, 1
9D000120  146200BB   BNE V1, V0, 0x9D000410
9D000124  00000000   NOP
524:                 				{
525:                                 // sequence is complete, so bump state
526:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000128  A3808107   SB ZERO, -32505(GP)
527:                 				bMenuFSMSequenceCtr = 0;
9D00012C  A3808106   SB ZERO, -32506(GP)
528:                 				stMenuState = ST_MENU_PROCESS_COMMAND;
9D000130  24020004   ADDIU V0, ZERO, 4
9D000134  AF828108   SW V0, -32504(GP)
529:                 				}
530:                 			break;
9D000138  0B40011D   J 0x9D000474
9D00013C  00000000   NOP
9D000410  00000000   NOP
9D000414  0B40011D   J 0x9D000474
9D000418  00000000   NOP
531:                 
532:                 //		case ST_MENU_WAIT_FOR_CR:
533:                 //			break;
534:                 
535:                 		case ST_MENU_PROCESS_COMMAND:
536:                 			// check for result
537:                 			switch(fSelection)
9D000140  8F828040   LW V0, -32704(GP)
9D000144  24030002   ADDIU V1, ZERO, 2
9D000148  10430015   BEQ V0, V1, 0x9D0001A0
9D00014C  00000000   NOP
9D000150  28430003   SLTI V1, V0, 3
9D000154  10600006   BEQ V1, ZERO, 0x9D000170
9D000158  00000000   NOP
9D00015C  24030001   ADDIU V1, ZERO, 1
9D000160  1043000B   BEQ V0, V1, 0x9D000190
9D000164  00000000   NOP
9D000168  0B400075   J 0x9D0001D4
9D00016C  00000000   NOP
9D000170  24030003   ADDIU V1, ZERO, 3
9D000174  1043000F   BEQ V0, V1, 0x9D0001B4
9D000178  00000000   NOP
9D00017C  24030004   ADDIU V1, ZERO, 4
9D000180  10430010   BEQ V0, V1, 0x9D0001C4
9D000184  00000000   NOP
9D000188  0B400075   J 0x9D0001D4
9D00018C  00000000   NOP
538:                 				{
539:                 				case MENU_SELECTED:
540:                 					stMenuState = ST_MENU_DISPLAY_MENU;
9D000190  24020001   ADDIU V0, ZERO, 1
9D000194  AF828108   SW V0, -32504(GP)
541:                 					break;
9D000198  0B40007B   J 0x9D0001EC
9D00019C  00000000   NOP
542:                 
543:                 				case COMMAND_SELECTED:
544:                 					stMenuState = ST_MENU_DISPLAY_RESULT;
9D0001A0  24020008   ADDIU V0, ZERO, 8
9D0001A4  AF828108   SW V0, -32504(GP)
545:                 					fgwDisplayLineCtr = 0;
9D0001A8  A7808110   SH ZERO, -32496(GP)
546:                 					break;
9D0001AC  0B40007B   J 0x9D0001EC
9D0001B0  00000000   NOP
547:                 
548:                 				case PARAMETER_SELECTED:
549:                 					stMenuState = ST_MENU_WAIT_FOR_PARAMETER_AND_CR;		// ST_MENU_WAIT_FOR_CR;
9D0001B4  24020003   ADDIU V0, ZERO, 3
9D0001B8  AF828108   SW V0, -32504(GP)
550:                 					break;
9D0001BC  0B40007B   J 0x9D0001EC
9D0001C0  00000000   NOP
551:                 
552:                 				case DATA_STREAM_SELECTED:
553:                 					stMenuState = ST_MENU_DISPLAY_STREAMING_DATA;
9D0001C4  24020005   ADDIU V0, ZERO, 5
9D0001C8  AF828108   SW V0, -32504(GP)
554:                 					break;
9D0001CC  0B40007B   J 0x9D0001EC
9D0001D0  00000000   NOP
555:                 
556:                 				default:
557:                 					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D0001D4  24040034   ADDIU A0, ZERO, 52
9D0001D8  0F40365E   JAL _RuntimeError
9D0001DC  00000000   NOP
558:                 					stMenuState = ST_MENU_DISPLAY_MENU;
9D0001E0  24020001   ADDIU V0, ZERO, 1
9D0001E4  AF828108   SW V0, -32504(GP)
559:                 					break;
9D0001E8  00000000   NOP
560:                 				}
561:                 
562:                             // clear flags
563:                 			fSubStateStatus = SUBSTATE_NOT_DONE;
9D0001EC  A3808107   SB ZERO, -32505(GP)
564:                 			bMenuFSMSequenceCtr = 0;
9D0001F0  A3808106   SB ZERO, -32506(GP)
565:                 			break;
9D0001F4  0B40011D   J 0x9D000474
9D0001F8  00000000   NOP
566:                 
567:                 		case ST_MENU_WAIT_FOR_PARAMETER_AND_CR:
568:                 			// collecting keystrokes and waiting for CR terminator
569:                 			// receieved keystroke(s) are processed in last substate, below
570:                         	if (fSubStateStatus IS SUBSTATE_DONE)
9D0001FC  93838107   LBU V1, -32505(GP)
9D000200  24020001   ADDIU V0, ZERO, 1
9D000204  14620085   BNE V1, V0, 0x9D00041C
9D000208  00000000   NOP
571:                 				{
572:                                 // sequence is complete, so bump state
573:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D00020C  A3808107   SB ZERO, -32505(GP)
574:                 				bMenuFSMSequenceCtr = 0;
9D000210  A3808106   SB ZERO, -32506(GP)
575:                 
576:                 				// stMenuState = ST_MENU_PROCESS_COMMAND;		// would it make more sense to move parameter processing to a separate state?
577:                 				stMenuState = ST_MENU_DISPLAY_MENU;
9D000214  24020001   ADDIU V0, ZERO, 1
9D000218  AF828108   SW V0, -32504(GP)
578:                 				}
579:                 			break;
9D00021C  0B40011D   J 0x9D000474
9D000220  00000000   NOP
9D00041C  00000000   NOP
9D000420  0B40011D   J 0x9D000474
9D000424  00000000   NOP
580:                 
581:                 
582:                 		case ST_MENU_DISPLAY_STREAMING_DATA:
583:                 			// check for first entry into state
584:                 			if ((fSubStateStatus IS SUBSTATE_NOT_DONE) AND (bMenuFSMSequenceCtr IS 0))
9D000224  93828107   LBU V0, -32505(GP)
9D000228  14400007   BNE V0, ZERO, 0x9D000248
9D00022C  00000000   NOP
9D000230  93828106   LBU V0, -32506(GP)
9D000234  14400004   BNE V0, ZERO, 0x9D000248
9D000238  00000000   NOP
585:                 				{
586:                 				eStreamLine = STREAM_FIRST_LINE;				// this is not actually used anywhere..
9D00023C  AF80811C   SW ZERO, -32484(GP)
9D000240  0B4000AE   J 0x9D0002B8
9D000244  00000000   NOP
587:                 				}
588:                 			// check for display of ONE LINE of streaming data complete
589:                         	else if ((fSubStateStatus IS SUBSTATE_DONE) AND (eStreamLine IS STREAM_LINE))
9D000248  93838107   LBU V1, -32505(GP)
9D00024C  24020001   ADDIU V0, ZERO, 1
9D000250  1462000B   BNE V1, V0, 0x9D000280
9D000254  00000000   NOP
9D000258  8F83811C   LW V1, -32484(GP)
9D00025C  24020001   ADDIU V0, ZERO, 1
9D000260  14620007   BNE V1, V0, 0x9D000280
9D000264  00000000   NOP
590:                 				{
591:                                 // single line sequence is complete, so bump state to check for terminating keystroke
592:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000268  A3808107   SB ZERO, -32505(GP)
593:                 				bMenuFSMSequenceCtr = 0;
9D00026C  A3808106   SB ZERO, -32506(GP)
594:                 				stMenuState = ST_MENU_CHECK_FOR_TERMINATING_KEYSTROKE;;
9D000270  24020006   ADDIU V0, ZERO, 6
9D000274  AF828108   SW V0, -32504(GP)
9D000278  0B4000AE   J 0x9D0002B8
9D00027C  00000000   NOP
595:                 				}
596:                 			// check for done with all available data
597:                         	else if ((fSubStateStatus IS SUBSTATE_DONE) AND (eStreamLine IS STREAM_LAST_LINE))
9D000280  93838107   LBU V1, -32505(GP)
9D000284  24020001   ADDIU V0, ZERO, 1
9D000288  14620067   BNE V1, V0, 0x9D000428
9D00028C  00000000   NOP
9D000290  8F83811C   LW V1, -32484(GP)
9D000294  24020002   ADDIU V0, ZERO, 2
9D000298  14620066   BNE V1, V0, 0x9D000434
9D00029C  00000000   NOP
598:                 				{
599:                                 // sequence is complete, so bump state
600:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D0002A0  A3808107   SB ZERO, -32505(GP)
601:                 				bMenuFSMSequenceCtr = 0;
9D0002A4  A3808106   SB ZERO, -32506(GP)
602:                 				stMenuState = ST_MENU_DISPLAY_MENU;
9D0002A8  24020001   ADDIU V0, ZERO, 1
9D0002AC  AF828108   SW V0, -32504(GP)
603:                 				}
604:                 
605:                 			// display is not complete, so no state change
606:                 			break;
9D0002B0  0B40011D   J 0x9D000474
9D0002B4  00000000   NOP
9D0002B8  0B40011D   J 0x9D000474
9D0002BC  00000000   NOP
9D000428  00000000   NOP
9D00042C  0B40011D   J 0x9D000474
9D000430  00000000   NOP
9D000434  00000000   NOP
9D000438  0B40011D   J 0x9D000474
9D00043C  00000000   NOP
607:                 
608:                 		case ST_MENU_CHECK_FOR_TERMINATING_KEYSTROKE:
609:                 			// check for keystroke received
610:                         	if (fSubStateStatus IS SUBSTATE_DONE)
9D0002C0  93838107   LBU V1, -32505(GP)
9D0002C4  24020001   ADDIU V0, ZERO, 1
9D0002C8  1462005D   BNE V1, V0, 0x9D000440
9D0002CC  00000000   NOP
611:                 				{
612:                 				switch(fSelection)
9D0002D0  8F828040   LW V0, -32704(GP)
9D0002D4  10400006   BEQ V0, ZERO, 0x9D0002F0
9D0002D8  00000000   NOP
9D0002DC  24030001   ADDIU V1, ZERO, 1
9D0002E0  10430007   BEQ V0, V1, 0x9D000300
9D0002E4  00000000   NOP
9D0002E8  0B4000C4   J 0x9D000310
9D0002EC  00000000   NOP
613:                 					{
614:                 					case NOTHING_SELECTED:
615:                 		                // no keystroke received, so display another line of streaming data
616:                 						stMenuState = ST_MENU_DISPLAY_STREAMING_DATA;
9D0002F0  24020005   ADDIU V0, ZERO, 5
9D0002F4  AF828108   SW V0, -32504(GP)
617:                 						break;
9D0002F8  0B4000CA   J 0x9D000328
9D0002FC  00000000   NOP
618:                 
619:                 					case MENU_SELECTED:
620:                 		                // sequence is complete (keystroke received), so bump state back to re-display menu
621:                 						stMenuState = ST_MENU_DISPLAY_MENU;
9D000300  24020001   ADDIU V0, ZERO, 1
9D000304  AF828108   SW V0, -32504(GP)
622:                 						break;
9D000308  0B4000CA   J 0x9D000328
9D00030C  00000000   NOP
623:                 
624:                 					default:
625:                 						RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000310  24040034   ADDIU A0, ZERO, 52
9D000314  0F40365E   JAL _RuntimeError
9D000318  00000000   NOP
626:                 						stMenuState = ST_MENU_DISPLAY_MENU;
9D00031C  24020001   ADDIU V0, ZERO, 1
9D000320  AF828108   SW V0, -32504(GP)
627:                 						break;
9D000324  00000000   NOP
628:                 					}
629:                 
630:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000328  A3808107   SB ZERO, -32505(GP)
631:                 				bMenuFSMSequenceCtr = 0;
9D00032C  A3808106   SB ZERO, -32506(GP)
632:                 				}
633:                 			// else not done with substates
634:                 			break;
9D000330  0B40011D   J 0x9D000474
9D000334  00000000   NOP
9D000440  00000000   NOP
9D000444  0B40011D   J 0x9D000474
9D000448  00000000   NOP
635:                 
636:                 		case ST_MENU_DISPLAY_REALTIME_DATA:
637:                 			// check for keystroke received
638:                         	if ((fSubStateStatus IS SUBSTATE_DONE) AND (fSelection IS MENU_SELECTED))
9D000338  93838107   LBU V1, -32505(GP)
9D00033C  24020001   ADDIU V0, ZERO, 1
9D000340  14620042   BNE V1, V0, 0x9D00044C
9D000344  00000000   NOP
9D000348  8F838040   LW V1, -32704(GP)
9D00034C  24020001   ADDIU V0, ZERO, 1
9D000350  14620041   BNE V1, V0, 0x9D000458
9D000354  00000000   NOP
639:                 				{
640:                 		        // sequence is complete (keystroke received), so bump state back to re-display menu
641:                 				stMenuState = ST_MENU_DISPLAY_MENU;
9D000358  24020001   ADDIU V0, ZERO, 1
9D00035C  AF828108   SW V0, -32504(GP)
642:                 
643:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000360  A3808107   SB ZERO, -32505(GP)
644:                 				bMenuFSMSequenceCtr = 0;
9D000364  A3808106   SB ZERO, -32506(GP)
645:                 				}
646:                 			// else not done with substates
647:                 			break;
9D000368  0B40011D   J 0x9D000474
9D00036C  00000000   NOP
9D00044C  00000000   NOP
9D000450  0B40011D   J 0x9D000474
9D000454  00000000   NOP
9D000458  00000000   NOP
9D00045C  0B40011D   J 0x9D000474
9D000460  00000000   NOP
648:                 
649:                 
650:                 		case ST_MENU_DISPLAY_RESULT:
651:                 			// check for display of ONE LINE of result complete
652:                         	if ((fSubStateStatus IS SUBSTATE_DONE) AND (eResultLine IS RESULT_LINE))
9D000370  93838107   LBU V1, -32505(GP)
9D000374  24020001   ADDIU V0, ZERO, 1
9D000378  14620009   BNE V1, V0, 0x9D0003A0
9D00037C  00000000   NOP
9D000380  8F838048   LW V1, -32696(GP)
9D000384  24020001   ADDIU V0, ZERO, 1
9D000388  14620005   BNE V1, V0, 0x9D0003A0
9D00038C  00000000   NOP
653:                 				{
654:                 				// we are done with displaying ONE line, but we are not done with ALL lines
655:                 				// restart state (but do not restart display line counter)
656:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D000390  A3808107   SB ZERO, -32505(GP)
657:                 				bMenuFSMSequenceCtr = 0;
9D000394  A3808106   SB ZERO, -32506(GP)
658:                 				}
659:                 
660:                 			// check for done with all available data
661:                         	else if ((fSubStateStatus IS SUBSTATE_DONE) AND ((eResultLine IS RESULT_LAST_LINE) OR (eResultLine IS RESULT_SINGLE_LINE)) )
9D0003A0  93838107   LBU V1, -32505(GP)
9D0003A4  24020001   ADDIU V0, ZERO, 1
9D0003A8  1462002E   BNE V1, V0, 0x9D000464
9D0003AC  00000000   NOP
9D0003B0  8F838048   LW V1, -32696(GP)
9D0003B4  24020002   ADDIU V0, ZERO, 2
9D0003B8  10620004   BEQ V1, V0, 0x9D0003CC
9D0003BC  00000000   NOP
9D0003C0  8F828048   LW V0, -32696(GP)
9D0003C4  1440002A   BNE V0, ZERO, 0x9D000470
9D0003C8  00000000   NOP
662:                 				{
663:                                 // we are done with last line and sequence is complete, so bump state
664:                 				fSubStateStatus = SUBSTATE_NOT_DONE;
9D0003CC  A3808107   SB ZERO, -32505(GP)
665:                 				bMenuFSMSequenceCtr = 0;
9D0003D0  A3808106   SB ZERO, -32506(GP)
666:                 				stMenuState = ST_MENU_DISPLAY_MENU;
9D0003D4  24020001   ADDIU V0, ZERO, 1
9D0003D8  AF828108   SW V0, -32504(GP)
667:                 				}
668:                 
669:                 			// else display is not complete, so no state change
670:                 			break;
9D000398  0B40011D   J 0x9D000474
9D00039C  00000000   NOP
9D0003DC  0B40011D   J 0x9D000474
9D0003E0  00000000   NOP
9D000464  00000000   NOP
9D000468  0B40011D   J 0x9D000474
9D00046C  00000000   NOP
9D000470  00000000   NOP
671:                 
672:                 	    default:
673:                             RuntimeError(MENU_FSM_ERROR_INVALID_STATE);
9D0003E4  24040033   ADDIU A0, ZERO, 51
9D0003E8  0F40365E   JAL _RuntimeError
9D0003EC  00000000   NOP
674:                             break;
9D0003F0  0B40011D   J 0x9D000474
9D0003F4  00000000   NOP
675:                 
676:                 		}
677:                 
678:                     // *************************************************
679:                     //		    Process the Current or New State
680:                     // *************************************************
681:                     // State handler
682:                     //	called one or more times for a state, depending on state implementation
683:                     //	state transitions do NOT occur here
684:                     //	no fallthrough state transitions - use fFSM_Execute flag to force immediate re-execute for eventless state changes
685:                     //	NOTE: the states transition handler above must make sure that states are not processed multiple times, if doing so is inappropriate
686:                 
687:                 	switch(stMenuState)
9D000474  8F828108   LW V0, -32504(GP)
9D000478  2C430009   SLTIU V1, V0, 9
9D00047C  106002D6   BEQ V1, ZERO, 0x9D000FD8
9D000480  00000000   NOP
9D000484  00021880   SLL V1, V0, 2
9D000488  3C029D00   LUI V0, -25344
9D00048C  244204A0   ADDIU V0, V0, 1184
9D000490  00621021   ADDU V0, V1, V0
9D000494  8C420000   LW V0, 0(V0)
9D000498  00400008   JR V0
9D00049C  00000000   NOP
688:                 		{
689:                 		case ST_MENU_INIT:				// we should NEVER be in this state
690:                             RuntimeError(MENU_FSM_ERROR_INVALID_STATE);
9D0004C4  24040033   ADDIU A0, ZERO, 51
9D0004C8  0F40365E   JAL _RuntimeError
9D0004CC  00000000   NOP
691:                 			break;
9D0004D0  0B4003FA   J 0x9D000FE8
9D0004D4  00000000   NOP
692:                 
693:                 		case ST_MENU_DISPLAY_MENU:
694:                 			switch(bMenuFSMSequenceCtr)
9D0004D8  93828106   LBU V0, -32506(GP)
9D0004DC  24030001   ADDIU V1, ZERO, 1
9D0004E0  1043005E   BEQ V0, V1, 0x9D00065C
9D0004E4  00000000   NOP
9D0004E8  24030002   ADDIU V1, ZERO, 2
9D0004EC  10430068   BEQ V0, V1, 0x9D000690
9D0004F0  00000000   NOP
9D0004F4  14400073   BNE V0, ZERO, 0x9D0006C4
9D0004F8  00000000   NOP
695:                 				{
696:                 				case 0:
697:                 					// substate for first entry into state, setup to start display of the current menu
698:                 					switch(eCurrentMenu)
9D0004FC  8F82810C   LW V0, -32500(GP)
9D000500  2C43000B   SLTIU V1, V0, 11
9D000504  1060004A   BEQ V1, ZERO, 0x9D000630
9D000508  00000000   NOP
9D00050C  00021880   SLL V1, V0, 2
9D000510  3C029D00   LUI V0, -25344
9D000514  24420528   ADDIU V0, V0, 1320
9D000518  00621021   ADDU V0, V1, V0
9D00051C  8C420000   LW V0, 0(V0)
9D000520  00400008   JR V0
9D000524  00000000   NOP
699:                 						{
700:                 						case MAIN_MENU:
701:                 							// initialize pointer to menu text
702:                 							fgpMenuText = pstrMainMenuText;
9D000554  3C02A000   LUI V0, -24576
9D000558  2442068C   ADDIU V0, V0, 1676
9D00055C  AF828140   SW V0, -32448(GP)
703:                 							break;
9D000560  0B400190   J 0x9D000640
9D000564  00000000   NOP
704:                 
705:                 						case STATUS_MENU:
706:                 							// initialize pointer to menu text
707:                 							fgpMenuText = pstrStatusMenuText;
9D000568  3C02A000   LUI V0, -24576
9D00056C  244206B0   ADDIU V0, V0, 1712
9D000570  AF828140   SW V0, -32448(GP)
708:                 							break;
9D000574  0B400190   J 0x9D000640
9D000578  00000000   NOP
709:                 
710:                 						case MOTION_SETTINGS_MENU:
711:                 							// initialize pointer to menu text
712:                 							fgpMenuText = pstrMotionSettingsMenuText;
9D00057C  3C02A000   LUI V0, -24576
9D000580  244206D0   ADDIU V0, V0, 1744
9D000584  AF828140   SW V0, -32448(GP)
713:                 							break;
9D000588  0B400190   J 0x9D000640
9D00058C  00000000   NOP
714:                 
715:                 						case OPEN_LOOP_MOVE_MENU:
716:                 							// initialize pointer to menu text
717:                 							fgpMenuText = pstrOpenLoopMoveMenuText;
9D000590  3C02A000   LUI V0, -24576
9D000594  244206F0   ADDIU V0, V0, 1776
9D000598  AF828140   SW V0, -32448(GP)
718:                 							break;
9D00059C  0B400190   J 0x9D000640
9D0005A0  00000000   NOP
719:                 
720:                 						case CLOSED_LOOP_MOVE_MENU:
721:                 							// initialize pointer to menu text
722:                 							fgpMenuText = pstrClosedLoopMoveMenuText;
9D0005A4  3C02A000   LUI V0, -24576
9D0005A8  2442071C   ADDIU V0, V0, 1820
9D0005AC  AF828140   SW V0, -32448(GP)
723:                 							break;
9D0005B0  0B400190   J 0x9D000640
9D0005B4  00000000   NOP
724:                 
725:                 						case MOVE_SEQUENCE_MENU:
726:                 							// initialize pointer to menu text
727:                 							fgpMenuText = pstrMoveSequenceMenuText;
9D0005B8  3C02A000   LUI V0, -24576
9D0005BC  24420764   ADDIU V0, V0, 1892
9D0005C0  AF828140   SW V0, -32448(GP)
728:                 							break;
9D0005C4  0B400190   J 0x9D000640
9D0005C8  00000000   NOP
729:                 
730:                 						case SYSTEM_PARAMETERS_MENU:
731:                 							// initialize pointer to menu text
732:                 							fgpMenuText = pstrSystemParametersMenuText;
9D0005CC  3C02A000   LUI V0, -24576
9D0005D0  244207AC   ADDIU V0, V0, 1964
9D0005D4  AF828140   SW V0, -32448(GP)
733:                 							break;
9D0005D8  0B400190   J 0x9D000640
9D0005DC  00000000   NOP
734:                 
735:                 						case LOCATION_PARAMETERS_MENU:
736:                 							// initialize pointer to menu text
737:                 							fgpMenuText = pstrUnitLocationParametersMenuText;
9D0005E0  3C02A000   LUI V0, -24576
9D0005E4  244207C8   ADDIU V0, V0, 1992
9D0005E8  AF828140   SW V0, -32448(GP)
738:                 							break;
9D0005EC  0B400190   J 0x9D000640
9D0005F0  00000000   NOP
739:                 
740:                 						case AZIMUTH_PARAMETERS_MENU:
741:                 							// initialize pointer to menu text
742:                 							fgpMenuText = pstrAzimuthParametersMenuText;
9D0005F4  3C02A000   LUI V0, -24576
9D0005F8  244207EC   ADDIU V0, V0, 2028
9D0005FC  AF828140   SW V0, -32448(GP)
743:                 							break;
9D000600  0B400190   J 0x9D000640
9D000604  00000000   NOP
744:                 
745:                 						case ELEVATION_PARAMETERS_MENU:
746:                 							// initialize pointer to menu text
747:                 							fgpMenuText = pstrElevationParametersMenuText;
9D000608  3C02A000   LUI V0, -24576
9D00060C  2442082C   ADDIU V0, V0, 2092
9D000610  AF828140   SW V0, -32448(GP)
748:                 							break;
9D000614  0B400190   J 0x9D000640
9D000618  00000000   NOP
749:                 
750:                 						case READ_INPUTS_MENU:
751:                 							// initialize pointer to menu text
752:                 							fgpMenuText = pstrReadInputsMenuText;
9D00061C  3C02A000   LUI V0, -24576
9D000620  2442086C   ADDIU V0, V0, 2156
9D000624  AF828140   SW V0, -32448(GP)
753:                 							break;
9D000628  0B400190   J 0x9D000640
9D00062C  00000000   NOP
754:                 
755:                 						default:
756:                 							RuntimeError(MENU_FSM_ERROR_INVALID_MENU);
9D000630  24040039   ADDIU A0, ZERO, 57
9D000634  0F40365E   JAL _RuntimeError
9D000638  00000000   NOP
757:                 							break;
9D00063C  00000000   NOP
758:                 						}
759:                 
760:                 					fgwDisplayLineCtr = 0;							// initialize menu line counter
9D000640  A7808110   SH ZERO, -32496(GP)
761:                 					++bMenuFSMSequenceCtr;							// force next substate on next FSM entry
9D000644  93828106   LBU V0, -32506(GP)
9D000648  24420001   ADDIU V0, V0, 1
9D00064C  304200FF   ANDI V0, V0, 255
9D000650  A3828106   SB V0, -32506(GP)
762:                 					break;
9D000654  0B4001B5   J 0x9D0006D4
9D000658  00000000   NOP
763:                 
764:                 				case 1:
765:                 					// substate to display a single line of the menu
766:                 					if (DisplayMenu(UARTid) IS_FALSE)				// returns FALSE if nothing MORE to display
9D00065C  8FC40028   LW A0, 40(S8)
9D000660  0F400401   JAL DisplayMenu
9D000664  00000000   NOP
9D000668  14400003   BNE V0, ZERO, 0x9D000678
9D00066C  00000000   NOP
767:                 						{
768:                 						fSubStateStatus = SUBSTATE_DONE;			// force exit from state; no need for 2nd substate
9D000670  24020001   ADDIU V0, ZERO, 1
9D000674  A3828107   SB V0, -32505(GP)
769:                 						}
770:                 
771:                 					++bMenuFSMSequenceCtr;							// force next substate on next FSM entry
9D000678  93828106   LBU V0, -32506(GP)
9D00067C  24420001   ADDIU V0, V0, 1
9D000680  304200FF   ANDI V0, V0, 255
9D000684  A3828106   SB V0, -32506(GP)
772:                 					break;
9D000688  0B4001B5   J 0x9D0006D4
9D00068C  00000000   NOP
773:                 
774:                 				case 2:
775:                 					// substate to check for menu display (RS-232 transmission) complete
776:                 					if (IsTransmitComplete(UARTid) IS_TRUE)
9D000690  8FC40028   LW A0, 40(S8)
9D000694  0F402390   JAL IsTransmitComplete
9D000698  00000000   NOP
9D00069C  10400007   BEQ V0, ZERO, 0x9D0006BC
9D0006A0  00000000   NOP
777:                 						{
778:                 						++bMenuFSMSequenceCtr;						// force next substate on next FSM entry, actually an invalid state
9D0006A4  93828106   LBU V0, -32506(GP)
9D0006A8  24420001   ADDIU V0, V0, 1
9D0006AC  304200FF   ANDI V0, V0, 255
9D0006B0  A3828106   SB V0, -32506(GP)
779:                 						fSubStateStatus = SUBSTATE_DONE;
9D0006B4  24020001   ADDIU V0, ZERO, 1
9D0006B8  A3828107   SB V0, -32505(GP)
780:                 						}
781:                 					// else stay in this state until display of line is complete
782:                 					break;
9D0006BC  0B4001B5   J 0x9D0006D4
9D0006C0  00000000   NOP
783:                 
784:                 				default:
785:                 					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D0006C4  24040034   ADDIU A0, ZERO, 52
9D0006C8  0F40365E   JAL _RuntimeError
9D0006CC  00000000   NOP
786:                 					break;
9D0006D0  00000000   NOP
787:                 
788:                 				}
789:                 			break;
9D0006D4  0B4003FA   J 0x9D000FE8
9D0006D8  00000000   NOP
790:                 
791:                 		case ST_MENU_WAIT_FOR_KEYSTROKE:
792:                 			switch(bMenuFSMSequenceCtr)
9D0006DC  93828106   LBU V0, -32506(GP)
9D0006E0  10400006   BEQ V0, ZERO, 0x9D0006FC
9D0006E4  00000000   NOP
9D0006E8  24030001   ADDIU V1, ZERO, 1
9D0006EC  10430011   BEQ V0, V1, 0x9D000734
9D0006F0  00000000   NOP
9D0006F4  0B4001E3   J 0x9D00078C
9D0006F8  00000000   NOP
793:                 				{
794:                 				case 0:
795:                 					// start receive process
796:                 					// if there is already a byte available, skip UART_StartReceive() so we do not lose it..
797:                 					if (AnyRxDataAvailable(UARTid) IS_FALSE)
9D0006FC  8FC40028   LW A0, 40(S8)
9D000700  0F402324   JAL AnyRxDataAvailable
9D000704  00000000   NOP
9D000708  14400004   BNE V0, ZERO, 0x9D00071C
9D00070C  00000000   NOP
798:                 						{
799:                 						IGNORE_RETURN_VALUE StartRx(UARTid);
9D000710  8FC40028   LW A0, 40(S8)
9D000714  0F4022F3   JAL StartRx
9D000718  00000000   NOP
800:                 						}
801:                 					++bMenuFSMSequenceCtr;			// force next substate on next FSM entry
9D00071C  93828106   LBU V0, -32506(GP)
9D000720  24420001   ADDIU V0, V0, 1
9D000724  304200FF   ANDI V0, V0, 255
9D000728  A3828106   SB V0, -32506(GP)
802:                 					break;
9D00072C  0B4001E7   J 0x9D00079C
9D000730  00000000   NOP
803:                 
804:                 				case 1:
805:                 					// check for available keystroke
806:                 					if (AnyRxDataAvailable(UARTid) IS_TRUE)
9D000734  8FC40028   LW A0, 40(S8)
9D000738  0F402324   JAL AnyRxDataAvailable
9D00073C  00000000   NOP
9D000740  10400010   BEQ V0, ZERO, 0x9D000784
9D000744  00000000   NOP
807:                 						{
808:                 						pgcInputBuffer[0] = (char)tolower((int)ReadRxdData(UARTid));
9D000748  8FC40028   LW A0, 40(S8)
9D00074C  0F40234D   JAL ReadRxdData
9D000750  00000000   NOP
9D000754  00402021   ADDU A0, V0, ZERO
9D000758  0F403999   JAL tolower
9D00075C  00000000   NOP
9D000760  7C021C20   SEB V1, V0
9D000764  3C02A000   LUI V0, -24576
9D000768  A0430470   SB V1, 1136(V0)
809:                 						++bMenuFSMSequenceCtr;		// force next substate on next FSM entry
9D00076C  93828106   LBU V0, -32506(GP)
9D000770  24420001   ADDIU V0, V0, 1
9D000774  304200FF   ANDI V0, V0, 255
9D000778  A3828106   SB V0, -32506(GP)
810:                 						fSubStateStatus = SUBSTATE_DONE;
9D00077C  24020001   ADDIU V0, ZERO, 1
9D000780  A3828107   SB V0, -32505(GP)
811:                 						}
812:                 					break;
9D000784  0B4001E7   J 0x9D00079C
9D000788  00000000   NOP
813:                 
814:                 				default:
815:                 					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D00078C  24040034   ADDIU A0, ZERO, 52
9D000790  0F40365E   JAL _RuntimeError
9D000794  00000000   NOP
816:                 					break;
9D000798  00000000   NOP
817:                 				}
818:                 			break;
9D00079C  0B4003FA   J 0x9D000FE8
9D0007A0  00000000   NOP
819:                 
820:                 //		case ST_MENU_WAIT_FOR_CR:
821:                 //			break;
822:                 
823:                 		case ST_MENU_PROCESS_COMMAND:
824:                 			switch(eCurrentMenu)
9D0007A4  8F82810C   LW V0, -32500(GP)
9D0007A8  2C43000B   SLTIU V1, V0, 11
9D0007AC  10600071   BEQ V1, ZERO, 0x9D000974
9D0007B0  00000000   NOP
9D0007B4  00021880   SLL V1, V0, 2
9D0007B8  3C029D00   LUI V0, -25344
9D0007BC  244207D0   ADDIU V0, V0, 2000
9D0007C0  00621021   ADDU V0, V1, V0
9D0007C4  8C420000   LW V0, 0(V0)
9D0007C8  00400008   JR V0
9D0007CC  00000000   NOP
825:                 				{
826:                 				case MAIN_MENU:								// always single pass display
827:                 					fSelection = MainMenu(pgcInputBuffer[0]);
9D0007FC  3C02A000   LUI V0, -24576
9D000800  80420470   LB V0, 1136(V0)
9D000804  00402021   ADDU A0, V0, ZERO
9D000808  0F40043E   JAL MainMenu
9D00080C  00000000   NOP
9D000810  AF828040   SW V0, -32704(GP)
828:                 					break;
9D000814  0B400261   J 0x9D000984
9D000818  00000000   NOP
829:                 
830:                 				case STATUS_MENU:							// may be single pass or multiple pass display
831:                 					fSelection = StatusMenu(pgcInputBuffer[0]);
9D00081C  3C02A000   LUI V0, -24576
9D000820  80420470   LB V0, 1136(V0)
9D000824  00402021   ADDU A0, V0, ZERO
9D000828  0F4004C2   JAL StatusMenu
9D00082C  00000000   NOP
9D000830  AF828040   SW V0, -32704(GP)
832:                 					break;
9D000834  0B400261   J 0x9D000984
9D000838  00000000   NOP
833:                 
834:                 				case MOTION_SETTINGS_MENU:					// may be single pass or multiple pass display
835:                 					fSelection = MotionSettingsMenu(UARTid, pgcInputBuffer[0]);
9D00083C  3C02A000   LUI V0, -24576
9D000840  80420470   LB V0, 1136(V0)
9D000844  8FC40028   LW A0, 40(S8)
9D000848  00402821   ADDU A1, V0, ZERO
9D00084C  0F40051B   JAL MotionSettingsMenu
9D000850  00000000   NOP
9D000854  AF828040   SW V0, -32704(GP)
836:                 					break;
9D000858  0B400261   J 0x9D000984
9D00085C  00000000   NOP
837:                 
838:                 				case OPEN_LOOP_MOVE_MENU:								// always single pass display
839:                 					fSelection = OpenLoopMoveMenu(UARTid, pgcInputBuffer[0]);
9D000860  3C02A000   LUI V0, -24576
9D000864  80420470   LB V0, 1136(V0)
9D000868  8FC40028   LW A0, 40(S8)
9D00086C  00402821   ADDU A1, V0, ZERO
9D000870  0F4005A4   JAL OpenLoopMoveMenu
9D000874  00000000   NOP
9D000878  AF828040   SW V0, -32704(GP)
840:                 					break;
9D00087C  0B400261   J 0x9D000984
9D000880  00000000   NOP
841:                 
842:                 				case CLOSED_LOOP_MOVE_MENU:								// always single pass display
843:                 					fSelection = ClosedLoopMoveMenu(UARTid, pgcInputBuffer[0]);
9D000884  3C02A000   LUI V0, -24576
9D000888  80420470   LB V0, 1136(V0)
9D00088C  8FC40028   LW A0, 40(S8)
9D000890  00402821   ADDU A1, V0, ZERO
9D000894  0F4006D2   JAL ClosedLoopMoveMenu
9D000898  00000000   NOP
9D00089C  AF828040   SW V0, -32704(GP)
844:                 					break;
9D0008A0  0B400261   J 0x9D000984
9D0008A4  00000000   NOP
845:                 
846:                 				case MOVE_SEQUENCE_MENU:					// always single pass display
847:                 					fSelection = MoveSequenceMenu(pgcInputBuffer[0]);
9D0008A8  3C02A000   LUI V0, -24576
9D0008AC  80420470   LB V0, 1136(V0)
9D0008B0  00402021   ADDU A0, V0, ZERO
9D0008B4  0F40085A   JAL MoveSequenceMenu
9D0008B8  00000000   NOP
9D0008BC  AF828040   SW V0, -32704(GP)
848:                 					break;
9D0008C0  0B400261   J 0x9D000984
9D0008C4  00000000   NOP
849:                 
850:                 				case SYSTEM_PARAMETERS_MENU:
851:                 					fSelection = SystemParametersMenu(pgcInputBuffer[0]);
9D0008C8  3C02A000   LUI V0, -24576
9D0008CC  80420470   LB V0, 1136(V0)
9D0008D0  00402021   ADDU A0, V0, ZERO
9D0008D4  0F40098D   JAL SystemParametersMenu
9D0008D8  00000000   NOP
9D0008DC  AF828040   SW V0, -32704(GP)
852:                 					break;
9D0008E0  0B400261   J 0x9D000984
9D0008E4  00000000   NOP
853:                 
854:                 				case LOCATION_PARAMETERS_MENU:
855:                 					fSelection = LocationParametersMenu(UARTid, pgcInputBuffer[0]);
9D0008E8  3C02A000   LUI V0, -24576
9D0008EC  80420470   LB V0, 1136(V0)
9D0008F0  8FC40028   LW A0, 40(S8)
9D0008F4  00402821   ADDU A1, V0, ZERO
9D0008F8  0F4009CC   JAL LocationParametersMenu
9D0008FC  00000000   NOP
9D000900  AF828040   SW V0, -32704(GP)
856:                 					break;
9D000904  0B400261   J 0x9D000984
9D000908  00000000   NOP
857:                 
858:                 				case AZIMUTH_PARAMETERS_MENU:
859:                 					fSelection = AzimuthParametersMenu(UARTid, pgcInputBuffer[0]);
9D00090C  3C02A000   LUI V0, -24576
9D000910  80420470   LB V0, 1136(V0)
9D000914  8FC40028   LW A0, 40(S8)
9D000918  00402821   ADDU A1, V0, ZERO
9D00091C  0F400AA0   JAL AzimuthParametersMenu
9D000920  00000000   NOP
9D000924  AF828040   SW V0, -32704(GP)
860:                 					break;
9D000928  0B400261   J 0x9D000984
9D00092C  00000000   NOP
861:                 
862:                 				case ELEVATION_PARAMETERS_MENU:
863:                 					fSelection = ElevationParametersMenu(UARTid, pgcInputBuffer[0]);
9D000930  3C02A000   LUI V0, -24576
9D000934  80420470   LB V0, 1136(V0)
9D000938  8FC40028   LW A0, 40(S8)
9D00093C  00402821   ADDU A1, V0, ZERO
9D000940  0F400ACF   JAL ElevationParametersMenu
9D000944  00000000   NOP
9D000948  AF828040   SW V0, -32704(GP)
864:                 					break;
9D00094C  0B400261   J 0x9D000984
9D000950  00000000   NOP
865:                 
866:                 				case READ_INPUTS_MENU:						// may be single pass or multiple pass display
867:                 					fSelection = ReadInputsMenu(pgcInputBuffer[0]);
9D000954  3C02A000   LUI V0, -24576
9D000958  80420470   LB V0, 1136(V0)
9D00095C  00402021   ADDU A0, V0, ZERO
9D000960  0F400AFE   JAL ReadInputsMenu
9D000964  00000000   NOP
9D000968  AF828040   SW V0, -32704(GP)
868:                 					break;
9D00096C  0B400261   J 0x9D000984
9D000970  00000000   NOP
869:                 
870:                 				default:
871:                 					RuntimeError(MENU_FSM_ERROR_INVALID_MENU);
9D000974  24040039   ADDIU A0, ZERO, 57
9D000978  0F40365E   JAL _RuntimeError
9D00097C  00000000   NOP
872:                 					break;
9D000980  00000000   NOP
873:                 				}
874:                 			break;
9D000984  0B4003FA   J 0x9D000FE8
9D000988  00000000   NOP
875:                 
876:                 		case ST_MENU_WAIT_FOR_PARAMETER_AND_CR:				// ST_MENU_WAIT_FOR_CR:
877:                 			// collecting keystrokes and waiting for CR terminator
878:                 			switch(bMenuFSMSequenceCtr)
9D00098C  93828106   LBU V0, -32506(GP)
9D000990  24030001   ADDIU V1, ZERO, 1
9D000994  10430015   BEQ V0, V1, 0x9D0009EC
9D000998  00000000   NOP
9D00099C  24030002   ADDIU V1, ZERO, 2
9D0009A0  104300AC   BEQ V0, V1, 0x9D000C54
9D0009A4  00000000   NOP
9D0009A8  144000BC   BNE V0, ZERO, 0x9D000C9C
9D0009AC  00000000   NOP
879:                 				{
880:                 				case 0:
881:                 					// start serial receive process
882:                 					// if there is already a byte available, skip StartSerialRx() so we do not lose it..
883:                 					if (AnySerialRxDataAvailable(UARTid) IS_FALSE)
9D0009B0  8FC40028   LW A0, 40(S8)
9D0009B4  0F402324   JAL AnyRxDataAvailable
9D0009B8  00000000   NOP
9D0009BC  14400004   BNE V0, ZERO, 0x9D0009D0
9D0009C0  00000000   NOP
884:                 						{
885:                 						StartSerialRx(UARTid);
9D0009C4  8FC40028   LW A0, 40(S8)
9D0009C8  0F4022F3   JAL StartRx
9D0009CC  00000000   NOP
886:                 						}
887:                 					++bMenuFSMSequenceCtr;						// force next substate on next FSM entry
9D0009D0  93828106   LBU V0, -32506(GP)
9D0009D4  24420001   ADDIU V0, V0, 1
9D0009D8  304200FF   ANDI V0, V0, 255
9D0009DC  A3828106   SB V0, -32506(GP)
888:                 					bInputBufferIndex = 0;						// initialize input buffer index (input may be more than one character)
9D0009E0  A3808124   SB ZERO, -32476(GP)
889:                 					break;
9D0009E4  0B40032B   J 0x9D000CAC
9D0009E8  00000000   NOP
890:                 
891:                 				case 1:
892:                 					// check for available keystroke ==> this is WRONG, does not handle end of buffer correctly!!
893:                 					if ((AnySerialRxDataAvailable(UARTid) IS_TRUE) AND (bInputBufferIndex < INPUT_BUFFER_SIZE))
9D0009EC  8FC40028   LW A0, 40(S8)
9D0009F0  0F402324   JAL AnyRxDataAvailable
9D0009F4  00000000   NOP
9D0009F8  10400094   BEQ V0, ZERO, 0x9D000C4C
9D0009FC  00000000   NOP
9D000A00  93828124   LBU V0, -32476(GP)
9D000A04  2C42000B   SLTIU V0, V0, 11
9D000A08  10400090   BEQ V0, ZERO, 0x9D000C4C
9D000A0C  00000000   NOP
894:                 					{
895:                 						// a keystroke is available. read the keystroke and put it in the buffer
896:                 						pgcInputBuffer[bInputBufferIndex] = (char)ReadSerialRxdData(UARTid);
9D000A10  93828124   LBU V0, -32476(GP)
9D000A14  00408021   ADDU S0, V0, ZERO
9D000A18  8FC40028   LW A0, 40(S8)
9D000A1C  0F40234D   JAL ReadRxdData
9D000A20  00000000   NOP
9D000A24  7C021C20   SEB V1, V0
9D000A28  3C02A000   LUI V0, -24576
9D000A2C  24420470   ADDIU V0, V0, 1136
9D000A30  02021021   ADDU V0, S0, V0
9D000A34  A0430000   SB V1, 0(V0)
897:                 
898:                 						if (isprint(pgcInputBuffer[bInputBufferIndex]) IS_NOT ZERO)
9D000A38  93828124   LBU V0, -32476(GP)
9D000A3C  00401821   ADDU V1, V0, ZERO
9D000A40  3C02A000   LUI V0, -24576
9D000A44  24420470   ADDIU V0, V0, 1136
9D000A48  00621021   ADDU V0, V1, V0
9D000A4C  80420000   LB V0, 0(V0)
9D000A50  24430001   ADDIU V1, V0, 1
9D000A54  3C029D01   LUI V0, -25343
9D000A58  2442DB30   ADDIU V0, V0, -9424
9D000A5C  00621021   ADDU V0, V1, V0
9D000A60  80420000   LB V0, 0(V0)
9D000A64  30420097   ANDI V0, V0, 151
9D000A68  1040000C   BEQ V0, ZERO, 0x9D000A9C
9D000A6C  00000000   NOP
899:                 						{
900:                 							// character is printable, so display it - regardless of whether or not it is valid
901:                 							DisplayCharacter(UARTid, pgcInputBuffer[bInputBufferIndex], NO_WAIT_FOR_DISPLAY);		// echo character; we are assuming this will complete before additional message below
9D000A70  93828124   LBU V0, -32476(GP)
9D000A74  00401821   ADDU V1, V0, ZERO
9D000A78  3C02A000   LUI V0, -24576
9D000A7C  24420470   ADDIU V0, V0, 1136
9D000A80  00621021   ADDU V0, V1, V0
9D000A84  80420000   LB V0, 0(V0)
9D000A88  8FC40028   LW A0, 40(S8)
9D000A8C  00402821   ADDU A1, V0, ZERO
9D000A90  00003021   ADDU A2, ZERO, ZERO
9D000A94  0F402EB2   JAL DisplayCharacter
9D000A98  00000000   NOP
902:                 						}
903:                 
904:                 						// check for end of input
905:                 						if (pgcInputBuffer[bInputBufferIndex] IS ASCII_CR)
9D000A9C  93828124   LBU V0, -32476(GP)
9D000AA0  00401821   ADDU V1, V0, ZERO
9D000AA4  3C02A000   LUI V0, -24576
9D000AA8  24420470   ADDIU V0, V0, 1136
9D000AAC  00621021   ADDU V0, V1, V0
9D000AB0  80430000   LB V1, 0(V0)
9D000AB4  2402000D   ADDIU V0, ZERO, 13
9D000AB8  14620014   BNE V1, V0, 0x9D000B0C
9D000ABC  00000000   NOP
906:                 						{
907:                 							// input is complete
908:                 							pgcInputBuffer[bInputBufferIndex] = SZ_TERM;			// terminate input string
9D000AC0  93828124   LBU V0, -32476(GP)
9D000AC4  00401821   ADDU V1, V0, ZERO
9D000AC8  3C02A000   LUI V0, -24576
9D000ACC  24420470   ADDIU V0, V0, 1136
9D000AD0  00621021   ADDU V0, V1, V0
9D000AD4  A0400000   SB ZERO, 0(V0)
909:                 
910:                 							// check for non-zero length of input string (zero length string is interpreted as... ZERO)
911:                 							if (bInputBufferIndex > 0)
9D000AD8  93828124   LBU V0, -32476(GP)
9D000ADC  10400007   BEQ V0, ZERO, 0x9D000AFC
9D000AE0  00000000   NOP
912:                 							{
913:                 								++bMenuFSMSequenceCtr;								// non-zero length string; force next substate on next FSM entry for processing of parameter
9D000AE4  93828106   LBU V0, -32506(GP)
9D000AE8  24420001   ADDIU V0, V0, 1
9D000AEC  304200FF   ANDI V0, V0, 255
9D000AF0  A3828106   SB V0, -32506(GP)
9D000AF4  0B400313   J 0x9D000C4C
9D000AF8  00000000   NOP
914:                 							}
915:                 							else
916:                 							{
917:                 								fSubStateStatus = SUBSTATE_DONE;					// no input string, so we are done with the ENTIRE state
9D000AFC  24020001   ADDIU V0, ZERO, 1
9D000B00  A3828107   SB V0, -32505(GP)
9D000B04  0B400313   J 0x9D000C4C
9D000B08  00000000   NOP
918:                 							}
919:                 						}
920:                 						// Check keystroke for valid type; numeric data ONLY. Note processing sequence order; CR and ESC are non-numeric, too!
921:                 						else if (pgcInputBuffer[bInputBufferIndex] IS ASCII_ESC)
9D000B0C  93828124   LBU V0, -32476(GP)
9D000B10  00401821   ADDU V1, V0, ZERO
9D000B14  3C02A000   LUI V0, -24576
9D000B18  24420470   ADDIU V0, V0, 1136
9D000B1C  00621021   ADDU V0, V1, V0
9D000B20  80430000   LB V1, 0(V0)
9D000B24  2402001B   ADDIU V0, ZERO, 27
9D000B28  14620005   BNE V1, V0, 0x9D000B40
9D000B2C  00000000   NOP
922:                 						{
923:                 							// abort substate
924:                 							fSubStateStatus = SUBSTATE_DONE;					// we are done with the ENTIRE state
9D000B30  24020001   ADDIU V0, ZERO, 1
9D000B34  A3828107   SB V0, -32505(GP)
925:                 							//++bMenuFSMSequenceCtr;								// force next substate on next FSM entry  <sek> 26 Feb 13
926:                 							break;
9D000B38  0B40032B   J 0x9D000CAC
9D000B3C  00000000   NOP
927:                 						}
928:                 						// Check keystroke for valid type; numeric data ONLY. Note sequence order; CR is non-numeric, too!
929:                 						else  if ((isdigit(pgcInputBuffer[bInputBufferIndex]) IS ZERO) AND (pgcInputBuffer[bInputBufferIndex] IS_NOT ASCII_PERIOD) AND (pgcInputBuffer[bInputBufferIndex] IS_NOT ASCII_MINUS))
9D000B40  93828124   LBU V0, -32476(GP)
9D000B44  00401821   ADDU V1, V0, ZERO
9D000B48  3C02A000   LUI V0, -24576
9D000B4C  24420470   ADDIU V0, V0, 1136
9D000B50  00621021   ADDU V0, V1, V0
9D000B54  80420000   LB V0, 0(V0)
9D000B58  24430001   ADDIU V1, V0, 1
9D000B5C  3C029D01   LUI V0, -25343
9D000B60  2442DB30   ADDIU V0, V0, -9424
9D000B64  00621021   ADDU V0, V1, V0
9D000B68  80420000   LB V0, 0(V0)
9D000B6C  304200FF   ANDI V0, V0, 255
9D000B70  30420004   ANDI V0, V0, 4
9D000B74  1440001D   BNE V0, ZERO, 0x9D000BEC
9D000B78  00000000   NOP
9D000B7C  93828124   LBU V0, -32476(GP)
9D000B80  00401821   ADDU V1, V0, ZERO
9D000B84  3C02A000   LUI V0, -24576
9D000B88  24420470   ADDIU V0, V0, 1136
9D000B8C  00621021   ADDU V0, V1, V0
9D000B90  80430000   LB V1, 0(V0)
9D000B94  2402002E   ADDIU V0, ZERO, 46
9D000B98  10620014   BEQ V1, V0, 0x9D000BEC
9D000B9C  00000000   NOP
9D000BA0  93828124   LBU V0, -32476(GP)
9D000BA4  00401821   ADDU V1, V0, ZERO
9D000BA8  3C02A000   LUI V0, -24576
9D000BAC  24420470   ADDIU V0, V0, 1136
9D000BB0  00621021   ADDU V0, V1, V0
9D000BB4  80430000   LB V1, 0(V0)
9D000BB8  2402002D   ADDIU V0, ZERO, 45
9D000BBC  1062000B   BEQ V1, V0, 0x9D000BEC
9D000BC0  00000000   NOP
930:                 						{
931:                 							// abort substate; only used when entry is invalid
932:                 							// note that this results in TWO writes within a single pass through the FSM (??), which may not work correctly...
933:                 							DisplayMessage(UARTid, "\t\x01B[31m Not a valid entry\x01B[30m", NO_WAIT_FOR_DISPLAY);	// start display (serial output) of line
9D000BC4  8FC40028   LW A0, 40(S8)
9D000BC8  3C029D00   LUI V0, -25344
9D000BCC  24455D10   ADDIU A1, V0, 23824
9D000BD0  00003021   ADDU A2, ZERO, ZERO
9D000BD4  0F402E88   JAL DisplayMessage
9D000BD8  00000000   NOP
934:                 
935:                 							fSubStateStatus = SUBSTATE_DONE;					// we are done with the state
9D000BDC  24020001   ADDIU V0, ZERO, 1
9D000BE0  A3828107   SB V0, -32505(GP)
936:                 							break;
9D000BE4  0B40032B   J 0x9D000CAC
9D000BE8  00000000   NOP
937:                 						}
938:                 						// check for buffer overrun
939:                 						else if (bInputBufferIndex IS INPUT_STR_SIZE)
9D000BEC  93838124   LBU V1, -32476(GP)
9D000BF0  2402000A   ADDIU V0, ZERO, 10
9D000BF4  14620011   BNE V1, V0, 0x9D000C3C
9D000BF8  00000000   NOP
940:                 						{
941:                 							// input buffer is full
942:                 							++bInputBufferIndex;								// bump index to point at terminator
9D000BFC  93828124   LBU V0, -32476(GP)
9D000C00  24420001   ADDIU V0, V0, 1
9D000C04  304200FF   ANDI V0, V0, 255
9D000C08  A3828124   SB V0, -32476(GP)
943:                 
944:                 							pgcInputBuffer[bInputBufferIndex] = SZ_TERM;		// terminate input string
9D000C0C  93828124   LBU V0, -32476(GP)
9D000C10  00401821   ADDU V1, V0, ZERO
9D000C14  3C02A000   LUI V0, -24576
9D000C18  24420470   ADDIU V0, V0, 1136
9D000C1C  00621021   ADDU V0, V1, V0
9D000C20  A0400000   SB ZERO, 0(V0)
945:                 
946:                 							++bMenuFSMSequenceCtr;								// force next substate on next FSM entry for processing of parameter
9D000C24  93828106   LBU V0, -32506(GP)
9D000C28  24420001   ADDIU V0, V0, 1
9D000C2C  304200FF   ANDI V0, V0, 255
9D000C30  A3828106   SB V0, -32506(GP)
9D000C34  0B400313   J 0x9D000C4C
9D000C38  00000000   NOP
947:                 						}
948:                 						else
949:                 						{
950:                 							// accept character and stay in state and substate
951:                 							++bInputBufferIndex;								// bump index
9D000C3C  93828124   LBU V0, -32476(GP)
9D000C40  24420001   ADDIU V0, V0, 1
9D000C44  304200FF   ANDI V0, V0, 255
9D000C48  A3828124   SB V0, -32476(GP)
952:                 						}
953:                 
954:                 						// we may want to add another substate here, to wait for any pending display to complete
955:                 					}
956:                 					// else stay in state and substate to collect more keystrokes
957:                 					break;
9D000C4C  0B40032B   J 0x9D000CAC
9D000C50  00000000   NOP
958:                 
959:                 				case 2:
960:                 					// update parameter
961:                 					bValueValid = UpdateParameter(eParameter);				// update selected parameter based on contents of pgcInputBuffer[]
9D000C54  8F828120   LW V0, -32480(GP)
9D000C58  00402021   ADDU A0, V0, ZERO
9D000C5C  0F4013CC   JAL UpdateParameter
9D000C60  00000000   NOP
9D000C64  AFC20010   SW V0, 16(S8)
962:                 					if (bValueValid IS FALSE)
9D000C68  8FC20010   LW V0, 16(S8)
9D000C6C  14400007   BNE V0, ZERO, 0x9D000C8C
9D000C70  00000000   NOP
963:                 					{
964:                 						DisplayMessage(UARTid, "\t\x01B[31m Not a valid value\x01B[30m", NO_WAIT_FOR_DISPLAY);		// start display (serial output) of line
9D000C74  8FC40028   LW A0, 40(S8)
9D000C78  3C029D00   LUI V0, -25344
9D000C7C  24455D30   ADDIU A1, V0, 23856
9D000C80  00003021   ADDU A2, ZERO, ZERO
9D000C84  0F402E88   JAL DisplayMessage
9D000C88  00000000   NOP
965:                 					}
966:                 
967:                 					fSubStateStatus = SUBSTATE_DONE;			// we are done with the state
9D000C8C  24020001   ADDIU V0, ZERO, 1
9D000C90  A3828107   SB V0, -32505(GP)
968:                 					break;
9D000C94  0B40032B   J 0x9D000CAC
9D000C98  00000000   NOP
969:                 
970:                 				default:
971:                 					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000C9C  24040034   ADDIU A0, ZERO, 52
9D000CA0  0F40365E   JAL _RuntimeError
9D000CA4  00000000   NOP
972:                 					break;
9D000CA8  00000000   NOP
973:                 				}
974:                 
975:                 			break;
9D000CAC  0B4003FA   J 0x9D000FE8
9D000CB0  00000000   NOP
976:                 
977:                 		case ST_MENU_DISPLAY_STREAMING_DATA:
978:                 			switch(bMenuFSMSequenceCtr)
9D000CB4  93828106   LBU V0, -32506(GP)
9D000CB8  10400006   BEQ V0, ZERO, 0x9D000CD4
9D000CBC  00000000   NOP
9D000CC0  24030001   ADDIU V1, ZERO, 1
9D000CC4  10430010   BEQ V0, V1, 0x9D000D08
9D000CC8  00000000   NOP
9D000CCC  0B40034F   J 0x9D000D3C
9D000CD0  00000000   NOP
979:                 				{
980:                 				case 0:
981:                 					// first entry into state, so start display result
982:                 					++bMenuFSMSequenceCtr;					// force next substate on next FSM entry
9D000CD4  93828106   LBU V0, -32506(GP)
9D000CD8  24420001   ADDIU V0, V0, 1
9D000CDC  304200FF   ANDI V0, V0, 255
9D000CE0  A3828106   SB V0, -32506(GP)
983:                 					if (DisplayStatus(UARTid) IS_FALSE)		// returns FALSE if nothing to display
9D000CE4  8FC40028   LW A0, 40(S8)
9D000CE8  0F4010A9   JAL DisplayStatus
9D000CEC  00000000   NOP
9D000CF0  14400003   BNE V0, ZERO, 0x9D000D00
9D000CF4  00000000   NOP
984:                 						{
985:                 						fSubStateStatus = SUBSTATE_DONE;	// force exit from state; no need for 2nd substate
9D000CF8  24020001   ADDIU V0, ZERO, 1
9D000CFC  A3828107   SB V0, -32505(GP)
986:                 						}
987:                 					break;
9D000D00  0B400353   J 0x9D000D4C
9D000D04  00000000   NOP
988:                 
989:                 				case 1:
990:                 					// all subsequent entries into the state
991:                 					// check for status display (RS-232 transmission) complete
992:                 					if (IsTransmitComplete(UARTid) IS_TRUE)
9D000D08  8FC40028   LW A0, 40(S8)
9D000D0C  0F402390   JAL IsTransmitComplete
9D000D10  00000000   NOP
9D000D14  10400007   BEQ V0, ZERO, 0x9D000D34
9D000D18  00000000   NOP
993:                 						{
994:                 						++bMenuFSMSequenceCtr;					// force next substate on next FSM entry
9D000D1C  93828106   LBU V0, -32506(GP)
9D000D20  24420001   ADDIU V0, V0, 1
9D000D24  304200FF   ANDI V0, V0, 255
9D000D28  A3828106   SB V0, -32506(GP)
995:                 						fSubStateStatus = SUBSTATE_DONE;
9D000D2C  24020001   ADDIU V0, ZERO, 1
9D000D30  A3828107   SB V0, -32505(GP)
996:                 						}
997:                 					break;
9D000D34  0B400353   J 0x9D000D4C
9D000D38  00000000   NOP
998:                 
999:                 				default:
1000:                					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000D3C  24040034   ADDIU A0, ZERO, 52
9D000D40  0F40365E   JAL _RuntimeError
9D000D44  00000000   NOP
1001:                					break;
9D000D48  00000000   NOP
1002:                				}
1003:                			break;
9D000D4C  0B4003FA   J 0x9D000FE8
9D000D50  00000000   NOP
1004:                
1005:                
1006:                		case ST_MENU_CHECK_FOR_TERMINATING_KEYSTROKE:
1007:                			switch(bMenuFSMSequenceCtr)
9D000D54  93828106   LBU V0, -32506(GP)
9D000D58  10400006   BEQ V0, ZERO, 0x9D000D74
9D000D5C  00000000   NOP
9D000D60  24030001   ADDIU V1, ZERO, 1
9D000D64  10430011   BEQ V0, V1, 0x9D000DAC
9D000D68  00000000   NOP
9D000D6C  0B400389   J 0x9D000E24
9D000D70  00000000   NOP
1008:                				{
1009:                				case 0:
1010:                					// start receive process
1011:                					// if there is already a byte available, skip UART_StartReceive() so we do not lose it..
1012:                					if (AnyRxDataAvailable(UARTid) IS_FALSE)
9D000D74  8FC40028   LW A0, 40(S8)
9D000D78  0F402324   JAL AnyRxDataAvailable
9D000D7C  00000000   NOP
9D000D80  14400004   BNE V0, ZERO, 0x9D000D94
9D000D84  00000000   NOP
1013:                						{
1014:                						IGNORE_RETURN_VALUE StartRx(UARTid);
9D000D88  8FC40028   LW A0, 40(S8)
9D000D8C  0F4022F3   JAL StartRx
9D000D90  00000000   NOP
1015:                						}
1016:                					++bMenuFSMSequenceCtr;						// force next substate on next FSM entry
9D000D94  93828106   LBU V0, -32506(GP)
9D000D98  24420001   ADDIU V0, V0, 1
9D000D9C  304200FF   ANDI V0, V0, 255
9D000DA0  A3828106   SB V0, -32506(GP)
1017:                					break;
9D000DA4  0B40038D   J 0x9D000E34
9D000DA8  00000000   NOP
1018:                
1019:                				case 1:
1020:                					// check for available keystroke
1021:                					if (AnyRxDataAvailable(UARTid) IS_TRUE)
9D000DAC  8FC40028   LW A0, 40(S8)
9D000DB0  0F402324   JAL AnyRxDataAvailable
9D000DB4  00000000   NOP
9D000DB8  10400011   BEQ V0, ZERO, 0x9D000E00
9D000DBC  00000000   NOP
1022:                						{
1023:                						// a keystroke is available 
1024:                						pgcInputBuffer[0] = (char)ReadRxdData(UARTid);
9D000DC0  8FC40028   LW A0, 40(S8)
9D000DC4  0F40234D   JAL ReadRxdData
9D000DC8  00000000   NOP
9D000DCC  7C021C20   SEB V1, V0
9D000DD0  3C02A000   LUI V0, -24576
9D000DD4  A0430470   SB V1, 1136(V0)
1025:                						fSelection = MENU_SELECTED;
9D000DD8  24020001   ADDIU V0, ZERO, 1
9D000DDC  AF828040   SW V0, -32704(GP)
1026:                
1027:                						// if we are displaying the Runtime Error status, a keystroke stops the display, and clears the buffer
1028:                						if (eCurrentStatus IS RUNTIME_ERROR_STATUS)
9D000DE0  8F838118   LW V1, -32488(GP)
9D000DE4  24020003   ADDIU V0, ZERO, 3
9D000DE8  14620006   BNE V1, V0, 0x9D000E04
9D000DEC  00000000   NOP
1029:                							{
1030:                							ResetRuntimeError();				// reset the buffer pointer; has the effect of clearing the Runtime Error buffer
9D000DF0  0F403680   JAL ResetRuntimeError
9D000DF4  00000000   NOP
9D000DF8  0B400381   J 0x9D000E04
9D000DFC  00000000   NOP
1031:                							}
1032:                						}
1033:                					else
1034:                						{
1035:                						fSelection = NOTHING_SELECTED;			// no selection made
9D000E00  AF808040   SW ZERO, -32704(GP)
1036:                						}
1037:                
1038:                					++bMenuFSMSequenceCtr;						// force next (invalid) substate on next FSM entry
9D000E04  93828106   LBU V0, -32506(GP)
9D000E08  24420001   ADDIU V0, V0, 1
9D000E0C  304200FF   ANDI V0, V0, 255
9D000E10  A3828106   SB V0, -32506(GP)
1039:                					fSubStateStatus = SUBSTATE_DONE;			// keystroke or not, we are done with the state
9D000E14  24020001   ADDIU V0, ZERO, 1
9D000E18  A3828107   SB V0, -32505(GP)
1040:                					break;
9D000E1C  0B40038D   J 0x9D000E34
9D000E20  00000000   NOP
1041:                
1042:                				default:
1043:                					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000E24  24040034   ADDIU A0, ZERO, 52
9D000E28  0F40365E   JAL _RuntimeError
9D000E2C  00000000   NOP
1044:                					break;
9D000E30  00000000   NOP
1045:                				}
1046:                			break;
9D000E34  0B4003FA   J 0x9D000FE8
9D000E38  00000000   NOP
1047:                
1048:                		case ST_MENU_DISPLAY_REALTIME_DATA:
1049:                			switch(bMenuFSMSequenceCtr)
9D000E3C  93828106   LBU V0, -32506(GP)
9D000E40  10400006   BEQ V0, ZERO, 0x9D000E5C
9D000E44  00000000   NOP
9D000E48  24030001   ADDIU V1, ZERO, 1
9D000E4C  10430015   BEQ V0, V1, 0x9D000EA4
9D000E50  00000000   NOP
9D000E54  0B4003C4   J 0x9D000F10
9D000E58  00000000   NOP
1050:                				{
1051:                				case 0:
1052:                					// enable realtime serial data display
1053:                					bRealTimeDisplay = TRUE;
9D000E5C  24020001   ADDIU V0, ZERO, 1
9D000E60  AF82806C   SW V0, -32660(GP)
1054:                					eSerialOutputMode = SER_MODE_REALTIME;
9D000E64  24020002   ADDIU V0, ZERO, 2
9D000E68  AF828070   SW V0, -32656(GP)
1055:                
1056:                					// start serial receive process
1057:                					// if there is already a byte available, skip StartSerialRx() so we do not lose it..
1058:                					if (AnySerialRxDataAvailable(UARTid) IS_FALSE)
9D000E6C  8FC40028   LW A0, 40(S8)
9D000E70  0F402324   JAL AnyRxDataAvailable
9D000E74  00000000   NOP
9D000E78  14400004   BNE V0, ZERO, 0x9D000E8C
9D000E7C  00000000   NOP
1059:                						{
1060:                						StartSerialRx(UARTid);
9D000E80  8FC40028   LW A0, 40(S8)
9D000E84  0F4022F3   JAL StartRx
9D000E88  00000000   NOP
1061:                						}
1062:                					++bMenuFSMSequenceCtr;						// force next substate on next FSM entry
9D000E8C  93828106   LBU V0, -32506(GP)
9D000E90  24420001   ADDIU V0, V0, 1
9D000E94  304200FF   ANDI V0, V0, 255
9D000E98  A3828106   SB V0, -32506(GP)
1063:                					break;
9D000E9C  0B4003C8   J 0x9D000F20
9D000EA0  00000000   NOP
1064:                
1065:                				case 1:
1066:                					// check for available keystroke
1067:                					if (AnySerialRxDataAvailable(UARTid) IS_TRUE)
9D000EA4  8FC40028   LW A0, 40(S8)
9D000EA8  0F402324   JAL AnyRxDataAvailable
9D000EAC  00000000   NOP
9D000EB0  10400014   BEQ V0, ZERO, 0x9D000F04
9D000EB4  00000000   NOP
1068:                						{
1069:                						// a keystroke is available
1070:                						pgcInputBuffer[0] = (char)ReadSerialRxdData(UARTid);
9D000EB8  8FC40028   LW A0, 40(S8)
9D000EBC  0F40234D   JAL ReadRxdData
9D000EC0  00000000   NOP
9D000EC4  7C021C20   SEB V1, V0
9D000EC8  3C02A000   LUI V0, -24576
9D000ECC  A0430470   SB V1, 1136(V0)
1071:                						fSelection = MENU_SELECTED;
9D000ED0  24020001   ADDIU V0, ZERO, 1
9D000ED4  AF828040   SW V0, -32704(GP)
1072:                
1073:                						// any keystroke ends the Realtime Data streaming and returns to the menu
1074:                						// disable realtime serial data display
1075:                						bRealTimeDisplay = FALSE;
9D000ED8  AF80806C   SW ZERO, -32660(GP)
1076:                						eSerialOutputMode = SER_MODE_MENU;
9D000EDC  24020001   ADDIU V0, ZERO, 1
9D000EE0  AF828070   SW V0, -32656(GP)
1077:                
1078:                						// we may want to add another substate here, to wait for any pending display to complete
1079:                
1080:                						++bMenuFSMSequenceCtr;						// force next (invalid) substate on next FSM entry
9D000EE4  93828106   LBU V0, -32506(GP)
9D000EE8  24420001   ADDIU V0, V0, 1
9D000EEC  304200FF   ANDI V0, V0, 255
9D000EF0  A3828106   SB V0, -32506(GP)
1081:                						fSubStateStatus = SUBSTATE_DONE;			// keystroke or not, we are done with the state
9D000EF4  24020001   ADDIU V0, ZERO, 1
9D000EF8  A3828107   SB V0, -32505(GP)
9D000EFC  0B4003C2   J 0x9D000F08
9D000F00  00000000   NOP
1082:                						}
1083:                					else
1084:                						{
1085:                						fSelection = NOTHING_SELECTED;			// no selection made
9D000F04  AF808040   SW ZERO, -32704(GP)
1086:                
1087:                						// stay in state and substate
1088:                						}
1089:                					break;
9D000F08  0B4003C8   J 0x9D000F20
9D000F0C  00000000   NOP
1090:                
1091:                				default:
1092:                					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000F10  24040034   ADDIU A0, ZERO, 52
9D000F14  0F40365E   JAL _RuntimeError
9D000F18  00000000   NOP
1093:                					break;
9D000F1C  00000000   NOP
1094:                				}
1095:                
1096:                			break;
9D000F20  0B4003FA   J 0x9D000FE8
9D000F24  00000000   NOP
1097:                
1098:                
1099:                		case ST_MENU_DISPLAY_RESULT:
1100:                			switch(bMenuFSMSequenceCtr)
9D000F28  93828106   LBU V0, -32506(GP)
9D000F2C  10400006   BEQ V0, ZERO, 0x9D000F48
9D000F30  00000000   NOP
9D000F34  24030001   ADDIU V1, ZERO, 1
9D000F38  10430018   BEQ V0, V1, 0x9D000F9C
9D000F3C  00000000   NOP
9D000F40  0B4003F0   J 0x9D000FC0
9D000F44  00000000   NOP
1101:                				{
1102:                				case 0:
1103:                					// first entry into state (or re-entry for a new line), so start display result
1104:                					if (eResultLine IS RESULT_SINGLE_LINE)			// just one line to display
9D000F48  8F828048   LW V0, -32696(GP)
9D000F4C  14400006   BNE V0, ZERO, 0x9D000F68
9D000F50  00000000   NOP
1105:                						{
1106:                						DisplayStr(UARTid);								// single line is already setup for display
9D000F54  8FC40028   LW A0, 40(S8)
9D000F58  0F402E32   JAL DisplayStr
9D000F5C  00000000   NOP
9D000F60  0B4003E1   J 0x9D000F84
9D000F64  00000000   NOP
1107:                						}
1108:                					// must be line 1 of 1 to n lines..
1109:                					else if (DisplayResult(UARTid) IS_FALSE)				// returns FALSE if nothing MORE to display
9D000F68  8FC40028   LW A0, 40(S8)
9D000F6C  0F400B6B   JAL DisplayResult
9D000F70  00000000   NOP
9D000F74  14400003   BNE V0, ZERO, 0x9D000F84
9D000F78  00000000   NOP
1110:                						{
1111:                						fSubStateStatus = SUBSTATE_DONE;			// force exit from state; no need for 2nd substate
9D000F7C  24020001   ADDIU V0, ZERO, 1
9D000F80  A3828107   SB V0, -32505(GP)
1112:                						}
1113:                
1114:                					++bMenuFSMSequenceCtr;							// force next substate on next FSM entry
9D000F84  93828106   LBU V0, -32506(GP)
9D000F88  24420001   ADDIU V0, V0, 1
9D000F8C  304200FF   ANDI V0, V0, 255
9D000F90  A3828106   SB V0, -32506(GP)
1115:                					break;
9D000F94  0B4003F4   J 0x9D000FD0
9D000F98  00000000   NOP
1116:                
1117:                				case 1:
1118:                					// subsequent entry into the state
1119:                					// check for result display (RS-232 transmission) complete
1120:                					if (IsTransmitComplete(UARTid) IS_TRUE)
9D000F9C  8FC40028   LW A0, 40(S8)
9D000FA0  0F402390   JAL IsTransmitComplete
9D000FA4  00000000   NOP
9D000FA8  10400003   BEQ V0, ZERO, 0x9D000FB8
9D000FAC  00000000   NOP
1121:                						{
1122:                						//if (eResultLine IS RESULT_SINGLE_LINE)			// just one line to display
1123:                						//	{
1124:                							fSubStateStatus = SUBSTATE_DONE;			// force exit from state
9D000FB0  24020001   ADDIU V0, ZERO, 1
9D000FB4  A3828107   SB V0, -32505(GP)
1125:                						//	}
1126:                
1127:                						//bMenuFSMSequenceCtr = 0;						// return to previous substate on next FSM entry
1128:                						//++fgwDisplayLineCtr;							// bump to next display line
1129:                						}
1130:                					break;
9D000FB8  0B4003F4   J 0x9D000FD0
9D000FBC  00000000   NOP
1131:                
1132:                				default:
1133:                					RuntimeError(MENU_FSM_ERROR_INVALID_SUBSTATE);
9D000FC0  24040034   ADDIU A0, ZERO, 52
9D000FC4  0F40365E   JAL _RuntimeError
9D000FC8  00000000   NOP
1134:                					break;
9D000FCC  00000000   NOP
1135:                
1136:                				}
1137:                			break;
9D000FD0  0B4003FA   J 0x9D000FE8
9D000FD4  00000000   NOP
1138:                
1139:                	    default:
1140:                            RuntimeError(MENU_FSM_ERROR_INVALID_STATE);
9D000FD8  24040033   ADDIU A0, ZERO, 51
9D000FDC  0F40365E   JAL _RuntimeError
9D000FE0  00000000   NOP
1141:                            break;
9D000FE4  00000000   NOP
1142:                		}
1143:                
1144:                	// Note that we do not check for unprocessed events here.. because the FSM is not setup to handle externally generated events.
1145:                
1146:                }
9D000FE8  03C0E821   ADDU SP, S8, ZERO
9D000FEC  8FBF0024   LW RA, 36(SP)
9D000FF0  8FBE0020   LW S8, 32(SP)
9D000FF4  8FB0001C   LW S0, 28(SP)
9D000FF8  27BD0028   ADDIU SP, SP, 40
9D000FFC  03E00008   JR RA
9D001000  00000000   NOP
1147:                
1148:                
1149:                //*****************************************************************************
1150:                //							D i s p l a y M e n u ( ) 
1151:                //*****************************************************************************
1152:                
1153:                // Display of multi-line Menu Text
1154:                // Displays just ONE line per pass through the function, so multiple passes are required.
1155:                
1156:                // returns	TRUE is a line was displayed
1157:                //			FALSE if the fgwDisplayLineCtr value goes beyond the last line
1158:                BOOL DisplayMenu(UART_MODULE UARTid)
1159:                {
9D001004  27BDFFE0   ADDIU SP, SP, -32
9D001008  AFBF001C   SW RA, 28(SP)
9D00100C  AFBE0018   SW S8, 24(SP)
9D001010  03A0F021   ADDU S8, SP, ZERO
9D001014  AFC40020   SW A0, 32(S8)
1160:                
1161:                	BOOL bRetVal = TRUE;
9D001018  24020001   ADDIU V0, ZERO, 1
9D00101C  AFC20010   SW V0, 16(S8)
1162:                
1163:                	ClearDisplayStr();
9D001020  0F402DB6   JAL ClearDisplayStr
9D001024  00000000   NOP
1164:                
1165:                	// check for done with menu text
1166:                	if (strlen(fgpMenuText[fgwDisplayLineCtr]) IS (size_t)0)
9D001028  8F838140   LW V1, -32448(GP)
9D00102C  97828110   LHU V0, -32496(GP)
9D001030  00021080   SLL V0, V0, 2
9D001034  00621021   ADDU V0, V1, V0
9D001038  8C420000   LW V0, 0(V0)
9D00103C  80420000   LB V0, 0(V0)
9D001040  14400006   BNE V0, ZERO, 0x9D00105C
9D001044  00000000   NOP
1167:                		{
1168:                		// this is actually an error condition...
1169:                		eMenuLine = MENU_LAST_LINE;						// this is (effectively) the last line to display
9D001048  24020002   ADDIU V0, ZERO, 2
9D00104C  AF828044   SW V0, -32700(GP)
1170:                		return (FALSE);									// nothing to display
9D001050  00001021   ADDU V0, ZERO, ZERO
9D001054  0B400438   J 0x9D0010E0
9D001058  00000000   NOP
1171:                		}
1172:                
1173:                	// add a line of menu to display
1174:                	AddDisplayStr(fgpMenuText[fgwDisplayLineCtr]);
9D00105C  8F838140   LW V1, -32448(GP)
9D001060  97828110   LHU V0, -32496(GP)
9D001064  00021080   SLL V0, V0, 2
9D001068  00621021   ADDU V0, V1, V0
9D00106C  8C420000   LW V0, 0(V0)
9D001070  00402021   ADDU A0, V0, ZERO
9D001074  0F402DC0   JAL AddDisplayStr
9D001078  00000000   NOP
1175:                
1176:                	// bump pointer to menu text to next line
1177:                	fgwDisplayLineCtr++;
9D00107C  97828110   LHU V0, -32496(GP)
9D001080  24420001   ADDIU V0, V0, 1
9D001084  3042FFFF   ANDI V0, V0, -1
9D001088  A7828110   SH V0, -32496(GP)
1178:                
1179:                	// check for done with menu text
1180:                	if (strlen(fgpMenuText[fgwDisplayLineCtr]) IS (size_t)0)
9D00108C  8F838140   LW V1, -32448(GP)
9D001090  97828110   LHU V0, -32496(GP)
9D001094  00021080   SLL V0, V0, 2
9D001098  00621021   ADDU V0, V1, V0
9D00109C  8C420000   LW V0, 0(V0)
9D0010A0  80420000   LB V0, 0(V0)
9D0010A4  14400006   BNE V0, ZERO, 0x9D0010C0
9D0010A8  00000000   NOP
1181:                		{
1182:                		eMenuLine = MENU_LAST_LINE;						// this is (effectively) the last line to display
9D0010AC  24020002   ADDIU V0, ZERO, 2
9D0010B0  AF828044   SW V0, -32700(GP)
1183:                		bRetVal = FALSE;								// nothing to display
9D0010B4  AFC00010   SW ZERO, 16(S8)
9D0010B8  0B400432   J 0x9D0010C8
9D0010BC  00000000   NOP
1184:                		}
1185:                	else
1186:                		{
1187:                		eMenuLine = MENU_LINE;							// at least one more line to display
9D0010C0  24020001   ADDIU V0, ZERO, 1
9D0010C4  AF828044   SW V0, -32700(GP)
1188:                		}
1189:                
1190:                
1191:                	AddDisplayNewLine();								// add line terminator
9D0010C8  0F402E24   JAL AddDisplayNewLine
9D0010CC  00000000   NOP
1192:                
1193:                	DisplayStr(UARTid);									// start display (serial output) of line
9D0010D0  8FC40020   LW A0, 32(S8)
9D0010D4  0F402E32   JAL DisplayStr
9D0010D8  00000000   NOP
1194:                
1195:                	return bRetVal;										// TRUE if more data to display, FALSE if last line
9D0010DC  8FC20010   LW V0, 16(S8)
1196:                }
9D0010E0  03C0E821   ADDU SP, S8, ZERO
9D0010E4  8FBF001C   LW RA, 28(SP)
9D0010E8  8FBE0018   LW S8, 24(SP)
9D0010EC  27BD0020   ADDIU SP, SP, 32
9D0010F0  03E00008   JR RA
9D0010F4  00000000   NOP
1197:                
1198:                
1199:                
1200:                //*****************************************************************************
1201:                //								M a i n M e n u ( ) 
1202:                //*****************************************************************************
1203:                
1204:                int MainMenu(char cKeystroke)
1205:                {
9D0010F8  27BDFFE8   ADDIU SP, SP, -24
9D0010FC  AFBF0014   SW RA, 20(SP)
9D001100  AFBE0010   SW S8, 16(SP)
9D001104  03A0F021   ADDU S8, SP, ZERO
9D001108  00801021   ADDU V0, A0, ZERO
9D00110C  A3C20018   SB V0, 24(S8)
1206:                
1207:                	switch(cKeystroke)
9D001110  83C20018   LB V0, 24(S8)
9D001114  2442FFCF   ADDIU V0, V0, -49
9D001118  2C430048   SLTIU V1, V0, 72
9D00111C  1060006F   BEQ V1, ZERO, 0x9D0012DC
9D001120  00000000   NOP
9D001124  00021880   SLL V1, V0, 2
9D001128  3C029D00   LUI V0, -25344
9D00112C  24421140   ADDIU V0, V0, 4416
9D001130  00621021   ADDU V0, V1, V0
9D001134  8C420000   LW V0, 0(V0)
9D001138  00400008   JR V0
9D00113C  00000000   NOP
1208:                	{
1209:                		case '1':				// Status Menu
1210:                			eCurrentMenu = STATUS_MENU;
9D001260  24020001   ADDIU V0, ZERO, 1
9D001264  AF82810C   SW V0, -32500(GP)
1211:                			break;
9D001268  0B4004BB   J 0x9D0012EC
9D00126C  00000000   NOP
1212:                
1213:                		case '2':				// Motor Settings
1214:                			eCurrentMenu = MOTION_SETTINGS_MENU;
9D001270  24020002   ADDIU V0, ZERO, 2
9D001274  AF82810C   SW V0, -32500(GP)
1215:                			break;
9D001278  0B4004BB   J 0x9D0012EC
9D00127C  00000000   NOP
1216:                
1217:                		case '3':				// Movement
1218:                			eCurrentMenu = OPEN_LOOP_MOVE_MENU;
9D001280  24020003   ADDIU V0, ZERO, 3
9D001284  AF82810C   SW V0, -32500(GP)
1219:                			break;
9D001288  0B4004BB   J 0x9D0012EC
9D00128C  00000000   NOP
1220:                
1221:                		case '4':				// Movement
1222:                			eCurrentMenu = CLOSED_LOOP_MOVE_MENU;
9D001290  24020004   ADDIU V0, ZERO, 4
9D001294  AF82810C   SW V0, -32500(GP)
1223:                			break;
9D001298  0B4004BB   J 0x9D0012EC
9D00129C  00000000   NOP
1224:                
1225:                		case '5':				// Movement
1226:                			eCurrentMenu = MOVE_SEQUENCE_MENU;
9D0012A0  24020005   ADDIU V0, ZERO, 5
9D0012A4  AF82810C   SW V0, -32500(GP)
1227:                			break;
9D0012A8  0B4004BB   J 0x9D0012EC
9D0012AC  00000000   NOP
1228:                
1229:                		case '6':				// Movement
1230:                			eCurrentMenu = SYSTEM_PARAMETERS_MENU;
9D0012B0  24020006   ADDIU V0, ZERO, 6
9D0012B4  AF82810C   SW V0, -32500(GP)
1231:                			break;
9D0012B8  0B4004BB   J 0x9D0012EC
9D0012BC  00000000   NOP
1232:                
1233:                		case '7':				// Read Inputs
1234:                			eCurrentMenu = READ_INPUTS_MENU;
9D0012C0  2402000A   ADDIU V0, ZERO, 10
9D0012C4  AF82810C   SW V0, -32500(GP)
1235:                			break;
9D0012C8  0B4004BB   J 0x9D0012EC
9D0012CC  00000000   NOP
1236:                
1237:                		#ifdef NOTDEF
1238:                			case '5':				// Restart system
1239:                				pgbTerminate = TRUE;	// set flag to restart
1240:                				break;
1241:                		#endif
1242:                
1243:                		case 'x':				// Redisplay Main Menu
1244:                			eCurrentMenu = MAIN_MENU;
9D0012D0  AF80810C   SW ZERO, -32500(GP)
1245:                			break;
9D0012D4  0B4004BB   J 0x9D0012EC
9D0012D8  00000000   NOP
1246:                
1247:                		default:
1248:                            RuntimeError(MENU_FSM_ERROR_INVALID_STATE);
9D0012DC  24040033   ADDIU A0, ZERO, 51
9D0012E0  0F40365E   JAL _RuntimeError
9D0012E4  00000000   NOP
1249:                			// redisplay current menu
1250:                			break;
9D0012E8  00000000   NOP
1251:                	}
1252:                
1253:                	return MENU_SELECTED;
9D0012EC  24020001   ADDIU V0, ZERO, 1
1254:                	
1255:                }
9D0012F0  03C0E821   ADDU SP, S8, ZERO
9D0012F4  8FBF0014   LW RA, 20(SP)
9D0012F8  8FBE0010   LW S8, 16(SP)
9D0012FC  27BD0018   ADDIU SP, SP, 24
9D001300  03E00008   JR RA
9D001304  00000000   NOP
1256:                
1257:                //*****************************************************************************
1258:                //								S t a t u s M e n u ( ) 
1259:                //*****************************************************************************
1260:                
1261:                int StatusMenu(char cKeystroke)
1262:                {
9D001308  27BDFFE0   ADDIU SP, SP, -32
9D00130C  AFBF001C   SW RA, 28(SP)
9D001310  AFBE0018   SW S8, 24(SP)
9D001314  03A0F021   ADDU S8, SP, ZERO
9D001318  00801021   ADDU V0, A0, ZERO
9D00131C  A3C20020   SB V0, 32(S8)
1263:                
1264:                	int nRetVal = COMMAND_SELECTED;
9D001320  24020002   ADDIU V0, ZERO, 2
9D001324  AFC20010   SW V0, 16(S8)
1265:                
1266:                	ClearDisplayStr();
9D001328  0F402DB6   JAL ClearDisplayStr
9D00132C  00000000   NOP
1267:                	AddDisplayNewLine();
9D001330  0F402E24   JAL AddDisplayNewLine
9D001334  00000000   NOP
1268:                
1269:                	switch(cKeystroke)
9D001338  83C20020   LB V0, 32(S8)
9D00133C  24030033   ADDIU V1, ZERO, 51
9D001340  10430024   BEQ V0, V1, 0x9D0013D4
9D001344  00000000   NOP
9D001348  28430034   SLTI V1, V0, 52
9D00134C  10600009   BEQ V1, ZERO, 0x9D001374
9D001350  00000000   NOP
9D001354  24030031   ADDIU V1, ZERO, 49
9D001358  10430011   BEQ V0, V1, 0x9D0013A0
9D00135C  00000000   NOP
9D001360  24030032   ADDIU V1, ZERO, 50
9D001364  10430016   BEQ V0, V1, 0x9D0013C0
9D001368  00000000   NOP
9D00136C  0B40050D   J 0x9D001434
9D001370  00000000   NOP
9D001374  24030035   ADDIU V1, ZERO, 53
9D001378  10430022   BEQ V0, V1, 0x9D001404
9D00137C  00000000   NOP
9D001380  28430035   SLTI V1, V0, 53
9D001384  14600019   BNE V1, ZERO, 0x9D0013EC
9D001388  00000000   NOP
9D00138C  24030078   ADDIU V1, ZERO, 120
9D001390  10430023   BEQ V0, V1, 0x9D001420
9D001394  00000000   NOP
9D001398  0B40050D   J 0x9D001434
9D00139C  00000000   NOP
1270:                	{
1271:                		case '1':				// last movement
1272:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D0013A0  24020001   ADDIU V0, ZERO, 1
9D0013A4  AF828048   SW V0, -32696(GP)
1273:                			eResultType = RESULT_STATUS_LAST_MOVEMENT;
9D0013A8  24020001   ADDIU V0, ZERO, 1
9D0013AC  AF828114   SW V0, -32492(GP)
1274:                			nRetVal = COMMAND_SELECTED;
9D0013B0  24020002   ADDIU V0, ZERO, 2
9D0013B4  AFC20010   SW V0, 16(S8)
1275:                			break;
9D0013B8  0B400514   J 0x9D001450
9D0013BC  00000000   NOP
1276:                
1277:                		case '2':				// stream FSM States
1278:                			eCurrentStatus = FSM_STATUS;
9D0013C0  AF808118   SW ZERO, -32488(GP)
1279:                			nRetVal = DATA_STREAM_SELECTED;
9D0013C4  24020004   ADDIU V0, ZERO, 4
9D0013C8  AFC20010   SW V0, 16(S8)
1280:                			break;
9D0013CC  0B400514   J 0x9D001450
9D0013D0  00000000   NOP
1281:                
1282:                		case '3':				// stream motor status data
1283:                			eCurrentStatus = MOTOR_STATUS;
9D0013D4  24020001   ADDIU V0, ZERO, 1
9D0013D8  AF828118   SW V0, -32488(GP)
1284:                			nRetVal = DATA_STREAM_SELECTED;
9D0013DC  24020004   ADDIU V0, ZERO, 4
9D0013E0  AFC20010   SW V0, 16(S8)
1285:                			break;
9D0013E4  0B400514   J 0x9D001450
9D0013E8  00000000   NOP
1286:                
1287:                		case '4':				// stream input switch status data
1288:                			eCurrentStatus = INPUT_SWITCH_STATUS;
9D0013EC  24020002   ADDIU V0, ZERO, 2
9D0013F0  AF828118   SW V0, -32488(GP)
1289:                			nRetVal = DATA_STREAM_SELECTED;
9D0013F4  24020004   ADDIU V0, ZERO, 4
9D0013F8  AFC20010   SW V0, 16(S8)
1290:                			break;
9D0013FC  0B400514   J 0x9D001450
9D001400  00000000   NOP
1291:                
1292:                		case '5':				// stream runtime error data
1293:                			eCurrentStatus = RUNTIME_ERROR_STATUS;
9D001404  24020003   ADDIU V0, ZERO, 3
9D001408  AF828118   SW V0, -32488(GP)
1294:                			gwErrorDisplayIndex = 0;				// reset error display index
9D00140C  A7808104   SH ZERO, -32508(GP)
1295:                			nRetVal = DATA_STREAM_SELECTED;
9D001410  24020004   ADDIU V0, ZERO, 4
9D001414  AFC20010   SW V0, 16(S8)
1296:                			break;
9D001418  0B400514   J 0x9D001450
9D00141C  00000000   NOP
1297:                
1298:                		case 'x':				// Redisplay Main Menu
1299:                			eCurrentMenu = MAIN_MENU;
9D001420  AF80810C   SW ZERO, -32500(GP)
1300:                			nRetVal = MENU_SELECTED;
9D001424  24020001   ADDIU V0, ZERO, 1
9D001428  AFC20010   SW V0, 16(S8)
1301:                			break;
9D00142C  0B400514   J 0x9D001450
9D001430  00000000   NOP
1302:                
1303:                		default:
1304:                			AddDisplayStrAndNewLine("???");
9D001434  3C029D00   LUI V0, -25344
9D001438  24445D50   ADDIU A0, V0, 23888
9D00143C  0F402DDD   JAL AddDisplayStrAndNewLine
9D001440  00000000   NOP
1305:                			nRetVal = MENU_SELECTED;
9D001444  24020001   ADDIU V0, ZERO, 1
9D001448  AFC20010   SW V0, 16(S8)
1306:                			break;
9D00144C  00000000   NOP
1307:                	}
1308:                
1309:                	return nRetVal;
9D001450  8FC20010   LW V0, 16(S8)
1310:                }
9D001454  03C0E821   ADDU SP, S8, ZERO
9D001458  8FBF001C   LW RA, 28(SP)
9D00145C  8FBE0018   LW S8, 24(SP)
9D001460  27BD0020   ADDIU SP, SP, 32
9D001464  03E00008   JR RA
9D001468  00000000   NOP
1311:                
1312:                //*****************************************************************************
1313:                //						M o t o r S e t t i n g s M e n u ( ) 
1314:                //*****************************************************************************
1315:                
1316:                int MotionSettingsMenu(UART_MODULE UARTid, char cKeystroke)
1317:                {
9D00146C  27BDFF90   ADDIU SP, SP, -112
9D001470  AFBF006C   SW RA, 108(SP)
9D001474  AFBE0068   SW S8, 104(SP)
9D001478  03A0F021   ADDU S8, SP, ZERO
9D00147C  AFC40070   SW A0, 112(S8)
9D001480  00A01021   ADDU V0, A1, ZERO
9D001484  A3C20074   SB V0, 116(S8)
1318:                
1319:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1320:                	int nRetVal = COMMAND_SELECTED;
9D001488  24020002   ADDIU V0, ZERO, 2
9D00148C  AFC20010   SW V0, 16(S8)
1321:                
1322:                	ClearDisplayStr();
9D001490  0F402DB6   JAL ClearDisplayStr
9D001494  00000000   NOP
1323:                	AddDisplayNewLine();
9D001498  0F402E24   JAL AddDisplayNewLine
9D00149C  00000000   NOP
1324:                
1325:                	switch(cKeystroke)
9D0014A0  83C20074   LB V0, 116(S8)
9D0014A4  24030033   ADDIU V1, ZERO, 51
9D0014A8  10430023   BEQ V0, V1, 0x9D001538
9D0014AC  00000000   NOP
9D0014B0  28430034   SLTI V1, V0, 52
9D0014B4  10600009   BEQ V1, ZERO, 0x9D0014DC
9D0014B8  00000000   NOP
9D0014BC  24030031   ADDIU V1, ZERO, 49
9D0014C0  10430011   BEQ V0, V1, 0x9D001508
9D0014C4  00000000   NOP
9D0014C8  24030032   ADDIU V1, ZERO, 50
9D0014CC  10430014   BEQ V0, V1, 0x9D001520
9D0014D0  00000000   NOP
9D0014D4  0B400596   J 0x9D001658
9D0014D8  00000000   NOP
9D0014DC  24030035   ADDIU V1, ZERO, 53
9D0014E0  1043003A   BEQ V0, V1, 0x9D0015CC
9D0014E4  00000000   NOP
9D0014E8  28430035   SLTI V1, V0, 53
9D0014EC  14600018   BNE V1, ZERO, 0x9D001550
9D0014F0  00000000   NOP
9D0014F4  24030078   ADDIU V1, ZERO, 120
9D0014F8  10430052   BEQ V0, V1, 0x9D001644
9D0014FC  00000000   NOP
9D001500  0B400596   J 0x9D001658
9D001504  00000000   NOP
1326:                		{
1327:                		case '1':
1328:                			// multi-line output display
1329:                			eResultType = RESULT_READ_REGISTERS_MTN_SENSOR_SETTINGS;
9D001508  24020002   ADDIU V0, ZERO, 2
9D00150C  AF828114   SW V0, -32492(GP)
1330:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D001510  24020001   ADDIU V0, ZERO, 1
9D001514  AF828048   SW V0, -32696(GP)
1331:                			break;
9D001518  0B40059D   J 0x9D001674
9D00151C  00000000   NOP
1332:                
1333:                		case '2':
1334:                			// multi-line output display
1335:                			eResultType = RESULT_READ_REGISTERS_PWM_SETTINGS;
9D001520  24020003   ADDIU V0, ZERO, 3
9D001524  AF828114   SW V0, -32492(GP)
1336:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D001528  24020001   ADDIU V0, ZERO, 1
9D00152C  AF828048   SW V0, -32696(GP)
1337:                			break;
9D001530  0B40059D   J 0x9D001674
9D001534  00000000   NOP
1338:                
1339:                		case '3':				// PWM widths
1340:                			// multi-line output display
1341:                			eResultType = RESULT_MOTOR_PWM_WIDTHS;
9D001538  24020004   ADDIU V0, ZERO, 4
9D00153C  AF828114   SW V0, -32492(GP)
1342:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D001540  24020001   ADDIU V0, ZERO, 1
9D001544  AF828048   SW V0, -32696(GP)
1343:                			break;
9D001548  0B40059D   J 0x9D001674
9D00154C  00000000   NOP
1344:                
1345:                		case '4':
1346:                			AddDisplayStr("Elevation Duty Cycle: ");
9D001550  3C029D00   LUI V0, -25344
9D001554  24445D54   ADDIU A0, V0, 23892
9D001558  0F402DC0   JAL AddDisplayStr
9D00155C  00000000   NOP
1347:                			WORDtoASCIIstr(pgwPWMDutyCycle[MOTOR_ELEVATION], WORD_WIDTH, szfnDisplayStr);
9D001560  3C02A000   LUI V0, -24576
9D001564  24420268   ADDIU V0, V0, 616
9D001568  94420002   LHU V0, 2(V0)
9D00156C  00401821   ADDU V1, V0, ZERO
9D001570  27C20014   ADDIU V0, S8, 20
9D001574  00602021   ADDU A0, V1, ZERO
9D001578  24050005   ADDIU A1, ZERO, 5
9D00157C  00403021   ADDU A2, V0, ZERO
9D001580  0F402C67   JAL WORDtoASCIIstr
9D001584  00000000   NOP
1348:                			AddDisplayStr(szfnDisplayStr);
9D001588  27C20014   ADDIU V0, S8, 20
9D00158C  00402021   ADDU A0, V0, ZERO
9D001590  0F402DC0   JAL AddDisplayStr
9D001594  00000000   NOP
1349:                			AddDisplayStr("  _");
9D001598  3C029D00   LUI V0, -25344
9D00159C  24445D6C   ADDIU A0, V0, 23916
9D0015A0  0F402DC0   JAL AddDisplayStr
9D0015A4  00000000   NOP
1350:                			DisplayStr(UARTid);							// start display (serial output) of line
9D0015A8  8FC40070   LW A0, 112(S8)
9D0015AC  0F402E32   JAL DisplayStr
9D0015B0  00000000   NOP
1351:                			nRetVal = PARAMETER_SELECTED;
9D0015B4  24020003   ADDIU V0, ZERO, 3
9D0015B8  AFC20010   SW V0, 16(S8)
1352:                			eParameter = PARAMETER_ELEVATION_DUTY_CYCLE;
9D0015BC  24020007   ADDIU V0, ZERO, 7
9D0015C0  AF828120   SW V0, -32480(GP)
1353:                			break;
9D0015C4  0B40059D   J 0x9D001674
9D0015C8  00000000   NOP
1354:                
1355:                		case '5':
1356:                			AddDisplayStr("Azimuth Duty Cycle: ");
9D0015CC  3C029D00   LUI V0, -25344
9D0015D0  24445D70   ADDIU A0, V0, 23920
9D0015D4  0F402DC0   JAL AddDisplayStr
9D0015D8  00000000   NOP
1357:                			WORDtoASCIIstr(pgwPWMDutyCycle[MOTOR_AZIMUTH], WORD_WIDTH, szfnDisplayStr);
9D0015DC  3C02A000   LUI V0, -24576
9D0015E0  94420268   LHU V0, 616(V0)
9D0015E4  00401821   ADDU V1, V0, ZERO
9D0015E8  27C20014   ADDIU V0, S8, 20
9D0015EC  00602021   ADDU A0, V1, ZERO
9D0015F0  24050005   ADDIU A1, ZERO, 5
9D0015F4  00403021   ADDU A2, V0, ZERO
9D0015F8  0F402C67   JAL WORDtoASCIIstr
9D0015FC  00000000   NOP
1358:                			AddDisplayStr(szfnDisplayStr);
9D001600  27C20014   ADDIU V0, S8, 20
9D001604  00402021   ADDU A0, V0, ZERO
9D001608  0F402DC0   JAL AddDisplayStr
9D00160C  00000000   NOP
1359:                			AddDisplayStr("  _");
9D001610  3C029D00   LUI V0, -25344
9D001614  24445D6C   ADDIU A0, V0, 23916
9D001618  0F402DC0   JAL AddDisplayStr
9D00161C  00000000   NOP
1360:                			DisplayStr(UARTid);							// start display (serial output) of line
9D001620  8FC40070   LW A0, 112(S8)
9D001624  0F402E32   JAL DisplayStr
9D001628  00000000   NOP
1361:                			nRetVal = PARAMETER_SELECTED;
9D00162C  24020003   ADDIU V0, ZERO, 3
9D001630  AFC20010   SW V0, 16(S8)
1362:                			eParameter = PARAMETER_AZIMUTH_DUTY_CYCLE;
9D001634  24020008   ADDIU V0, ZERO, 8
9D001638  AF828120   SW V0, -32480(GP)
1363:                			break;
9D00163C  0B40059D   J 0x9D001674
9D001640  00000000   NOP
1364:                
1365:                		case 'x':				// Redisplay Main Menu
1366:                			eCurrentMenu = MAIN_MENU;
9D001644  AF80810C   SW ZERO, -32500(GP)
1367:                			nRetVal = MENU_SELECTED;
9D001648  24020001   ADDIU V0, ZERO, 1
9D00164C  AFC20010   SW V0, 16(S8)
1368:                			break;
9D001650  0B40059D   J 0x9D001674
9D001654  00000000   NOP
1369:                
1370:                		default:
1371:                			AddDisplayStrAndNewLine("???");
9D001658  3C029D00   LUI V0, -25344
9D00165C  24445D50   ADDIU A0, V0, 23888
9D001660  0F402DDD   JAL AddDisplayStrAndNewLine
9D001664  00000000   NOP
1372:                			nRetVal = MENU_SELECTED;
9D001668  24020001   ADDIU V0, ZERO, 1
9D00166C  AFC20010   SW V0, 16(S8)
1373:                			break;
9D001670  00000000   NOP
1374:                		}
1375:                
1376:                	return nRetVal;
9D001674  8FC20010   LW V0, 16(S8)
1377:                }
9D001678  03C0E821   ADDU SP, S8, ZERO
9D00167C  8FBF006C   LW RA, 108(SP)
9D001680  8FBE0068   LW S8, 104(SP)
9D001684  27BD0070   ADDIU SP, SP, 112
9D001688  03E00008   JR RA
9D00168C  00000000   NOP
1378:                
1379:                
1380:                //*****************************************************************************
1381:                //					O p e n L o o p M o v e M e n u ( )
1382:                //*****************************************************************************
1383:                
1384:                
1385:                int OpenLoopMoveMenu(UART_MODULE UARTid, char cKeystroke)
1386:                {
9D001690  27BDFF90   ADDIU SP, SP, -112
9D001694  AFBF006C   SW RA, 108(SP)
9D001698  AFBE0068   SW S8, 104(SP)
9D00169C  03A0F021   ADDU S8, SP, ZERO
9D0016A0  AFC40070   SW A0, 112(S8)
9D0016A4  00A01021   ADDU V0, A1, ZERO
9D0016A8  A3C20074   SB V0, 116(S8)
1387:                
1388:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1389:                
1390:                	int nRetVal = COMMAND_SELECTED;
9D0016AC  24020002   ADDIU V0, ZERO, 2
9D0016B0  AFC20010   SW V0, 16(S8)
1391:                
1392:                	// clear the screen
1393:                	ClearDisplayStr();
9D0016B4  0F402DB6   JAL ClearDisplayStr
9D0016B8  00000000   NOP
1394:                	AddDisplayNewLine();
9D0016BC  0F402E24   JAL AddDisplayNewLine
9D0016C0  00000000   NOP
1395:                
1396:                	switch(cKeystroke)
9D0016C4  83C20074   LB V0, 116(S8)
9D0016C8  2442FFCF   ADDIU V0, V0, -49
9D0016CC  2C430048   SLTIU V1, V0, 72
9D0016D0  1060010E   BEQ V1, ZERO, 0x9D001B0C
9D0016D4  00000000   NOP
9D0016D8  00021880   SLL V1, V0, 2
9D0016DC  3C029D00   LUI V0, -25344
9D0016E0  244216F4   ADDIU V0, V0, 5876
9D0016E4  00621021   ADDU V0, V1, V0
9D0016E8  8C420000   LW V0, 0(V0)
9D0016EC  00400008   JR V0
9D0016F0  00000000   NOP
1397:                		{
1398:                		// each of these cases simply sets a menu event flag for the requested move
1399:                		// the event flags are subsequently processed by the User FSM
1400:                		case '1':				// set move distace
1401:                			AddDisplayStr("Elevation Duty Cycle: ");
9D001814  3C029D00   LUI V0, -25344
9D001818  24445D54   ADDIU A0, V0, 23892
9D00181C  0F402DC0   JAL AddDisplayStr
9D001820  00000000   NOP
1402:                			WORDtoASCIIstr(pgwPWMDutyCycle[MOTOR_ELEVATION], WORD_WIDTH, szfnDisplayStr);
9D001824  3C02A000   LUI V0, -24576
9D001828  24420268   ADDIU V0, V0, 616
9D00182C  94420002   LHU V0, 2(V0)
9D001830  00401821   ADDU V1, V0, ZERO
9D001834  27C20014   ADDIU V0, S8, 20
9D001838  00602021   ADDU A0, V1, ZERO
9D00183C  24050005   ADDIU A1, ZERO, 5
9D001840  00403021   ADDU A2, V0, ZERO
9D001844  0F402C67   JAL WORDtoASCIIstr
9D001848  00000000   NOP
1403:                			AddDisplayStr(szfnDisplayStr);
9D00184C  27C20014   ADDIU V0, S8, 20
9D001850  00402021   ADDU A0, V0, ZERO
9D001854  0F402DC0   JAL AddDisplayStr
9D001858  00000000   NOP
1404:                			AddDisplayStr("  _");
9D00185C  3C029D00   LUI V0, -25344
9D001860  24445D6C   ADDIU A0, V0, 23916
9D001864  0F402DC0   JAL AddDisplayStr
9D001868  00000000   NOP
1405:                			DisplayStr(UARTid);							// start display (serial output) of line
9D00186C  8FC40070   LW A0, 112(S8)
9D001870  0F402E32   JAL DisplayStr
9D001874  00000000   NOP
1406:                			nRetVal = PARAMETER_SELECTED;
9D001878  24020003   ADDIU V0, ZERO, 3
9D00187C  AFC20010   SW V0, 16(S8)
1407:                			eParameter = PARAMETER_ELEVATION_DUTY_CYCLE;
9D001880  24020007   ADDIU V0, ZERO, 7
9D001884  AF828120   SW V0, -32480(GP)
1408:                			break;
9D001888  0B4006CA   J 0x9D001B28
9D00188C  00000000   NOP
1409:                
1410:                		case '2':				// run up
1411:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001890  0F4034F7   JAL SetCommandStarted
9D001894  00000000   NOP
1412:                			BITSET(efCommandEvents, EF_CMD_RUN_UP);
9D001898  978280E0   LHU V0, -32544(GP)
9D00189C  34420200   ORI V0, V0, 512
9D0018A0  3042FFFF   ANDI V0, V0, -1
9D0018A4  A78280E0   SH V0, -32544(GP)
1413:                			AddDisplayStrAndNewLine("Run up (fwd)");
9D0018A8  3C029D00   LUI V0, -25344
9D0018AC  24445D88   ADDIU A0, V0, 23944
9D0018B0  0F402DDD   JAL AddDisplayStrAndNewLine
9D0018B4  00000000   NOP
1414:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_STOPPED);	// must stop before changing directions
9D0018B8  24040001   ADDIU A0, ZERO, 1
9D0018BC  00002821   ADDU A1, ZERO, ZERO
9D0018C0  0F402581   JAL PWM_SetConfig
9D0018C4  00000000   NOP
1415:                			// ==>> need a delay here
1416:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_FORWARD);
9D0018C8  24040001   ADDIU A0, ZERO, 1
9D0018CC  24050001   ADDIU A1, ZERO, 1
9D0018D0  0F402581   JAL PWM_SetConfig
9D0018D4  00000000   NOP
1417:                			PWM_SetDutyCycle(MOTOR_ELEVATION, PWM_DUTY_CYCLE_MIN);
9D0018D8  24040001   ADDIU A0, ZERO, 1
9D0018DC  24050014   ADDIU A1, ZERO, 20
9D0018E0  0F402671   JAL PWM_SetDutyCycle
9D0018E4  00000000   NOP
1418:                			break;
9D0018E8  0B4006CA   J 0x9D001B28
9D0018EC  00000000   NOP
1419:                
1420:                		case '3':				// run down
1421:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D0018F0  0F4034F7   JAL SetCommandStarted
9D0018F4  00000000   NOP
1422:                			BITSET(efCommandEvents, EF_CMD_RUN_DOWN);
9D0018F8  978280E0   LHU V0, -32544(GP)
9D0018FC  34420400   ORI V0, V0, 1024
9D001900  3042FFFF   ANDI V0, V0, -1
9D001904  A78280E0   SH V0, -32544(GP)
1423:                			AddDisplayStrAndNewLine("Run down (rev)");
9D001908  3C029D00   LUI V0, -25344
9D00190C  24445D98   ADDIU A0, V0, 23960
9D001910  0F402DDD   JAL AddDisplayStrAndNewLine
9D001914  00000000   NOP
1424:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_STOPPED);	// must stop before changing directions
9D001918  24040001   ADDIU A0, ZERO, 1
9D00191C  00002821   ADDU A1, ZERO, ZERO
9D001920  0F402581   JAL PWM_SetConfig
9D001924  00000000   NOP
1425:                			// ==>> need a delay here
1426:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_REVERSE);
9D001928  24040001   ADDIU A0, ZERO, 1
9D00192C  2405FFFF   ADDIU A1, ZERO, -1
9D001930  0F402581   JAL PWM_SetConfig
9D001934  00000000   NOP
1427:                			PWM_SetDutyCycle(MOTOR_ELEVATION, PWM_DUTY_CYCLE_MIN);
9D001938  24040001   ADDIU A0, ZERO, 1
9D00193C  24050014   ADDIU A1, ZERO, 20
9D001940  0F402671   JAL PWM_SetDutyCycle
9D001944  00000000   NOP
1428:                			break;
9D001948  0B4006CA   J 0x9D001B28
9D00194C  00000000   NOP
1429:                
1430:                		case '4':
1431:                			AddDisplayStr("Azimuth Duty Cycle: ");
9D001950  3C029D00   LUI V0, -25344
9D001954  24445D70   ADDIU A0, V0, 23920
9D001958  0F402DC0   JAL AddDisplayStr
9D00195C  00000000   NOP
1432:                			WORDtoASCIIstr(pgwPWMDutyCycle[MOTOR_AZIMUTH], WORD_WIDTH, szfnDisplayStr);
9D001960  3C02A000   LUI V0, -24576
9D001964  94420268   LHU V0, 616(V0)
9D001968  00401821   ADDU V1, V0, ZERO
9D00196C  27C20014   ADDIU V0, S8, 20
9D001970  00602021   ADDU A0, V1, ZERO
9D001974  24050005   ADDIU A1, ZERO, 5
9D001978  00403021   ADDU A2, V0, ZERO
9D00197C  0F402C67   JAL WORDtoASCIIstr
9D001980  00000000   NOP
1433:                			AddDisplayStr(szfnDisplayStr);
9D001984  27C20014   ADDIU V0, S8, 20
9D001988  00402021   ADDU A0, V0, ZERO
9D00198C  0F402DC0   JAL AddDisplayStr
9D001990  00000000   NOP
1434:                			AddDisplayStr("  _");
9D001994  3C029D00   LUI V0, -25344
9D001998  24445D6C   ADDIU A0, V0, 23916
9D00199C  0F402DC0   JAL AddDisplayStr
9D0019A0  00000000   NOP
1435:                			DisplayStr(UARTid);							// start display (serial output) of line
9D0019A4  8FC40070   LW A0, 112(S8)
9D0019A8  0F402E32   JAL DisplayStr
9D0019AC  00000000   NOP
1436:                			nRetVal = PARAMETER_SELECTED;
9D0019B0  24020003   ADDIU V0, ZERO, 3
9D0019B4  AFC20010   SW V0, 16(S8)
1437:                			eParameter = PARAMETER_AZIMUTH_DUTY_CYCLE;
9D0019B8  24020008   ADDIU V0, ZERO, 8
9D0019BC  AF828120   SW V0, -32480(GP)
1438:                			break;
9D0019C0  0B4006CA   J 0x9D001B28
9D0019C4  00000000   NOP
1439:                
1440:                		case '5':
1441:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D0019C8  0F4034F7   JAL SetCommandStarted
9D0019CC  00000000   NOP
1442:                			BITSET(efCommandEvents, EF_CMD_RUN_RIGHT);
9D0019D0  978280E0   LHU V0, -32544(GP)
9D0019D4  34420800   ORI V0, V0, 2048
9D0019D8  3042FFFF   ANDI V0, V0, -1
9D0019DC  A78280E0   SH V0, -32544(GP)
1443:                			AddDisplayStrAndNewLine("Run right (fwd)");
9D0019E0  3C029D00   LUI V0, -25344
9D0019E4  24445DA8   ADDIU A0, V0, 23976
9D0019E8  0F402DDD   JAL AddDisplayStrAndNewLine
9D0019EC  00000000   NOP
1444:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_STOPPED);	// must stop before changing directions
9D0019F0  00002021   ADDU A0, ZERO, ZERO
9D0019F4  00002821   ADDU A1, ZERO, ZERO
9D0019F8  0F402581   JAL PWM_SetConfig
9D0019FC  00000000   NOP
1445:                			// ==>> need a delay here
1446:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_FORWARD);
9D001A00  00002021   ADDU A0, ZERO, ZERO
9D001A04  24050001   ADDIU A1, ZERO, 1
9D001A08  0F402581   JAL PWM_SetConfig
9D001A0C  00000000   NOP
1447:                			PWM_SetDutyCycle(MOTOR_AZIMUTH, PWM_DUTY_CYCLE_MIN);
9D001A10  00002021   ADDU A0, ZERO, ZERO
9D001A14  24050014   ADDIU A1, ZERO, 20
9D001A18  0F402671   JAL PWM_SetDutyCycle
9D001A1C  00000000   NOP
1448:                			break;
9D001A20  0B4006CA   J 0x9D001B28
9D001A24  00000000   NOP
1449:                
1450:                		case '6':
1451:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001A28  0F4034F7   JAL SetCommandStarted
9D001A2C  00000000   NOP
1452:                			BITSET(efCommandEvents, EF_CMD_RUN_LEFT);
9D001A30  978280E0   LHU V0, -32544(GP)
9D001A34  34421000   ORI V0, V0, 4096
9D001A38  3042FFFF   ANDI V0, V0, -1
9D001A3C  A78280E0   SH V0, -32544(GP)
1453:                			AddDisplayStrAndNewLine("Run left (rev)");
9D001A40  3C029D00   LUI V0, -25344
9D001A44  24445DB8   ADDIU A0, V0, 23992
9D001A48  0F402DDD   JAL AddDisplayStrAndNewLine
9D001A4C  00000000   NOP
1454:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_STOPPED);	// must stop before changing directions
9D001A50  00002021   ADDU A0, ZERO, ZERO
9D001A54  00002821   ADDU A1, ZERO, ZERO
9D001A58  0F402581   JAL PWM_SetConfig
9D001A5C  00000000   NOP
1455:                			// ==>> need a delay here
1456:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_REVERSE);
9D001A60  00002021   ADDU A0, ZERO, ZERO
9D001A64  2405FFFF   ADDIU A1, ZERO, -1
9D001A68  0F402581   JAL PWM_SetConfig
9D001A6C  00000000   NOP
1457:                			PWM_SetDutyCycle(MOTOR_AZIMUTH, PWM_DUTY_CYCLE_MIN);
9D001A70  00002021   ADDU A0, ZERO, ZERO
9D001A74  24050014   ADDIU A1, ZERO, 20
9D001A78  0F402671   JAL PWM_SetDutyCycle
9D001A7C  00000000   NOP
1458:                			break;
9D001A80  0B4006CA   J 0x9D001B28
9D001A84  00000000   NOP
1459:                
1460:                		case 's':				// ALL STOP
1461:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001A88  0F4034F7   JAL SetCommandStarted
9D001A8C  00000000   NOP
1462:                			BITSET(efCommandEvents, EF_CMD_STOP);
9D001A90  978280E0   LHU V0, -32544(GP)
9D001A94  A78280E0   SH V0, -32544(GP)
1463:                			AddDisplayStrAndNewLine("All Stop!");
9D001A98  3C029D00   LUI V0, -25344
9D001A9C  24445DC8   ADDIU A0, V0, 24008
9D001AA0  0F402DDD   JAL AddDisplayStrAndNewLine
9D001AA4  00000000   NOP
1464:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_STOPPED);	// stop both axis
9D001AA8  24040001   ADDIU A0, ZERO, 1
9D001AAC  00002821   ADDU A1, ZERO, ZERO
9D001AB0  0F402581   JAL PWM_SetConfig
9D001AB4  00000000   NOP
1465:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_STANDBY);	// disables Motion Sensor interrupts
9D001AB8  24040001   ADDIU A0, ZERO, 1
9D001ABC  24050003   ADDIU A1, ZERO, 3
9D001AC0  0F402581   JAL PWM_SetConfig
9D001AC4  00000000   NOP
1466:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_STOPPED);
9D001AC8  00002021   ADDU A0, ZERO, ZERO
9D001ACC  00002821   ADDU A1, ZERO, ZERO
9D001AD0  0F402581   JAL PWM_SetConfig
9D001AD4  00000000   NOP
1467:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_STANDBY);	// disables Motion Sensor interrupts
9D001AD8  00002021   ADDU A0, ZERO, ZERO
9D001ADC  24050003   ADDIU A1, ZERO, 3
9D001AE0  0F402581   JAL PWM_SetConfig
9D001AE4  00000000   NOP
1468:                			break;
9D001AE8  0B4006CA   J 0x9D001B28
9D001AEC  00000000   NOP
1469:                
1470:                		case 'r':				// reset
1471:                			Reset();													// processor reset
9D001AF0  0F403508   JAL Reset
9D001AF4  00000000   NOP
1472:                			//lint -fallthrough  no need for a break here, we are doing a hard reset
1473:                
1474:                		case 'x':				// Redisplay Main Menu
1475:                			eCurrentMenu = MAIN_MENU;
9D001AF8  AF80810C   SW ZERO, -32500(GP)
1476:                			nRetVal = MENU_SELECTED;
9D001AFC  24020001   ADDIU V0, ZERO, 1
9D001B00  AFC20010   SW V0, 16(S8)
1477:                			break;
9D001B04  0B4006CA   J 0x9D001B28
9D001B08  00000000   NOP
1478:                
1479:                		default:
1480:                			AddDisplayStrAndNewLine("???");
9D001B0C  3C029D00   LUI V0, -25344
9D001B10  24445D50   ADDIU A0, V0, 23888
9D001B14  0F402DDD   JAL AddDisplayStrAndNewLine
9D001B18  00000000   NOP
1481:                			nRetVal = MENU_SELECTED;
9D001B1C  24020001   ADDIU V0, ZERO, 1
9D001B20  AFC20010   SW V0, 16(S8)
1482:                			break;
9D001B24  00000000   NOP
1483:                		}
1484:                
1485:                	eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D001B28  AF808048   SW ZERO, -32696(GP)
1486:                	return nRetVal;
9D001B2C  8FC20010   LW V0, 16(S8)
1487:                }
9D001B30  03C0E821   ADDU SP, S8, ZERO
9D001B34  8FBF006C   LW RA, 108(SP)
9D001B38  8FBE0068   LW S8, 104(SP)
9D001B3C  27BD0070   ADDIU SP, SP, 112
9D001B40  03E00008   JR RA
9D001B44  00000000   NOP
1488:                
1489:                
1490:                //*****************************************************************************
1491:                //					C l o s e d L o o p	M o v e M e n u ( )
1492:                //*****************************************************************************
1493:                
1494:                
1495:                int ClosedLoopMoveMenu(UART_MODULE UARTid, char cKeystroke)
1496:                {
9D001B48  27BDFF88   ADDIU SP, SP, -120
9D001B4C  AFBF0074   SW RA, 116(SP)
9D001B50  AFBE0070   SW S8, 112(SP)
9D001B54  03A0F021   ADDU S8, SP, ZERO
9D001B58  AFC40078   SW A0, 120(S8)
9D001B5C  00A01021   ADDU V0, A1, ZERO
9D001B60  A3C2007C   SB V0, 124(S8)
1497:                
1498:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1499:                	int nStatus = 0;
9D001B64  AFC00068   SW ZERO, 104(S8)
1500:                	int nRetVal = COMMAND_SELECTED;
9D001B68  24020002   ADDIU V0, ZERO, 2
9D001B6C  AFC20010   SW V0, 16(S8)
1501:                
1502:                	// clear the screen
1503:                	ClearDisplayStr();
9D001B70  0F402DB6   JAL ClearDisplayStr
9D001B74  00000000   NOP
1504:                	AddDisplayNewLine();
9D001B78  0F402E24   JAL AddDisplayNewLine
9D001B7C  00000000   NOP
1505:                
1506:                	// display the current panel orientation
1507:                	AddDisplayStr("\tOrientation: ");
9D001B80  3C029D00   LUI V0, -25344
9D001B84  24445DD4   ADDIU A0, V0, 24020
9D001B88  0F402DC0   JAL AddDisplayStr
9D001B8C  00000000   NOP
1508:                	CurrentOrientation_Format(szfnDisplayStr);
9D001B90  27C20014   ADDIU V0, S8, 20
9D001B94  00402021   ADDU A0, V0, ZERO
9D001B98  0F4034C2   JAL CurrentOrientation_Format
9D001B9C  00000000   NOP
1509:                	AddDisplayStrAndNewLine(szfnDisplayStr);
9D001BA0  27C20014   ADDIU V0, S8, 20
9D001BA4  00402021   ADDU A0, V0, ZERO
9D001BA8  0F402DDD   JAL AddDisplayStrAndNewLine
9D001BAC  00000000   NOP
1510:                
1511:                	// check for completion of previously selected command
1512:                //	if (efCommandEvents IS_NOT ZERO)
1513:                	if (IsCommandComplete() IS_FALSE)
9D001BB0  0F4034FF   JAL IsCommandComplete
9D001BB4  00000000   NOP
9D001BB8  14400012   BNE V0, ZERO, 0x9D001C04
9D001BBC  00000000   NOP
1514:                		{
1515:                		// previous command has not been completed, so do NOT allow selection of additional commands OTHER than Reset
1516:                		RuntimeError(MENU_FSM_ERROR_COMMAND_OVERRUN);
9D001BC0  2404003B   ADDIU A0, ZERO, 59
9D001BC4  0F40365E   JAL _RuntimeError
9D001BC8  00000000   NOP
1517:                		AddDisplayStrAndNewLine("NOT Done!");
9D001BCC  3C029D00   LUI V0, -25344
9D001BD0  24445DE4   ADDIU A0, V0, 24036
9D001BD4  0F402DDD   JAL AddDisplayStrAndNewLine
9D001BD8  00000000   NOP
1518:                
1519:                		#ifndef _lint				// for some reason, putting this #ifdef around a single line does not work correctly...
1520:                		if (cKeystroke IS 'r')
9D001BDC  83C3007C   LB V1, 124(S8)
9D001BE0  24020072   ADDIU V0, ZERO, 114
9D001BE4  14620003   BNE V1, V0, 0x9D001BF4
9D001BE8  00000000   NOP
1521:                			{
1522:                				Reset();							// forces a complete reset, macro to  {_asm reset _endasm} gets PC-Lint ver lost!
9D001BEC  0F403508   JAL Reset
9D001BF0  00000000   NOP
1523:                			}
1524:                		#endif
1525:                
1526:                		eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D001BF4  AF808048   SW ZERO, -32696(GP)
1527:                		return COMMAND_SELECTED;
9D001BF8  24020002   ADDIU V0, ZERO, 2
9D001BFC  0B400854   J 0x9D002150
9D001C00  00000000   NOP
1528:                		}
1529:                
1530:                	switch(cKeystroke)
9D001C04  83C2007C   LB V0, 124(S8)
9D001C08  2442FFCF   ADDIU V0, V0, -49
9D001C0C  2C430048   SLTIU V1, V0, 72
9D001C10  10600146   BEQ V1, ZERO, 0x9D00212C
9D001C14  00000000   NOP
9D001C18  00021880   SLL V1, V0, 2
9D001C1C  3C029D00   LUI V0, -25344
9D001C20  24421C34   ADDIU V0, V0, 7220
9D001C24  00621021   ADDU V0, V1, V0
9D001C28  8C420000   LW V0, 0(V0)
9D001C2C  00400008   JR V0
9D001C30  00000000   NOP
1531:                		{
1532:                		// each of these cases simply sets a menu event flag for the requested move
1533:                		// the event flags are subsequently processed by the User FSM
1534:                		case '1':				// set move distace
1535:                			AddDisplayStr("Move Distance:");
9D001D54  3C029D00   LUI V0, -25344
9D001D58  24445DF0   ADDIU A0, V0, 24048
9D001D5C  0F402DC0   JAL AddDisplayStr
9D001D60  00000000   NOP
1536:                			AddDisplayStr((const char *)ftoa(fgfCLMoveDistance, &nStatus));
9D001D64  8F838100   LW V1, -32512(GP)
9D001D68  27C20068   ADDIU V0, S8, 104
9D001D6C  00602021   ADDU A0, V1, ZERO
9D001D70  00402821   ADDU A1, V0, ZERO
9D001D74  0F403090   JAL ftoa
9D001D78  00000000   NOP
9D001D7C  00402021   ADDU A0, V0, ZERO
9D001D80  0F402DC0   JAL AddDisplayStr
9D001D84  00000000   NOP
1537:                			AddDisplayStr("  _");
9D001D88  3C029D00   LUI V0, -25344
9D001D8C  24445D6C   ADDIU A0, V0, 23916
9D001D90  0F402DC0   JAL AddDisplayStr
9D001D94  00000000   NOP
1538:                			DisplayStr(UARTid);							// start display (serial output) of line
9D001D98  8FC40078   LW A0, 120(S8)
9D001D9C  0F402E32   JAL DisplayStr
9D001DA0  00000000   NOP
1539:                			nRetVal = PARAMETER_SELECTED;
9D001DA4  24020003   ADDIU V0, ZERO, 3
9D001DA8  AFC20010   SW V0, 16(S8)
1540:                			eParameter = PARAMETER_MOVE_DISTANCE;
9D001DAC  24020009   ADDIU V0, ZERO, 9
9D001DB0  AF828120   SW V0, -32480(GP)
1541:                			break;
9D001DB4  0B400852   J 0x9D002148
9D001DB8  00000000   NOP
1542:                
1543:                		case '2':				// move up
1544:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001DBC  0F4034F7   JAL SetCommandStarted
9D001DC0  00000000   NOP
1545:                			BITSET(efCommandEvents, EF_CMD_MOVE_UP);
9D001DC4  978280E0   LHU V0, -32544(GP)
9D001DC8  34420002   ORI V0, V0, 2
9D001DCC  3042FFFF   ANDI V0, V0, -1
9D001DD0  A78280E0   SH V0, -32544(GP)
1546:                			AddDisplayStr("Move Up ");
9D001DD4  3C029D00   LUI V0, -25344
9D001DD8  24445E00   ADDIU A0, V0, 24064
9D001DDC  0F402DC0   JAL AddDisplayStr
9D001DE0  00000000   NOP
1547:                			AddDisplayStr((const char *)ftoa(fgfCLMoveDistance, &nStatus));
9D001DE4  8F838100   LW V1, -32512(GP)
9D001DE8  27C20068   ADDIU V0, S8, 104
9D001DEC  00602021   ADDU A0, V1, ZERO
9D001DF0  00402821   ADDU A1, V0, ZERO
9D001DF4  0F403090   JAL ftoa
9D001DF8  00000000   NOP
9D001DFC  00402021   ADDU A0, V0, ZERO
9D001E00  0F402DC0   JAL AddDisplayStr
9D001E04  00000000   NOP
1548:                			AddDisplayStrAndNewLine(" Degrees");
9D001E08  3C029D00   LUI V0, -25344
9D001E0C  24445E0C   ADDIU A0, V0, 24076
9D001E10  0F402DDD   JAL AddDisplayStrAndNewLine
9D001E14  00000000   NOP
1549:                			break;
9D001E18  0B400852   J 0x9D002148
9D001E1C  00000000   NOP
1550:                
1551:                		case '3':				// move down
1552:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001E20  0F4034F7   JAL SetCommandStarted
9D001E24  00000000   NOP
1553:                			BITSET(efCommandEvents, EF_CMD_MOVE_DOWN);
9D001E28  978280E0   LHU V0, -32544(GP)
9D001E2C  34420004   ORI V0, V0, 4
9D001E30  3042FFFF   ANDI V0, V0, -1
9D001E34  A78280E0   SH V0, -32544(GP)
1554:                			AddDisplayStr("Move Down ");
9D001E38  3C029D00   LUI V0, -25344
9D001E3C  24445E18   ADDIU A0, V0, 24088
9D001E40  0F402DC0   JAL AddDisplayStr
9D001E44  00000000   NOP
1555:                			AddDisplayStr((const char *)ftoa(fgfCLMoveDistance, &nStatus));
9D001E48  8F838100   LW V1, -32512(GP)
9D001E4C  27C20068   ADDIU V0, S8, 104
9D001E50  00602021   ADDU A0, V1, ZERO
9D001E54  00402821   ADDU A1, V0, ZERO
9D001E58  0F403090   JAL ftoa
9D001E5C  00000000   NOP
9D001E60  00402021   ADDU A0, V0, ZERO
9D001E64  0F402DC0   JAL AddDisplayStr
9D001E68  00000000   NOP
1556:                			AddDisplayStrAndNewLine(" Degrees");
9D001E6C  3C029D00   LUI V0, -25344
9D001E70  24445E0C   ADDIU A0, V0, 24076
9D001E74  0F402DDD   JAL AddDisplayStrAndNewLine
9D001E78  00000000   NOP
1557:                			break;
9D001E7C  0B400852   J 0x9D002148
9D001E80  00000000   NOP
1558:                
1559:                		case '4':				// move right
1560:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001E84  0F4034F7   JAL SetCommandStarted
9D001E88  00000000   NOP
1561:                			BITSET(efCommandEvents, EF_CMD_MOVE_RIGHT);
9D001E8C  978280E0   LHU V0, -32544(GP)
9D001E90  34420008   ORI V0, V0, 8
9D001E94  3042FFFF   ANDI V0, V0, -1
9D001E98  A78280E0   SH V0, -32544(GP)
1562:                			AddDisplayStr("Move Right ");
9D001E9C  3C029D00   LUI V0, -25344
9D001EA0  24445E24   ADDIU A0, V0, 24100
9D001EA4  0F402DC0   JAL AddDisplayStr
9D001EA8  00000000   NOP
1563:                			AddDisplayStr((const char *)ftoa(fgfCLMoveDistance, &nStatus));
9D001EAC  8F838100   LW V1, -32512(GP)
9D001EB0  27C20068   ADDIU V0, S8, 104
9D001EB4  00602021   ADDU A0, V1, ZERO
9D001EB8  00402821   ADDU A1, V0, ZERO
9D001EBC  0F403090   JAL ftoa
9D001EC0  00000000   NOP
9D001EC4  00402021   ADDU A0, V0, ZERO
9D001EC8  0F402DC0   JAL AddDisplayStr
9D001ECC  00000000   NOP
1564:                			AddDisplayStrAndNewLine(" Degrees");
9D001ED0  3C029D00   LUI V0, -25344
9D001ED4  24445E0C   ADDIU A0, V0, 24076
9D001ED8  0F402DDD   JAL AddDisplayStrAndNewLine
9D001EDC  00000000   NOP
1565:                			break;
9D001EE0  0B400852   J 0x9D002148
9D001EE4  00000000   NOP
1566:                
1567:                		case '5':				// move left
1568:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001EE8  0F4034F7   JAL SetCommandStarted
9D001EEC  00000000   NOP
1569:                			BITSET(efCommandEvents, EF_CMD_MOVE_LEFT);
9D001EF0  978280E0   LHU V0, -32544(GP)
9D001EF4  34420010   ORI V0, V0, 16
9D001EF8  3042FFFF   ANDI V0, V0, -1
9D001EFC  A78280E0   SH V0, -32544(GP)
1570:                			AddDisplayStr("Move Left ");
9D001F00  3C029D00   LUI V0, -25344
9D001F04  24445E30   ADDIU A0, V0, 24112
9D001F08  0F402DC0   JAL AddDisplayStr
9D001F0C  00000000   NOP
1571:                			AddDisplayStr((const char *)ftoa(fgfCLMoveDistance, &nStatus));
9D001F10  8F838100   LW V1, -32512(GP)
9D001F14  27C20068   ADDIU V0, S8, 104
9D001F18  00602021   ADDU A0, V1, ZERO
9D001F1C  00402821   ADDU A1, V0, ZERO
9D001F20  0F403090   JAL ftoa
9D001F24  00000000   NOP
9D001F28  00402021   ADDU A0, V0, ZERO
9D001F2C  0F402DC0   JAL AddDisplayStr
9D001F30  00000000   NOP
1572:                			AddDisplayStrAndNewLine(" Degrees");
9D001F34  3C029D00   LUI V0, -25344
9D001F38  24445E0C   ADDIU A0, V0, 24076
9D001F3C  0F402DDD   JAL AddDisplayStrAndNewLine
9D001F40  00000000   NOP
1573:                			break;
9D001F44  0B400852   J 0x9D002148
9D001F48  00000000   NOP
1574:                
1575:                		case '6':				// move up to EOT
1576:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001F4C  0F4034F7   JAL SetCommandStarted
9D001F50  00000000   NOP
1577:                			BITSET(efCommandEvents, EF_CMD_MOVE_UP_TO_END);
9D001F54  978280E0   LHU V0, -32544(GP)
9D001F58  34420020   ORI V0, V0, 32
9D001F5C  3042FFFF   ANDI V0, V0, -1
9D001F60  A78280E0   SH V0, -32544(GP)
1578:                			AddDisplayStrAndNewLine("Move Up to End (fwd)");
9D001F64  3C029D00   LUI V0, -25344
9D001F68  24445E3C   ADDIU A0, V0, 24124
9D001F6C  0F402DDD   JAL AddDisplayStrAndNewLine
9D001F70  00000000   NOP
1579:                			break;
9D001F74  0B400852   J 0x9D002148
9D001F78  00000000   NOP
1580:                
1581:                		case '7':				// move down to EOT
1582:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001F7C  0F4034F7   JAL SetCommandStarted
9D001F80  00000000   NOP
1583:                			BITSET(efCommandEvents, EF_CMD_MOVE_DOWN_TO_END);
9D001F84  978280E0   LHU V0, -32544(GP)
9D001F88  34420040   ORI V0, V0, 64
9D001F8C  3042FFFF   ANDI V0, V0, -1
9D001F90  A78280E0   SH V0, -32544(GP)
1584:                			AddDisplayStrAndNewLine("Move Down to End (rev)");
9D001F94  3C029D00   LUI V0, -25344
9D001F98  24445E54   ADDIU A0, V0, 24148
9D001F9C  0F402DDD   JAL AddDisplayStrAndNewLine
9D001FA0  00000000   NOP
1585:                			break;
9D001FA4  0B400852   J 0x9D002148
9D001FA8  00000000   NOP
1586:                
1587:                		case '8':				// move right to EOT
1588:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001FAC  0F4034F7   JAL SetCommandStarted
9D001FB0  00000000   NOP
1589:                			BITSET(efCommandEvents, EF_CMD_MOVE_RIGHT_TO_END);
9D001FB4  978280E0   LHU V0, -32544(GP)
9D001FB8  34420080   ORI V0, V0, 128
9D001FBC  3042FFFF   ANDI V0, V0, -1
9D001FC0  A78280E0   SH V0, -32544(GP)
1590:                			AddDisplayStrAndNewLine("Move Right to End (fwd)");
9D001FC4  3C029D00   LUI V0, -25344
9D001FC8  24445E6C   ADDIU A0, V0, 24172
9D001FCC  0F402DDD   JAL AddDisplayStrAndNewLine
9D001FD0  00000000   NOP
1591:                			break;
9D001FD4  0B400852   J 0x9D002148
9D001FD8  00000000   NOP
1592:                
1593:                		case '9':				// move left to EOT
1594:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D001FDC  0F4034F7   JAL SetCommandStarted
9D001FE0  00000000   NOP
1595:                			BITSET(efCommandEvents, EF_CMD_MOVE_LEFT_TO_END);
9D001FE4  978280E0   LHU V0, -32544(GP)
9D001FE8  34420100   ORI V0, V0, 256
9D001FEC  3042FFFF   ANDI V0, V0, -1
9D001FF0  A78280E0   SH V0, -32544(GP)
1596:                			AddDisplayStrAndNewLine("Move Left to End (rev)");
9D001FF4  3C029D00   LUI V0, -25344
9D001FF8  24445E84   ADDIU A0, V0, 24196
9D001FFC  0F402DDD   JAL AddDisplayStrAndNewLine
9D002000  00000000   NOP
1597:                			break;
9D002004  0B400852   J 0x9D002148
9D002008  00000000   NOP
1598:                
1599:                		case 'a':				// one rotation in
1600:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D00200C  0F4034F7   JAL SetCommandStarted
9D002010  00000000   NOP
1601:                			BITSET(efCommandEvents, EF_CMD_ONE_ROTATION_UP);
9D002014  978280E0   LHU V0, -32544(GP)
9D002018  34422000   ORI V0, V0, 8192
9D00201C  3042FFFF   ANDI V0, V0, -1
9D002020  A78280E0   SH V0, -32544(GP)
1602:                			AddDisplayStrAndNewLine("One Rotation up (fwd)");
9D002024  3C029D00   LUI V0, -25344
9D002028  24445E9C   ADDIU A0, V0, 24220
9D00202C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002030  00000000   NOP
1603:                			break;
9D002034  0B400852   J 0x9D002148
9D002038  00000000   NOP
1604:                
1605:                		case 'b':				// one rotation out
1606:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D00203C  0F4034F7   JAL SetCommandStarted
9D002040  00000000   NOP
1607:                			BITSET(efCommandEvents, EF_CMD_ONE_ROTATION_DOWN);
9D002044  978280E0   LHU V0, -32544(GP)
9D002048  34424000   ORI V0, V0, 16384
9D00204C  3042FFFF   ANDI V0, V0, -1
9D002050  A78280E0   SH V0, -32544(GP)
1608:                			AddDisplayStrAndNewLine("One Rotation down (rev)");
9D002054  3C029D00   LUI V0, -25344
9D002058  24445EB4   ADDIU A0, V0, 24244
9D00205C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002060  00000000   NOP
1609:                			break;
9D002064  0B400852   J 0x9D002148
9D002068  00000000   NOP
1610:                
1611:                		case 'c':				// one rotation in
1612:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D00206C  0F4034F7   JAL SetCommandStarted
9D002070  00000000   NOP
1613:                			BITSET(efCommandEvents, EF_CMD_ONE_ROTATION_RIGHT);
9D002074  978380E0   LHU V1, -32544(GP)
9D002078  24028000   ADDIU V0, ZERO, -32768
9D00207C  00621025   OR V0, V1, V0
9D002080  3042FFFF   ANDI V0, V0, -1
9D002084  A78280E0   SH V0, -32544(GP)
1614:                			AddDisplayStrAndNewLine("One Rotation right (fwd)");
9D002088  3C029D00   LUI V0, -25344
9D00208C  24445ECC   ADDIU A0, V0, 24268
9D002090  0F402DDD   JAL AddDisplayStrAndNewLine
9D002094  00000000   NOP
1615:                			break;
9D002098  0B400852   J 0x9D002148
9D00209C  00000000   NOP
1616:                
1617:                		case 'd':				// one rotation out
1618:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D0020A0  0F4034F7   JAL SetCommandStarted
9D0020A4  00000000   NOP
1619:                			BITSET(efCommandEvents, EF_CMD_ONE_ROTATION_LEFT);
9D0020A8  978280E0   LHU V0, -32544(GP)
9D0020AC  A78280E0   SH V0, -32544(GP)
1620:                			AddDisplayStrAndNewLine("One Rotation left (rev)");
9D0020B0  3C029D00   LUI V0, -25344
9D0020B4  24445EE8   ADDIU A0, V0, 24296
9D0020B8  0F402DDD   JAL AddDisplayStrAndNewLine
9D0020BC  00000000   NOP
1621:                			break;
9D0020C0  0B400852   J 0x9D002148
9D0020C4  00000000   NOP
1622:                
1623:                		case 's':				// stop
1624:                			SetCommandStarted();								// mark command as started so we cannot misinterpret completion
9D0020C8  0F4034F7   JAL SetCommandStarted
9D0020CC  00000000   NOP
1625:                			BITSET(efCommandEvents, EF_CMD_STOP);
9D0020D0  978280E0   LHU V0, -32544(GP)
9D0020D4  A78280E0   SH V0, -32544(GP)
1626:                			AddDisplayStrAndNewLine("All Stop!");
9D0020D8  3C029D00   LUI V0, -25344
9D0020DC  24445DC8   ADDIU A0, V0, 24008
9D0020E0  0F402DDD   JAL AddDisplayStrAndNewLine
9D0020E4  00000000   NOP
1627:                			PWM_SetConfig(MOTOR_ELEVATION, PWM_CONFIG_STOPPED);	// stop both axis
9D0020E8  24040001   ADDIU A0, ZERO, 1
9D0020EC  00002821   ADDU A1, ZERO, ZERO
9D0020F0  0F402581   JAL PWM_SetConfig
9D0020F4  00000000   NOP
1628:                			PWM_SetConfig(MOTOR_AZIMUTH, PWM_CONFIG_STOPPED);
9D0020F8  00002021   ADDU A0, ZERO, ZERO
9D0020FC  00002821   ADDU A1, ZERO, ZERO
9D002100  0F402581   JAL PWM_SetConfig
9D002104  00000000   NOP
1629:                			break;
9D002108  0B400852   J 0x9D002148
9D00210C  00000000   NOP
1630:                
1631:                		case 'r':				// reset
1632:                			Reset();													// processor reset
9D002110  0F403508   JAL Reset
9D002114  00000000   NOP
1633:                			//lint -fallthrough  no need for a break here, we are doing a hard reset
1634:                
1635:                		case 'x':				// Redisplay Main Menu
1636:                			eCurrentMenu = MAIN_MENU;
9D002118  AF80810C   SW ZERO, -32500(GP)
1637:                			nRetVal = MENU_SELECTED;
9D00211C  24020001   ADDIU V0, ZERO, 1
9D002120  AFC20010   SW V0, 16(S8)
1638:                			break;
9D002124  0B400852   J 0x9D002148
9D002128  00000000   NOP
1639:                
1640:                		default:
1641:                			AddDisplayStrAndNewLine("???");
9D00212C  3C029D00   LUI V0, -25344
9D002130  24445D50   ADDIU A0, V0, 23888
9D002134  0F402DDD   JAL AddDisplayStrAndNewLine
9D002138  00000000   NOP
1642:                			nRetVal = MENU_SELECTED;
9D00213C  24020001   ADDIU V0, ZERO, 1
9D002140  AFC20010   SW V0, 16(S8)
1643:                			break;
9D002144  00000000   NOP
1644:                		}
1645:                
1646:                	eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D002148  AF808048   SW ZERO, -32696(GP)
1647:                	return nRetVal;
9D00214C  8FC20010   LW V0, 16(S8)
1648:                }
9D002150  03C0E821   ADDU SP, S8, ZERO
9D002154  8FBF0074   LW RA, 116(SP)
9D002158  8FBE0070   LW S8, 112(SP)
9D00215C  27BD0078   ADDIU SP, SP, 120
9D002160  03E00008   JR RA
9D002164  00000000   NOP
1649:                
1650:                
1651:                //*****************************************************************************
1652:                //							M o v e S e q u e n c e M e n u ( ) 
1653:                //*****************************************************************************
1654:                
1655:                int MoveSequenceMenu(char cKeystroke)
1656:                {
9D002168  27BDFF90   ADDIU SP, SP, -112
9D00216C  AFBF006C   SW RA, 108(SP)
9D002170  AFBE0068   SW S8, 104(SP)
9D002174  03A0F021   ADDU S8, SP, ZERO
9D002178  00801021   ADDU V0, A0, ZERO
9D00217C  A3C20070   SB V0, 112(S8)
1657:                
1658:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1659:                
1660:                	int nRetVal = COMMAND_SELECTED;
9D002180  24020002   ADDIU V0, ZERO, 2
9D002184  AFC20010   SW V0, 16(S8)
1661:                
1662:                	// clear the screen
1663:                	ClearDisplayStr();
9D002188  0F402DB6   JAL ClearDisplayStr
9D00218C  00000000   NOP
1664:                	AddDisplayNewLine();
9D002190  0F402E24   JAL AddDisplayNewLine
9D002194  00000000   NOP
1665:                
1666:                	// display the current panel orientation
1667:                	AddDisplayStr("\tOrientation: ");
9D002198  3C029D00   LUI V0, -25344
9D00219C  24445DD4   ADDIU A0, V0, 24020
9D0021A0  0F402DC0   JAL AddDisplayStr
9D0021A4  00000000   NOP
1668:                	CurrentOrientation_Format(szfnDisplayStr);
9D0021A8  27C20014   ADDIU V0, S8, 20
9D0021AC  00402021   ADDU A0, V0, ZERO
9D0021B0  0F4034C2   JAL CurrentOrientation_Format
9D0021B4  00000000   NOP
1669:                	AddDisplayStrAndNewLine(szfnDisplayStr);
9D0021B8  27C20014   ADDIU V0, S8, 20
9D0021BC  00402021   ADDU A0, V0, ZERO
9D0021C0  0F402DDD   JAL AddDisplayStrAndNewLine
9D0021C4  00000000   NOP
1670:                
1671:                	// check for completion of previously selected command
1672:                	if (IsMoveSequenceComplete() IS_FALSE)
9D0021C8  0F403510   JAL IsMoveSequenceComplete
9D0021CC  00000000   NOP
9D0021D0  14400012   BNE V0, ZERO, 0x9D00221C
9D0021D4  00000000   NOP
1673:                		{
1674:                		// previous command has not been completed, so do NOT allow selection of additional commands OTHER than Reset
1675:                		RuntimeError(MENU_FSM_ERROR_COMMAND_OVERRUN);
9D0021D8  2404003B   ADDIU A0, ZERO, 59
9D0021DC  0F40365E   JAL _RuntimeError
9D0021E0  00000000   NOP
1676:                		AddDisplayStrAndNewLine("NOT Done!");
9D0021E4  3C029D00   LUI V0, -25344
9D0021E8  24445DE4   ADDIU A0, V0, 24036
9D0021EC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0021F0  00000000   NOP
1677:                
1678:                		#ifndef _lint				// for some reason, putting this #ifdef around a single line does not work correctly...
1679:                		if (cKeystroke IS 'r')
9D0021F4  83C30070   LB V1, 112(S8)
9D0021F8  24020072   ADDIU V0, ZERO, 114
9D0021FC  14620003   BNE V1, V0, 0x9D00220C
9D002200  00000000   NOP
1680:                			{
1681:                				Reset();							// forces a complete reset, macro to  {_asm reset _endasm} gets PC-Lint ver lost!
9D002204  0F403508   JAL Reset
9D002208  00000000   NOP
1682:                			}
1683:                		#endif
1684:                	
1685:                		eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D00220C  AF808048   SW ZERO, -32696(GP)
1686:                		return COMMAND_SELECTED;
9D002210  24020002   ADDIU V0, ZERO, 2
9D002214  0B400987   J 0x9D00261C
9D002218  00000000   NOP
1687:                		}
1688:                
1689:                	switch(cKeystroke)
9D00221C  83C20070   LB V0, 112(S8)
9D002220  2442FFCF   ADDIU V0, V0, -49
9D002224  2C430048   SLTIU V1, V0, 72
9D002228  106000F3   BEQ V1, ZERO, 0x9D0025F8
9D00222C  00000000   NOP
9D002230  00021880   SLL V1, V0, 2
9D002234  3C029D00   LUI V0, -25344
9D002238  2442224C   ADDIU V0, V0, 8780
9D00223C  00621021   ADDU V0, V1, V0
9D002240  8C420000   LW V0, 0(V0)
9D002244  00400008   JR V0
9D002248  00000000   NOP
1690:                		{
1691:                		// each of these cases simply sets a menu event flag for the requested move
1692:                		// the event flags are subsequently processed by the User FSM
1693:                		case '1':				// find end points
1694:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00236C  0F403519   JAL SetMoveSequenceStarted
9D002370  00000000   NOP
1695:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_FIND_END_POINTS);	// set flag to start movement sequence
9D002374  978280DE   LHU V0, -32546(GP)
9D002378  34420002   ORI V0, V0, 2
9D00237C  3042FFFF   ANDI V0, V0, -1
9D002380  A78280DE   SH V0, -32546(GP)
1696:                			AddDisplayStrAndNewLine("Finding End Points.. Please wait!");
9D002384  3C029D00   LUI V0, -25344
9D002388  24445F00   ADDIU A0, V0, 24320
9D00238C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002390  00000000   NOP
1697:                			break;
9D002394  0B400985   J 0x9D002614
9D002398  00000000   NOP
1698:                
1699:                		case '2':				// move to center position
1700:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00239C  0F403519   JAL SetMoveSequenceStarted
9D0023A0  00000000   NOP
1701:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_MOVE_TO_CENTER);
9D0023A4  978280DE   LHU V0, -32546(GP)
9D0023A8  34420004   ORI V0, V0, 4
9D0023AC  3042FFFF   ANDI V0, V0, -1
9D0023B0  A78280DE   SH V0, -32546(GP)
1702:                			AddDisplayStrAndNewLine("Moving to Center");
9D0023B4  3C029D00   LUI V0, -25344
9D0023B8  24445F24   ADDIU A0, V0, 24356
9D0023BC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0023C0  00000000   NOP
1703:                			break;
9D0023C4  0B400985   J 0x9D002614
9D0023C8  00000000   NOP
1704:                
1705:                		case '3':				// move to stow position
1706:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D0023CC  0F403519   JAL SetMoveSequenceStarted
9D0023D0  00000000   NOP
1707:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_MOVE_TO_STOW);
9D0023D4  978280DE   LHU V0, -32546(GP)
9D0023D8  34420008   ORI V0, V0, 8
9D0023DC  3042FFFF   ANDI V0, V0, -1
9D0023E0  A78280DE   SH V0, -32546(GP)
1708:                			AddDisplayStrAndNewLine("Moving to Stow");
9D0023E4  3C029D00   LUI V0, -25344
9D0023E8  24445F38   ADDIU A0, V0, 24376
9D0023EC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0023F0  00000000   NOP
1709:                			break;
9D0023F4  0B400985   J 0x9D002614
9D0023F8  00000000   NOP
1710:                
1711:                		case '4':				// long move cycle
1712:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D0023FC  0F403519   JAL SetMoveSequenceStarted
9D002400  00000000   NOP
1713:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_MOVE_TO_SPA_TRACK);
9D002404  978280DE   LHU V0, -32546(GP)
9D002408  34420010   ORI V0, V0, 16
9D00240C  3042FFFF   ANDI V0, V0, -1
9D002410  A78280DE   SH V0, -32546(GP)
1714:                			AddDisplayStrAndNewLine("Moving to SPA Track");
9D002414  3C029D00   LUI V0, -25344
9D002418  24445F48   ADDIU A0, V0, 24392
9D00241C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002420  00000000   NOP
1715:                			break;
9D002424  0B400985   J 0x9D002614
9D002428  00000000   NOP
1716:                
1717:                		case '5':
1718:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00242C  0F403519   JAL SetMoveSequenceStarted
9D002430  00000000   NOP
1719:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_HALF_DEGREE_UP);
9D002434  978280DE   LHU V0, -32546(GP)
9D002438  34420020   ORI V0, V0, 32
9D00243C  3042FFFF   ANDI V0, V0, -1
9D002440  A78280DE   SH V0, -32546(GP)
1720:                			AddDisplayStrAndNewLine("move 0.5 degree Up");
9D002444  3C029D00   LUI V0, -25344
9D002448  24445F5C   ADDIU A0, V0, 24412
9D00244C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002450  00000000   NOP
1721:                			break;
9D002454  0B400985   J 0x9D002614
9D002458  00000000   NOP
1722:                
1723:                		case '6':
1724:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00245C  0F403519   JAL SetMoveSequenceStarted
9D002460  00000000   NOP
1725:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_HALF_DEGREE_DOWN);
9D002464  978280DE   LHU V0, -32546(GP)
9D002468  34420040   ORI V0, V0, 64
9D00246C  3042FFFF   ANDI V0, V0, -1
9D002470  A78280DE   SH V0, -32546(GP)
1726:                			AddDisplayStrAndNewLine("move 0.5 degree Down");
9D002474  3C029D00   LUI V0, -25344
9D002478  24445F70   ADDIU A0, V0, 24432
9D00247C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002480  00000000   NOP
1727:                			break;
9D002484  0B400985   J 0x9D002614
9D002488  00000000   NOP
1728:                
1729:                		case '7':
1730:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00248C  0F403519   JAL SetMoveSequenceStarted
9D002490  00000000   NOP
1731:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_HALF_DEGREE_RIGHT);
9D002494  978280DE   LHU V0, -32546(GP)
9D002498  34420080   ORI V0, V0, 128
9D00249C  3042FFFF   ANDI V0, V0, -1
9D0024A0  A78280DE   SH V0, -32546(GP)
1732:                			AddDisplayStrAndNewLine("move 0.5 degree Right");
9D0024A4  3C029D00   LUI V0, -25344
9D0024A8  24445F88   ADDIU A0, V0, 24456
9D0024AC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0024B0  00000000   NOP
1733:                			break;
9D0024B4  0B400985   J 0x9D002614
9D0024B8  00000000   NOP
1734:                
1735:                		case '8':
1736:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D0024BC  0F403519   JAL SetMoveSequenceStarted
9D0024C0  00000000   NOP
1737:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_HALF_DEGREE_LEFT);
9D0024C4  978280DE   LHU V0, -32546(GP)
9D0024C8  34420100   ORI V0, V0, 256
9D0024CC  3042FFFF   ANDI V0, V0, -1
9D0024D0  A78280DE   SH V0, -32546(GP)
1738:                			AddDisplayStrAndNewLine("move 0.5 degree Left");
9D0024D4  3C029D00   LUI V0, -25344
9D0024D8  24445FA0   ADDIU A0, V0, 24480
9D0024DC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0024E0  00000000   NOP
1739:                			break;
9D0024E4  0B400985   J 0x9D002614
9D0024E8  00000000   NOP
1740:                
1741:                		case '9':
1742:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D0024EC  0F403519   JAL SetMoveSequenceStarted
9D0024F0  00000000   NOP
1743:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_ONE_DEGREE_UP);
9D0024F4  978280DE   LHU V0, -32546(GP)
9D0024F8  34420200   ORI V0, V0, 512
9D0024FC  3042FFFF   ANDI V0, V0, -1
9D002500  A78280DE   SH V0, -32546(GP)
1744:                			AddDisplayStrAndNewLine("move 1 degree Up");
9D002504  3C029D00   LUI V0, -25344
9D002508  24445FB8   ADDIU A0, V0, 24504
9D00250C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002510  00000000   NOP
1745:                			break;
9D002514  0B400985   J 0x9D002614
9D002518  00000000   NOP
1746:                
1747:                		case 'a':
1748:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00251C  0F403519   JAL SetMoveSequenceStarted
9D002520  00000000   NOP
1749:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_ONE_DEGREE_DOWN);
9D002524  978280DE   LHU V0, -32546(GP)
9D002528  34420400   ORI V0, V0, 1024
9D00252C  3042FFFF   ANDI V0, V0, -1
9D002530  A78280DE   SH V0, -32546(GP)
1750:                			AddDisplayStrAndNewLine("move 1 degree Down");
9D002534  3C029D00   LUI V0, -25344
9D002538  24445FCC   ADDIU A0, V0, 24524
9D00253C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002540  00000000   NOP
1751:                			break;
9D002544  0B400985   J 0x9D002614
9D002548  00000000   NOP
1752:                
1753:                		case 'b':
1754:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00254C  0F403519   JAL SetMoveSequenceStarted
9D002550  00000000   NOP
1755:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_ONE_DEGREE_RIGHT);
9D002554  978280DE   LHU V0, -32546(GP)
9D002558  34420800   ORI V0, V0, 2048
9D00255C  3042FFFF   ANDI V0, V0, -1
9D002560  A78280DE   SH V0, -32546(GP)
1756:                			AddDisplayStrAndNewLine("move 1 degree Right");
9D002564  3C029D00   LUI V0, -25344
9D002568  24445FE0   ADDIU A0, V0, 24544
9D00256C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002570  00000000   NOP
1757:                			break;
9D002574  0B400985   J 0x9D002614
9D002578  00000000   NOP
1758:                
1759:                		case 'c':
1760:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D00257C  0F403519   JAL SetMoveSequenceStarted
9D002580  00000000   NOP
1761:                			BITSET(efMoveSequenceEvents, EF_MOVE_SEQ_ONE_DEGREE_LEFT);
9D002584  978280DE   LHU V0, -32546(GP)
9D002588  34421000   ORI V0, V0, 4096
9D00258C  3042FFFF   ANDI V0, V0, -1
9D002590  A78280DE   SH V0, -32546(GP)
1762:                			AddDisplayStrAndNewLine("move 1 degree Left");
9D002594  3C029D00   LUI V0, -25344
9D002598  24445FF4   ADDIU A0, V0, 24564
9D00259C  0F402DDD   JAL AddDisplayStrAndNewLine
9D0025A0  00000000   NOP
1763:                			break;
9D0025A4  0B400985   J 0x9D002614
9D0025A8  00000000   NOP
1764:                
1765:                		case 's':				// stop
1766:                			SetMoveSequenceStarted();									// mark Move Sequence as started so we cannot misinterpret completion
9D0025AC  0F403519   JAL SetMoveSequenceStarted
9D0025B0  00000000   NOP
1767:                			BITSET(efCommandEvents, EF_MOVE_SEQ_STOP);					// set flag for STOP
9D0025B4  978280E0   LHU V0, -32544(GP)
9D0025B8  34422000   ORI V0, V0, 8192
9D0025BC  3042FFFF   ANDI V0, V0, -1
9D0025C0  A78280E0   SH V0, -32544(GP)
1768:                			AddDisplayStrAndNewLine("All Stop!");
9D0025C4  3C029D00   LUI V0, -25344
9D0025C8  24445DC8   ADDIU A0, V0, 24008
9D0025CC  0F402DDD   JAL AddDisplayStrAndNewLine
9D0025D0  00000000   NOP
1769:                			break;
9D0025D4  0B400985   J 0x9D002614
9D0025D8  00000000   NOP
1770:                
1771:                		case 'r':				// reset
1772:                			Reset();													// processor reset
9D0025DC  0F403508   JAL Reset
9D0025E0  00000000   NOP
1773:                			//lint -fallthrough  no need for a break here, we are doing a hard reset
1774:                
1775:                		case 'x':				// Redisplay Main Menu
1776:                			eCurrentMenu = MAIN_MENU;
9D0025E4  AF80810C   SW ZERO, -32500(GP)
1777:                			nRetVal = MENU_SELECTED;
9D0025E8  24020001   ADDIU V0, ZERO, 1
9D0025EC  AFC20010   SW V0, 16(S8)
1778:                			break;
9D0025F0  0B400985   J 0x9D002614
9D0025F4  00000000   NOP
1779:                
1780:                		default:
1781:                			AddDisplayStrAndNewLine("???");
9D0025F8  3C029D00   LUI V0, -25344
9D0025FC  24445D50   ADDIU A0, V0, 23888
9D002600  0F402DDD   JAL AddDisplayStrAndNewLine
9D002604  00000000   NOP
1782:                			nRetVal = MENU_SELECTED;
9D002608  24020001   ADDIU V0, ZERO, 1
9D00260C  AFC20010   SW V0, 16(S8)
1783:                			break;
9D002610  00000000   NOP
1784:                		}
1785:                
1786:                	eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D002614  AF808048   SW ZERO, -32696(GP)
1787:                	return nRetVal;
9D002618  8FC20010   LW V0, 16(S8)
1788:                }
9D00261C  03C0E821   ADDU SP, S8, ZERO
9D002620  8FBF006C   LW RA, 108(SP)
9D002624  8FBE0068   LW S8, 104(SP)
9D002628  27BD0070   ADDIU SP, SP, 112
9D00262C  03E00008   JR RA
9D002630  00000000   NOP
1789:                
1790:                
1791:                //*****************************************************************************
1792:                //					S y s t e m P a r a m e t e r s M e n u ( )
1793:                //*****************************************************************************
1794:                
1795:                int SystemParametersMenu(char cKeystroke)
1796:                {
9D002634  27BDFFE8   ADDIU SP, SP, -24
9D002638  AFBF0014   SW RA, 20(SP)
9D00263C  AFBE0010   SW S8, 16(SP)
9D002640  03A0F021   ADDU S8, SP, ZERO
9D002644  00801021   ADDU V0, A0, ZERO
9D002648  A3C20018   SB V0, 24(S8)
1797:                
1798:                	switch(cKeystroke)
9D00264C  83C20018   LB V0, 24(S8)
9D002650  24030033   ADDIU V1, ZERO, 51
9D002654  1043001C   BEQ V0, V1, 0x9D0026C8
9D002658  00000000   NOP
9D00265C  28430034   SLTI V1, V0, 52
9D002660  10600009   BEQ V1, ZERO, 0x9D002688
9D002664  00000000   NOP
9D002668  24030031   ADDIU V1, ZERO, 49
9D00266C  1043000E   BEQ V0, V1, 0x9D0026A8
9D002670  00000000   NOP
9D002674  24030032   ADDIU V1, ZERO, 50
9D002678  1043000F   BEQ V0, V1, 0x9D0026B8
9D00267C  00000000   NOP
9D002680  0B4009C1   J 0x9D002704
9D002684  00000000   NOP
9D002688  24030034   ADDIU V1, ZERO, 52
9D00268C  10430012   BEQ V0, V1, 0x9D0026D8
9D002690  00000000   NOP
9D002694  24030078   ADDIU V1, ZERO, 120
9D002698  10430017   BEQ V0, V1, 0x9D0026F8
9D00269C  00000000   NOP
9D0026A0  0B4009C1   J 0x9D002704
9D0026A4  00000000   NOP
1799:                	{
1800:                		case '1':				// location parameters Menu
1801:                			eCurrentMenu = LOCATION_PARAMETERS_MENU;
9D0026A8  24020007   ADDIU V0, ZERO, 7
9D0026AC  AF82810C   SW V0, -32500(GP)
1802:                			break;
9D0026B0  0B4009C5   J 0x9D002714
9D0026B4  00000000   NOP
1803:                
1804:                		case '2':				// azimuth parameters Menu
1805:                			eCurrentMenu = AZIMUTH_PARAMETERS_MENU;
9D0026B8  24020008   ADDIU V0, ZERO, 8
9D0026BC  AF82810C   SW V0, -32500(GP)
1806:                			break;
9D0026C0  0B4009C5   J 0x9D002714
9D0026C4  00000000   NOP
1807:                
1808:                		case '3':				// elevation parameters Menu
1809:                			eCurrentMenu = ELEVATION_PARAMETERS_MENU;
9D0026C8  24020009   ADDIU V0, ZERO, 9
9D0026CC  AF82810C   SW V0, -32500(GP)
1810:                			break;
9D0026D0  0B4009C5   J 0x9D002714
9D0026D4  00000000   NOP
1811:                
1812:                		case '4':				// write parameter table to flash
1813:                			WriteFlashParameterTable();		// ==> should have a return value
9D0026D8  0F40346C   JAL WriteFlashParameterTable
9D0026DC  00000000   NOP
1814:                			AddDisplayStrAndNewLine("Table Write Complete");
9D0026E0  3C029D00   LUI V0, -25344
9D0026E4  24446008   ADDIU A0, V0, 24584
9D0026E8  0F402DDD   JAL AddDisplayStrAndNewLine
9D0026EC  00000000   NOP
1815:                			break;
9D0026F0  0B4009C5   J 0x9D002714
9D0026F4  00000000   NOP
1816:                
1817:                		case 'x':				// Redisplay Main Menu
1818:                			eCurrentMenu = MAIN_MENU;
9D0026F8  AF80810C   SW ZERO, -32500(GP)
1819:                			break;
9D0026FC  0B4009C5   J 0x9D002714
9D002700  00000000   NOP
1820:                
1821:                		default:
1822:                            RuntimeError(MENU_FSM_ERROR_INVALID_STATE);
9D002704  24040033   ADDIU A0, ZERO, 51
9D002708  0F40365E   JAL _RuntimeError
9D00270C  00000000   NOP
1823:                			// redisplay current menu
1824:                			break;
9D002710  00000000   NOP
1825:                	}
1826:                
1827:                	return MENU_SELECTED;
9D002714  24020001   ADDIU V0, ZERO, 1
1828:                
1829:                }
9D002718  03C0E821   ADDU SP, S8, ZERO
9D00271C  8FBF0014   LW RA, 20(SP)
9D002720  8FBE0010   LW S8, 16(SP)
9D002724  27BD0018   ADDIU SP, SP, 24
9D002728  03E00008   JR RA
9D00272C  00000000   NOP
1830:                
1831:                int LocationParametersMenu(UART_MODULE UARTid, char cKeystroke)
1832:                {
9D002730  27BDFF88   ADDIU SP, SP, -120
9D002734  AFBF0074   SW RA, 116(SP)
9D002738  AFBE0070   SW S8, 112(SP)
9D00273C  03A0F021   ADDU S8, SP, ZERO
9D002740  AFC40078   SW A0, 120(S8)
9D002744  00A01021   ADDU V0, A1, ZERO
9D002748  A3C2007C   SB V0, 124(S8)
1833:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1834:                	int nRetVal = COMMAND_SELECTED;
9D00274C  24020002   ADDIU V0, ZERO, 2
9D002750  AFC20010   SW V0, 16(S8)
1835:                	int nStatus = 0;
9D002754  AFC00068   SW ZERO, 104(S8)
1836:                
1837:                	ClearDisplayStr();
9D002758  0F402DB6   JAL ClearDisplayStr
9D00275C  00000000   NOP
1838:                	AddDisplayNewLine();
9D002760  0F402E24   JAL AddDisplayNewLine
9D002764  00000000   NOP
1839:                
1840:                	switch(cKeystroke)
9D002768  83C2007C   LB V0, 124(S8)
9D00276C  24030034   ADDIU V1, ZERO, 52
9D002770  10430062   BEQ V0, V1, 0x9D0028FC
9D002774  00000000   NOP
9D002778  28430035   SLTI V1, V0, 53
9D00277C  1060000C   BEQ V1, ZERO, 0x9D0027B0
9D002780  00000000   NOP
9D002784  24030032   ADDIU V1, ZERO, 50
9D002788  1043002C   BEQ V0, V1, 0x9D00283C
9D00278C  00000000   NOP
9D002790  28430033   SLTI V1, V0, 51
9D002794  10600041   BEQ V1, ZERO, 0x9D00289C
9D002798  00000000   NOP
9D00279C  24030031   ADDIU V1, ZERO, 49
9D0027A0  1043000E   BEQ V0, V1, 0x9D0027DC
9D0027A4  00000000   NOP
9D0027A8  0B400A8F   J 0x9D002A3C
9D0027AC  00000000   NOP
9D0027B0  24030036   ADDIU V1, ZERO, 54
9D0027B4  10430081   BEQ V0, V1, 0x9D0029BC
9D0027B8  00000000   NOP
9D0027BC  28430036   SLTI V1, V0, 54
9D0027C0  14600066   BNE V1, ZERO, 0x9D00295C
9D0027C4  00000000   NOP
9D0027C8  24030078   ADDIU V1, ZERO, 120
9D0027CC  10430095   BEQ V0, V1, 0x9D002A24
9D0027D0  00000000   NOP
9D0027D4  0B400A8F   J 0x9D002A3C
9D0027D8  00000000   NOP
1841:                	{
1842:                		case '1':				// fLatitude
1843:                			AddDisplayStr("fLatitude: ");
9D0027DC  3C029D00   LUI V0, -25344
9D0027E0  24446020   ADDIU A0, V0, 24608
9D0027E4  0F402DC0   JAL AddDisplayStr
9D0027E8  00000000   NOP
1844:                			AddDisplayStr((const char *)ftoa(ptrRAM_SystemParameters->fLatitude, &nStatus));
9D0027EC  8F828010   LW V0, -32752(GP)
9D0027F0  8C430004   LW V1, 4(V0)
9D0027F4  27C20068   ADDIU V0, S8, 104
9D0027F8  00602021   ADDU A0, V1, ZERO
9D0027FC  00402821   ADDU A1, V0, ZERO
9D002800  0F403090   JAL ftoa
9D002804  00000000   NOP
9D002808  00402021   ADDU A0, V0, ZERO
9D00280C  0F402DC0   JAL AddDisplayStr
9D002810  00000000   NOP
1845:                			AddDisplayStr("  _");
9D002814  3C029D00   LUI V0, -25344
9D002818  24445D6C   ADDIU A0, V0, 23916
9D00281C  0F402DC0   JAL AddDisplayStr
9D002820  00000000   NOP
1846:                			nRetVal = PARAMETER_SELECTED;
9D002824  24020003   ADDIU V0, ZERO, 3
9D002828  AFC20010   SW V0, 16(S8)
1847:                			eParameter = PARAMETER_LATITUDE;
9D00282C  24020001   ADDIU V0, ZERO, 1
9D002830  AF828120   SW V0, -32480(GP)
1848:                			break;
9D002834  0B400A96   J 0x9D002A58
9D002838  00000000   NOP
1849:                
1850:                		case '2':				// fLongitude
1851:                			AddDisplayStr("fLongitude: ");
9D00283C  3C029D00   LUI V0, -25344
9D002840  2444602C   ADDIU A0, V0, 24620
9D002844  0F402DC0   JAL AddDisplayStr
9D002848  00000000   NOP
1852:                			AddDisplayStr((const char *)ftoa(ptrRAM_SystemParameters->fLongitude, &nStatus));
9D00284C  8F828010   LW V0, -32752(GP)
9D002850  8C430008   LW V1, 8(V0)
9D002854  27C20068   ADDIU V0, S8, 104
9D002858  00602021   ADDU A0, V1, ZERO
9D00285C  00402821   ADDU A1, V0, ZERO
9D002860  0F403090   JAL ftoa
9D002864  00000000   NOP
9D002868  00402021   ADDU A0, V0, ZERO
9D00286C  0F402DC0   JAL AddDisplayStr
9D002870  00000000   NOP
1853:                			AddDisplayStr("  _");
9D002874  3C029D00   LUI V0, -25344
9D002878  24445D6C   ADDIU A0, V0, 23916
9D00287C  0F402DC0   JAL AddDisplayStr
9D002880  00000000   NOP
1854:                			nRetVal = PARAMETER_SELECTED;
9D002884  24020003   ADDIU V0, ZERO, 3
9D002888  AFC20010   SW V0, 16(S8)
1855:                			eParameter = PARAMETER_LONGITUDE;
9D00288C  24020002   ADDIU V0, ZERO, 2
9D002890  AF828120   SW V0, -32480(GP)
1856:                			break;
9D002894  0B400A96   J 0x9D002A58
9D002898  00000000   NOP
1857:                
1858:                		case '3':				// fElevation
1859:                			AddDisplayStr("fElevation: ");
9D00289C  3C029D00   LUI V0, -25344
9D0028A0  2444603C   ADDIU A0, V0, 24636
9D0028A4  0F402DC0   JAL AddDisplayStr
9D0028A8  00000000   NOP
1860:                			AddDisplayStr((const char *)ftoa(ptrRAM_SystemParameters->fElevation, &nStatus));
9D0028AC  8F828010   LW V0, -32752(GP)
9D0028B0  8C43000C   LW V1, 12(V0)
9D0028B4  27C20068   ADDIU V0, S8, 104
9D0028B8  00602021   ADDU A0, V1, ZERO
9D0028BC  00402821   ADDU A1, V0, ZERO
9D0028C0  0F403090   JAL ftoa
9D0028C4  00000000   NOP
9D0028C8  00402021   ADDU A0, V0, ZERO
9D0028CC  0F402DC0   JAL AddDisplayStr
9D0028D0  00000000   NOP
1861:                			AddDisplayStr("  _");
9D0028D4  3C029D00   LUI V0, -25344
9D0028D8  24445D6C   ADDIU A0, V0, 23916
9D0028DC  0F402DC0   JAL AddDisplayStr
9D0028E0  00000000   NOP
1862:                			nRetVal = PARAMETER_SELECTED;
9D0028E4  24020003   ADDIU V0, ZERO, 3
9D0028E8  AFC20010   SW V0, 16(S8)
1863:                			eParameter = PARAMETER_ELEVATION;
9D0028EC  24020003   ADDIU V0, ZERO, 3
9D0028F0  AF828120   SW V0, -32480(GP)
1864:                			break;
9D0028F4  0B400A96   J 0x9D002A58
9D0028F8  00000000   NOP
1865:                
1866:                		case '4':				// fRefraction
1867:                			AddDisplayStr("fRefraction: ");
9D0028FC  3C029D00   LUI V0, -25344
9D002900  2444604C   ADDIU A0, V0, 24652
9D002904  0F402DC0   JAL AddDisplayStr
9D002908  00000000   NOP
1868:                			AddDisplayStr((const char *)ftoa(ptrRAM_SystemParameters->fRefraction, &nStatus));
9D00290C  8F828010   LW V0, -32752(GP)
9D002910  8C430010   LW V1, 16(V0)
9D002914  27C20068   ADDIU V0, S8, 104
9D002918  00602021   ADDU A0, V1, ZERO
9D00291C  00402821   ADDU A1, V0, ZERO
9D002920  0F403090   JAL ftoa
9D002924  00000000   NOP
9D002928  00402021   ADDU A0, V0, ZERO
9D00292C  0F402DC0   JAL AddDisplayStr
9D002930  00000000   NOP
1869:                			AddDisplayStr("  _");
9D002934  3C029D00   LUI V0, -25344
9D002938  24445D6C   ADDIU A0, V0, 23916
9D00293C  0F402DC0   JAL AddDisplayStr
9D002940  00000000   NOP
1870:                			nRetVal = PARAMETER_SELECTED;
9D002944  24020003   ADDIU V0, ZERO, 3
9D002948  AFC20010   SW V0, 16(S8)
1871:                			eParameter = PARAMETER_REFRACTION;
9D00294C  24020004   ADDIU V0, ZERO, 4
9D002950  AF828120   SW V0, -32480(GP)
1872:                			break;
9D002954  0B400A96   J 0x9D002A58
9D002958  00000000   NOP
1873:                
1874:                		case '5':				// fTimeZone
1875:                			AddDisplayStr("fTimeZone: ");
9D00295C  3C029D00   LUI V0, -25344
9D002960  2444605C   ADDIU A0, V0, 24668
9D002964  0F402DC0   JAL AddDisplayStr
9D002968  00000000   NOP
1876:                			AddDisplayStr((const char *)ftoa(ptrRAM_SystemParameters->fTimeZone, &nStatus));
9D00296C  8F828010   LW V0, -32752(GP)
9D002970  8C430014   LW V1, 20(V0)
9D002974  27C20068   ADDIU V0, S8, 104
9D002978  00602021   ADDU A0, V1, ZERO
9D00297C  00402821   ADDU A1, V0, ZERO
9D002980  0F403090   JAL ftoa
9D002984  00000000   NOP
9D002988  00402021   ADDU A0, V0, ZERO
9D00298C  0F402DC0   JAL AddDisplayStr
9D002990  00000000   NOP
1877:                			AddDisplayStr("  _");
9D002994  3C029D00   LUI V0, -25344
9D002998  24445D6C   ADDIU A0, V0, 23916
9D00299C  0F402DC0   JAL AddDisplayStr
9D0029A0  00000000   NOP
1878:                			nRetVal = PARAMETER_SELECTED;
9D0029A4  24020003   ADDIU V0, ZERO, 3
9D0029A8  AFC20010   SW V0, 16(S8)
1879:                			eParameter = PARAMETER_TIMEZONE;
9D0029AC  24020005   ADDIU V0, ZERO, 5
9D0029B0  AF828120   SW V0, -32480(GP)
1880:                			break;
9D0029B4  0B400A96   J 0x9D002A58
9D0029B8  00000000   NOP
1881:                
1882:                		case '6':				// ucTracker_State
1883:                			AddDisplayStr("ucTracker_State: ");
9D0029BC  3C029D00   LUI V0, -25344
9D0029C0  24446068   ADDIU A0, V0, 24680
9D0029C4  0F402DC0   JAL AddDisplayStr
9D0029C8  00000000   NOP
1884:                			BYTEtoHexASCIIstr(ptrRAM_SystemParameters->ucTracker_State, szfnDisplayStr);
9D0029CC  8F828010   LW V0, -32752(GP)
9D0029D0  90420080   LBU V0, 128(V0)
9D0029D4  00401821   ADDU V1, V0, ZERO
9D0029D8  27C20014   ADDIU V0, S8, 20
9D0029DC  00602021   ADDU A0, V1, ZERO
9D0029E0  00402821   ADDU A1, V0, ZERO
9D0029E4  0F402BFC   JAL BYTEtoHexASCIIstr
9D0029E8  00000000   NOP
1885:                			AddDisplayStr(szfnDisplayStr);
9D0029EC  27C20014   ADDIU V0, S8, 20
9D0029F0  00402021   ADDU A0, V0, ZERO
9D0029F4  0F402DC0   JAL AddDisplayStr
9D0029F8  00000000   NOP
1886:                			AddDisplayStr("  _");
9D0029FC  3C029D00   LUI V0, -25344
9D002A00  24445D6C   ADDIU A0, V0, 23916
9D002A04  0F402DC0   JAL AddDisplayStr
9D002A08  00000000   NOP
1887:                			nRetVal = PARAMETER_SELECTED;
9D002A0C  24020003   ADDIU V0, ZERO, 3
9D002A10  AFC20010   SW V0, 16(S8)
1888:                			eParameter = PARAMETER_TRACKER_STATE;
9D002A14  24020006   ADDIU V0, ZERO, 6
9D002A18  AF828120   SW V0, -32480(GP)
1889:                			break;
9D002A1C  0B400A96   J 0x9D002A58
9D002A20  00000000   NOP
1890:                
1891:                		case 'x':				// Redisplay Main Menu
1892:                			eCurrentMenu = SYSTEM_PARAMETERS_MENU;
9D002A24  24020006   ADDIU V0, ZERO, 6
9D002A28  AF82810C   SW V0, -32500(GP)
1893:                			nRetVal = MENU_SELECTED;
9D002A2C  24020001   ADDIU V0, ZERO, 1
9D002A30  AFC20010   SW V0, 16(S8)
1894:                			break;
9D002A34  0B400A96   J 0x9D002A58
9D002A38  00000000   NOP
1895:                
1896:                		default:
1897:                			AddDisplayStrAndNewLine("???");
9D002A3C  3C029D00   LUI V0, -25344
9D002A40  24445D50   ADDIU A0, V0, 23888
9D002A44  0F402DDD   JAL AddDisplayStrAndNewLine
9D002A48  00000000   NOP
1898:                			nRetVal = MENU_SELECTED;
9D002A4C  24020001   ADDIU V0, ZERO, 1
9D002A50  AFC20010   SW V0, 16(S8)
1899:                			break;
9D002A54  00000000   NOP
1900:                	}
1901:                
1902:                
1903:                	DisplayStr(UARTid);										// start display (serial output) of line
9D002A58  8FC40078   LW A0, 120(S8)
9D002A5C  0F402E32   JAL DisplayStr
9D002A60  00000000   NOP
1904:                
1905:                	return nRetVal;
9D002A64  8FC20010   LW V0, 16(S8)
1906:                }
9D002A68  03C0E821   ADDU SP, S8, ZERO
9D002A6C  8FBF0074   LW RA, 116(SP)
9D002A70  8FBE0070   LW S8, 112(SP)
9D002A74  27BD0078   ADDIU SP, SP, 120
9D002A78  03E00008   JR RA
9D002A7C  00000000   NOP
1907:                
1908:                int AzimuthParametersMenu(UART_MODULE UARTid, char cKeystroke)
1909:                {
9D002A80  27BDFF88   ADDIU SP, SP, -120
9D002A84  AFBF0074   SW RA, 116(SP)
9D002A88  AFBE0070   SW S8, 112(SP)
9D002A8C  03A0F021   ADDU S8, SP, ZERO
9D002A90  AFC40078   SW A0, 120(S8)
9D002A94  00A01021   ADDU V0, A1, ZERO
9D002A98  A3C2007C   SB V0, 124(S8)
1910:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1911:                	int nRetVal = COMMAND_SELECTED;
9D002A9C  24020002   ADDIU V0, ZERO, 2
9D002AA0  AFC20010   SW V0, 16(S8)
1912:                	int nStatus = 0;
9D002AA4  AFC00014   SW ZERO, 20(S8)
1913:                
1914:                	ClearDisplayStr();
9D002AA8  0F402DB6   JAL ClearDisplayStr
9D002AAC  00000000   NOP
1915:                	AddDisplayNewLine();
9D002AB0  0F402E24   JAL AddDisplayNewLine
9D002AB4  00000000   NOP
1916:                
1917:                	AddDisplayStr("Not Implemented ");
9D002AB8  3C029D00   LUI V0, -25344
9D002ABC  2444607C   ADDIU A0, V0, 24700
9D002AC0  0F402DC0   JAL AddDisplayStr
9D002AC4  00000000   NOP
1918:                	AddDisplayNewLine();
9D002AC8  0F402E24   JAL AddDisplayNewLine
9D002ACC  00000000   NOP
1919:                
1920:                	switch(cKeystroke)
9D002AD0  83C3007C   LB V1, 124(S8)
9D002AD4  24020078   ADDIU V0, ZERO, 120
9D002AD8  14620007   BNE V1, V0, 0x9D002AF8
9D002ADC  00000000   NOP
1921:                	{
1922:                		case 'x':				// Redisplay Main Menu
1923:                			eCurrentMenu = SYSTEM_PARAMETERS_MENU;
9D002AE0  24020006   ADDIU V0, ZERO, 6
9D002AE4  AF82810C   SW V0, -32500(GP)
1924:                			nRetVal = MENU_SELECTED;
9D002AE8  24020001   ADDIU V0, ZERO, 1
9D002AEC  AFC20010   SW V0, 16(S8)
1925:                			break;
9D002AF0  0B400AC5   J 0x9D002B14
9D002AF4  00000000   NOP
1926:                
1927:                		default:
1928:                			AddDisplayStrAndNewLine("???");
9D002AF8  3C029D00   LUI V0, -25344
9D002AFC  24445D50   ADDIU A0, V0, 23888
9D002B00  0F402DDD   JAL AddDisplayStrAndNewLine
9D002B04  00000000   NOP
1929:                			nRetVal = MENU_SELECTED;
9D002B08  24020001   ADDIU V0, ZERO, 1
9D002B0C  AFC20010   SW V0, 16(S8)
1930:                			break;
9D002B10  00000000   NOP
1931:                	}
1932:                
1933:                	DisplayStr(UARTid);										// start display (serial output) of line
9D002B14  8FC40078   LW A0, 120(S8)
9D002B18  0F402E32   JAL DisplayStr
9D002B1C  00000000   NOP
1934:                
1935:                	return nRetVal;
9D002B20  8FC20010   LW V0, 16(S8)
1936:                }
9D002B24  03C0E821   ADDU SP, S8, ZERO
9D002B28  8FBF0074   LW RA, 116(SP)
9D002B2C  8FBE0070   LW S8, 112(SP)
9D002B30  27BD0078   ADDIU SP, SP, 120
9D002B34  03E00008   JR RA
9D002B38  00000000   NOP
1937:                
1938:                int ElevationParametersMenu(UART_MODULE UARTid, char cKeystroke)
1939:                {
9D002B3C  27BDFF88   ADDIU SP, SP, -120
9D002B40  AFBF0074   SW RA, 116(SP)
9D002B44  AFBE0070   SW S8, 112(SP)
9D002B48  03A0F021   ADDU S8, SP, ZERO
9D002B4C  AFC40078   SW A0, 120(S8)
9D002B50  00A01021   ADDU V0, A1, ZERO
9D002B54  A3C2007C   SB V0, 124(S8)
1940:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1941:                	int nRetVal = COMMAND_SELECTED;
9D002B58  24020002   ADDIU V0, ZERO, 2
9D002B5C  AFC20010   SW V0, 16(S8)
1942:                	int nStatus = 0;
9D002B60  AFC00014   SW ZERO, 20(S8)
1943:                
1944:                	ClearDisplayStr();
9D002B64  0F402DB6   JAL ClearDisplayStr
9D002B68  00000000   NOP
1945:                	AddDisplayNewLine();
9D002B6C  0F402E24   JAL AddDisplayNewLine
9D002B70  00000000   NOP
1946:                
1947:                	AddDisplayStr("Not Implemented ");
9D002B74  3C029D00   LUI V0, -25344
9D002B78  2444607C   ADDIU A0, V0, 24700
9D002B7C  0F402DC0   JAL AddDisplayStr
9D002B80  00000000   NOP
1948:                	AddDisplayNewLine();
9D002B84  0F402E24   JAL AddDisplayNewLine
9D002B88  00000000   NOP
1949:                
1950:                	switch(cKeystroke)
9D002B8C  83C3007C   LB V1, 124(S8)
9D002B90  24020078   ADDIU V0, ZERO, 120
9D002B94  14620007   BNE V1, V0, 0x9D002BB4
9D002B98  00000000   NOP
1951:                	{
1952:                		case 'x':				// Redisplay Main Menu
1953:                			eCurrentMenu = SYSTEM_PARAMETERS_MENU;
9D002B9C  24020006   ADDIU V0, ZERO, 6
9D002BA0  AF82810C   SW V0, -32500(GP)
1954:                			nRetVal = MENU_SELECTED;
9D002BA4  24020001   ADDIU V0, ZERO, 1
9D002BA8  AFC20010   SW V0, 16(S8)
1955:                			break;
9D002BAC  0B400AF4   J 0x9D002BD0
9D002BB0  00000000   NOP
1956:                
1957:                		default:
1958:                			AddDisplayStrAndNewLine("???");
9D002BB4  3C029D00   LUI V0, -25344
9D002BB8  24445D50   ADDIU A0, V0, 23888
9D002BBC  0F402DDD   JAL AddDisplayStrAndNewLine
9D002BC0  00000000   NOP
1959:                			nRetVal = MENU_SELECTED;
9D002BC4  24020001   ADDIU V0, ZERO, 1
9D002BC8  AFC20010   SW V0, 16(S8)
1960:                			break;
9D002BCC  00000000   NOP
1961:                	}
1962:                
1963:                	DisplayStr(UARTid);										// start display (serial output) of line
9D002BD0  8FC40078   LW A0, 120(S8)
9D002BD4  0F402E32   JAL DisplayStr
9D002BD8  00000000   NOP
1964:                
1965:                	return nRetVal;
9D002BDC  8FC20010   LW V0, 16(S8)
1966:                
1967:                }
9D002BE0  03C0E821   ADDU SP, S8, ZERO
9D002BE4  8FBF0074   LW RA, 116(SP)
9D002BE8  8FBE0070   LW S8, 112(SP)
9D002BEC  27BD0078   ADDIU SP, SP, 120
9D002BF0  03E00008   JR RA
9D002BF4  00000000   NOP
1968:                
1969:                
1970:                //*****************************************************************************
1971:                //							R e a d I n p u t s M e n u ( ) 
1972:                //*****************************************************************************
1973:                
1974:                int ReadInputsMenu(char cKeystroke)
1975:                {
9D002BF8  27BDFF90   ADDIU SP, SP, -112
9D002BFC  AFBF006C   SW RA, 108(SP)
9D002C00  AFBE0068   SW S8, 104(SP)
9D002C04  03A0F021   ADDU S8, SP, ZERO
9D002C08  00801021   ADDU V0, A0, ZERO
9D002C0C  A3C20070   SB V0, 112(S8)
1976:                
1977:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
1978:                
1979:                	int nRetVal = COMMAND_SELECTED;
9D002C10  24020002   ADDIU V0, ZERO, 2
9D002C14  AFC20010   SW V0, 16(S8)
1980:                
1981:                	ClearDisplayStr();
9D002C18  0F402DB6   JAL ClearDisplayStr
9D002C1C  00000000   NOP
1982:                	AddDisplayNewLine();
9D002C20  0F402E24   JAL AddDisplayNewLine
9D002C24  00000000   NOP
1983:                
1984:                	switch(cKeystroke)
9D002C28  83C20070   LB V0, 112(S8)
9D002C2C  24030034   ADDIU V1, ZERO, 52
9D002C30  10430039   BEQ V0, V1, 0x9D002D18
9D002C34  00000000   NOP
9D002C38  28430035   SLTI V1, V0, 53
9D002C3C  1060000C   BEQ V1, ZERO, 0x9D002C70
9D002C40  00000000   NOP
9D002C44  24030032   ADDIU V1, ZERO, 50
9D002C48  10430027   BEQ V0, V1, 0x9D002CE8
9D002C4C  00000000   NOP
9D002C50  28430033   SLTI V1, V0, 51
9D002C54  1060002A   BEQ V1, ZERO, 0x9D002D00
9D002C58  00000000   NOP
9D002C5C  24030031   ADDIU V1, ZERO, 49
9D002C60  1043000E   BEQ V0, V1, 0x9D002C9C
9D002C64  00000000   NOP
9D002C68  0B400B5D   J 0x9D002D74
9D002C6C  00000000   NOP
9D002C70  24030036   ADDIU V1, ZERO, 54
9D002C74  10430034   BEQ V0, V1, 0x9D002D48
9D002C78  00000000   NOP
9D002C7C  28430036   SLTI V1, V0, 54
9D002C80  1460002B   BNE V1, ZERO, 0x9D002D30
9D002C84  00000000   NOP
9D002C88  24030078   ADDIU V1, ZERO, 120
9D002C8C  10430034   BEQ V0, V1, 0x9D002D60
9D002C90  00000000   NOP
9D002C94  0B400B5D   J 0x9D002D74
9D002C98  00000000   NOP
1985:                	{
1986:                		case '1':				// motion sensor input pins
1987:                			AddDisplayStr("Motion (Hall) Sensor Inputs: ");
9D002C9C  3C029D00   LUI V0, -25344
9D002CA0  24446090   ADDIU A0, V0, 24720
9D002CA4  0F402DC0   JAL AddDisplayStr
9D002CA8  00000000   NOP
1988:                			WORDtoHexASCIIstr(GetMotionSensorState(), szfnDisplayStr);
9D002CAC  0F401B23   JAL GetMotionSensorState
9D002CB0  00000000   NOP
9D002CB4  00401821   ADDU V1, V0, ZERO
9D002CB8  27C20014   ADDIU V0, S8, 20
9D002CBC  00602021   ADDU A0, V1, ZERO
9D002CC0  00402821   ADDU A1, V0, ZERO
9D002CC4  0F402C22   JAL WORDtoHexASCIIstr
9D002CC8  00000000   NOP
1989:                			//WORDtoHexASCIIstr(0x00, szfnDisplayStr);
1990:                			AddDisplayStrAndNewLine(szfnDisplayStr);
9D002CCC  27C20014   ADDIU V0, S8, 20
9D002CD0  00402021   ADDU A0, V0, ZERO
9D002CD4  0F402DDD   JAL AddDisplayStrAndNewLine
9D002CD8  00000000   NOP
1991:                
1992:                			eResultLine = RESULT_SINGLE_LINE;			// only one result line to display
9D002CDC  AF808048   SW ZERO, -32696(GP)
1993:                			break;
9D002CE0  0B400B64   J 0x9D002D90
9D002CE4  00000000   NOP
1994:                
1995:                		case '2':				// Optical Wheel counter
1996:                			// multi-line output display
1997:                			eResultType = RESULT_READ_INPUTS_MOTION_SENSORS;
9D002CE8  24020005   ADDIU V0, ZERO, 5
9D002CEC  AF828114   SW V0, -32492(GP)
1998:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D002CF0  24020001   ADDIU V0, ZERO, 1
9D002CF4  AF828048   SW V0, -32696(GP)
1999:                			break;
9D002CF8  0B400B64   J 0x9D002D90
9D002CFC  00000000   NOP
2000:                
2001:                		case '3':				// Timers
2002:                			// multi-line output display
2003:                			eResultType = RESULT_READ_REGISTERS_TIMERS;
9D002D00  24020006   ADDIU V0, ZERO, 6
9D002D04  AF828114   SW V0, -32492(GP)
2004:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D002D08  24020001   ADDIU V0, ZERO, 1
9D002D0C  AF828048   SW V0, -32696(GP)
2005:                			break;
9D002D10  0B400B64   J 0x9D002D90
9D002D14  00000000   NOP
2006:                
2007:                		case '4':				// ADC registers
2008:                			// multi-line output display
2009:                			eResultType = RESULT_READ_REGISTERS_ADC_SETTINGS;
9D002D18  24020007   ADDIU V0, ZERO, 7
9D002D1C  AF828114   SW V0, -32492(GP)
2010:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D002D20  24020001   ADDIU V0, ZERO, 1
9D002D24  AF828048   SW V0, -32696(GP)
2011:                			break;
9D002D28  0B400B64   J 0x9D002D90
9D002D2C  00000000   NOP
2012:                
2013:                		case '5':				// ADC values
2014:                			// multi-line output display
2015:                			eResultType = RESULT_READ_INPUTS_ADC;
9D002D30  24020008   ADDIU V0, ZERO, 8
9D002D34  AF828114   SW V0, -32492(GP)
2016:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D002D38  24020001   ADDIU V0, ZERO, 1
9D002D3C  AF828048   SW V0, -32696(GP)
2017:                			break;
9D002D40  0B400B64   J 0x9D002D90
9D002D44  00000000   NOP
2018:                
2019:                		case '6':				// Switch Input values
2020:                			// multi-line output display
2021:                			eResultType = RESULT_READ_INPUTS_SWITCHES;
9D002D48  24020009   ADDIU V0, ZERO, 9
9D002D4C  AF828114   SW V0, -32492(GP)
2022:                			eResultLine = RESULT_LINE;					// first line to display is 1 of n
9D002D50  24020001   ADDIU V0, ZERO, 1
9D002D54  AF828048   SW V0, -32696(GP)
2023:                			break;
9D002D58  0B400B64   J 0x9D002D90
9D002D5C  00000000   NOP
2024:                
2025:                		case 'x':				// Redisplay Main Menu
2026:                			eCurrentMenu = MAIN_MENU;
9D002D60  AF80810C   SW ZERO, -32500(GP)
2027:                			nRetVal = MENU_SELECTED;
9D002D64  24020001   ADDIU V0, ZERO, 1
9D002D68  AFC20010   SW V0, 16(S8)
2028:                			break;
9D002D6C  0B400B64   J 0x9D002D90
9D002D70  00000000   NOP
2029:                
2030:                		default:
2031:                			AddDisplayStrAndNewLine("???");
9D002D74  3C029D00   LUI V0, -25344
9D002D78  24445D50   ADDIU A0, V0, 23888
9D002D7C  0F402DDD   JAL AddDisplayStrAndNewLine
9D002D80  00000000   NOP
2032:                			nRetVal = MENU_SELECTED;
9D002D84  24020001   ADDIU V0, ZERO, 1
9D002D88  AFC20010   SW V0, 16(S8)
2033:                			break;
9D002D8C  00000000   NOP
2034:                	}
2035:                
2036:                	return nRetVal;
9D002D90  8FC20010   LW V0, 16(S8)
2037:                }
9D002D94  03C0E821   ADDU SP, S8, ZERO
9D002D98  8FBF006C   LW RA, 108(SP)
9D002D9C  8FBE0068   LW S8, 104(SP)
9D002DA0  27BD0070   ADDIU SP, SP, 112
9D002DA4  03E00008   JR RA
9D002DA8  00000000   NOP
2038:                
2039:                //*****************************************************************************
2040:                //							D i s p l a y R e s u l t ( ) 
2041:                //*****************************************************************************
2042:                
2043:                // Display of multi-line output from commands
2044:                // Displays just ONE line per pass through the function (a very few instances display two lines)
2045:                // so multiple passes are required.
2046:                
2047:                // returns	TRUE is a line was displayed
2048:                //			FALSE if the fgwDisplayLineCtr value goes beyond the last line
2049:                BOOL DisplayResult(UART_MODULE UARTid)
2050:                {
9D002DAC  27BDFF88   ADDIU SP, SP, -120
9D002DB0  AFBF0074   SW RA, 116(SP)
9D002DB4  AFBE0070   SW S8, 112(SP)
9D002DB8  03A0F021   ADDU S8, SP, ZERO
9D002DBC  AFC40078   SW A0, 120(S8)
2051:                
2052:                	
2053:                	// this may not be large enough... used to be TWO lines
2054:                	LOCAL ARRAY char szfnDisplayStr[(DISPLAY_LINE_SIZE * 1) + 1];				// a few outputs in THIS function are actually TWO lines long on the MC1 Board
2055:                	WORD wADCValue;
2056:                	INT32U lDutyCycle;
2057:                	BOOL bRetVal = TRUE;
9D002DC0  24020001   ADDIU V0, ZERO, 1
9D002DC4  AFC20010   SW V0, 16(S8)
2058:                
2059:                	ClearDisplayStr();
9D002DC8  0F402DB6   JAL ClearDisplayStr
9D002DCC  00000000   NOP
2060:                
2061:                	switch(eResultType)
9D002DD0  8F828114   LW V0, -32492(GP)
9D002DD4  2C43000A   SLTIU V1, V0, 10
9D002DD8  1060051E   BEQ V1, ZERO, 0x9D004254
9D002DDC  00000000   NOP
9D002DE0  00021880   SLL V1, V0, 2
9D002DE4  3C029D00   LUI V0, -25344
9D002DE8  24422DFC   ADDIU V0, V0, 11772
9D002DEC  00621021   ADDU V0, V1, V0
9D002DF0  8C420000   LW V0, 0(V0)
9D002DF4  00400008   JR V0
9D002DF8  00000000   NOP
2062:                		{
2063:                		case RESULT_STATUS_LAST_MOVEMENT:
2064:                			{
2065:                			switch(fgwDisplayLineCtr)
9D002E24  97828110   LHU V0, -32496(GP)
9D002E28  1440000B   BNE V0, ZERO, 0x9D002E58
9D002E2C  00000000   NOP
2066:                				{
2067:                				case 0:
2068:                					AddDisplayStr("  Last Movement : ");
9D002E30  3C029D00   LUI V0, -25344
9D002E34  244460B0   ADDIU A0, V0, 24752
9D002E38  0F402DC0   JAL AddDisplayStr
9D002E3C  00000000   NOP
2069:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D002E40  97828110   LHU V0, -32496(GP)
9D002E44  24420001   ADDIU V0, V0, 1
9D002E48  3042FFFF   ANDI V0, V0, -1
9D002E4C  A7828110   SH V0, -32496(GP)
2070:                					break;
9D002E50  0B400B9A   J 0x9D002E68
9D002E54  00000000   NOP
2071:                #ifdef NOTDEF
2072:                				case 1:
2073:                					switch((enum tagMoveTypes)(pgMotionStats.eMoveType & 0x007F))
2074:                						{
2075:                						case MOVE_NONE:					// no move, stopped
2076:                							AddDisplayStr("MOVE_NONE");
2077:                							break;
2078:                
2079:                						case MOVE_ONE_ROTATION_OUT:
2080:                							AddDisplayStr("MOVE_ONE_ROTATION_OUT");
2081:                							break;
2082:                
2083:                						case MOVE_ONE_ROTATION_IN:
2084:                							AddDisplayStr("MOVE_ONE_ROTATION_IN");
2085:                							break;
2086:                
2087:                						case MOVE_SHORT_OUT:			// general move to right
2088:                							AddDisplayStr("MOVE_SHORT_OUT");
2089:                							break;
2090:                
2091:                						case MOVE_SHORT_IN:				// general move to left
2092:                							AddDisplayStr("MOVE_SHORT_IN");
2093:                							break;
2094:                
2095:                						case MOVE_LONG_OUT:			// general move to right
2096:                							AddDisplayStr("MOVE_LONG_OUT");
2097:                							break;
2098:                
2099:                						case MOVE_LONG_IN:				// general move to left
2100:                							AddDisplayStr("MOVE_LONG_IN");
2101:                							break;
2102:                
2103:                						case MOVE_OUT_TO_END:			// moving right to EOT
2104:                							AddDisplayStr("MOVE_OUT_TO_END");
2105:                							break;
2106:                
2107:                						case MOVE_IN_TO_END:			// moving left to EOT
2108:                							AddDisplayStr("MOVE_IN_TO_END");
2109:                							break;
2110:                
2111:                  						case MOVE_RUN_OUT:				// very long (0xFFFF counts) move to right
2112:                							AddDisplayStr("MOVE_RUN_OUT");
2113:                							break;
2114:                
2115:                						case MOVE_RUN_IN:				// very long (0xFFFF counts) move to left
2116:                							AddDisplayStr("MOVE_RUN_IN");
2117:                							break;
2118:                
2119:                						case MOVE_CENTER:				// move to previously determined center of travel
2120:                							AddDisplayStr("MOVE_CENTER");
2121:                							break;
2122:                
2123:                						case MOVE_STALL_RECOVERY:		// short, fast, reverse move to recover from a stall
2124:                							AddDisplayStr("MOVE_STALL_RECOVERY");
2125:                							break;
2126:                
2127:                						case MOVE_COMPLETE:				// not meaningful
2128:                						default:
2129:                							AddDisplayStr("Unknown");
2130:                							break;
2131:                						}
2132:                
2133:                					// note: PWM direction is NOT the same as PWM config; the config includes braking, coasting, etc
2134:                					AddDisplayStr("   PWM dir: ");
2135:                					switch(pgMotionStats.ePWMDirection)	
2136:                						{
2137:                						case PWM_DIR_REVERSE:
2138:                							AddDisplayStr("REVERSE");
2139:                							break;
2140:                
2141:                						case PWM_DIR_FORWARD:
2142:                							AddDisplayStr("FORWARD");
2143:                							break;
2144:                
2145:                						case PWM_DIR_STOPPED:
2146:                							AddDisplayStr("STOPPED (?)");
2147:                							break;
2148:                
2149:                						case PWM_DIR_UNKNOWN:
2150:                						default:
2151:                							AddDisplayStr("UNKNOWN");
2152:                							break;
2153:                						}
2154:                
2155:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2156:                					break;
2157:                
2158:                				case 2:
2159:                					AddDisplayStr("Starting Pos: ");
2160:                					INT16StoASCIIstr(pgMotionStats.nStartingPosition, INT16S_WIDTH, szfnDisplayStr);
2161:                					AddDisplayStr(szfnDisplayStr);
2162:                					AddDisplayStr("  Ending Pos: ");
2163:                					INT16StoASCIIstr(pgMotionStats.nEndingPosition, INT16S_WIDTH, szfnDisplayStr);
2164:                					AddDisplayStr(szfnDisplayStr);
2165:                					AddDisplayStr("  Distance: ");
2166:                					INT16StoASCIIstr(pgMotionStats.nDistance, INT16S_WIDTH, szfnDisplayStr);
2167:                					AddDisplayStr(szfnDisplayStr);
2168:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2169:                					break;
2170:                
2171:                				case 3:
2172:                					AddDisplayStr("Accel MSI Ticks: ");
2173:                					WORDtoASCIIstr(pgMotionStats.wMSI_AccelerationCount, WORD_WIDTH, szfnDisplayStr);
2174:                					AddDisplayStr(szfnDisplayStr);
2175:                					AddDisplayStr("  Constant MSI Ticks: ");
2176:                					WORDtoASCIIstr(pgMotionStats.wMSI_ConstantSpeedCount, WORD_WIDTH, szfnDisplayStr);
2177:                					AddDisplayStr(szfnDisplayStr);
2178:                					AddDisplayStr("  Decel MSI Ticks: ");
2179:                					WORDtoASCIIstr(pgMotionStats.wMSI_DecelerationCount, WORD_WIDTH, szfnDisplayStr);
2180:                					AddDisplayStr(szfnDisplayStr);
2181:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2182:                					break;
2183:                
2184:                				case 4:
2185:                					AddDisplayStr("  Min PWM MSI Ticks: ");
2186:                					WORDtoASCIIstr(pgMotionStats.wMSI_MinimumPWMCount, WORD_WIDTH, szfnDisplayStr);
2187:                					AddDisplayStr(szfnDisplayStr);
2188:                					AddDisplayStr("  Coast MSI Ticks: ");
2189:                					WORDtoASCIIstr(pgMotionStats.wMSI_CoastCount, WORD_WIDTH, szfnDisplayStr);
2190:                					AddDisplayStr(szfnDisplayStr);
2191:                					AddDisplayStr("  Total MSI Ticks: ");
2192:                					WORDtoASCIIstr(pgMotionStats.wMSI_TotalCount, WORD_WIDTH, szfnDisplayStr);
2193:                					AddDisplayStr(szfnDisplayStr);
2194:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2195:                					break;
2196:                
2197:                				case 5:
2198:                					AddDisplayStr("Accel Time: ");
2199:                					WORDtoASCIIstr(pgMotionStats.wAccelerationEndTime - pgMotionStats.wStartTime, WORD_WIDTH, szfnDisplayStr);
2200:                					AddDisplayStr(szfnDisplayStr);
2201:                					AddDisplayStr("  Constant Run Time: ");
2202:                					WORDtoASCIIstr(pgMotionStats.wConstantSpeedEndTime - pgMotionStats.wAccelerationEndTime, WORD_WIDTH, szfnDisplayStr);
2203:                					AddDisplayStr(szfnDisplayStr);
2204:                					AddDisplayStr("  Decel Time: ");
2205:                					WORDtoASCIIstr(pgMotionStats.wDecelerationEndTime - pgMotionStats.wConstantSpeedEndTime, WORD_WIDTH, szfnDisplayStr);
2206:                					AddDisplayStr(szfnDisplayStr);
2207:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2208:                					break;
2209:                
2210:                				case 6:
2211:                					AddDisplayStr("  Min PWM Time: ");
2212:                					WORDtoASCIIstr(pgMotionStats.wMinimumPWMEndTime - pgMotionStats.wDecelerationEndTime, WORD_WIDTH, szfnDisplayStr);
2213:                					AddDisplayStr(szfnDisplayStr);
2214:                					AddDisplayStr("  Coast Time: ");
2215:                					WORDtoASCIIstr(pgMotionStats.wCoastEndTime - pgMotionStats.wMinimumPWMEndTime, WORD_WIDTH, szfnDisplayStr);
2216:                					AddDisplayStr(szfnDisplayStr);
2217:                					AddDisplayStr("  Total Time: ");
2218:                					WORDtoASCIIstr(pgMotionStats.wCoastEndTime - pgMotionStats.wStartTime, WORD_WIDTH, szfnDisplayStr);
2219:                					AddDisplayStr(szfnDisplayStr);
2220:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2221:                					break;
2222:                
2223:                
2224:                				case 7:
2225:                					AddDisplayStr("Min Speed: ");
2226:                					WORDtoASCIIstr(pgMotionStats.wMinimumSpeed, WORD_WIDTH, szfnDisplayStr);
2227:                					AddDisplayStr(szfnDisplayStr);
2228:                					AddDisplayStr("  Max Speed: ");
2229:                					WORDtoASCIIstr(pgMotionStats.wMaximumSpeed, WORD_WIDTH, szfnDisplayStr);
2230:                					AddDisplayStr(szfnDisplayStr);
2231:                
2232:                					#ifdef CALC_AVERAGE_SPEED
2233:                						AddDisplayStr("  Avg Speed: ");
2234:                						WORDtoASCIIstr(pgMotionStats.wAverageSpeed, WORD_WIDTH, szfnDisplayStr);
2235:                						AddDisplayStr(szfnDisplayStr);
2236:                					#endif
2237:                
2238:                					AddDisplayStr("  Timeout: ");
2239:                					WORDtoASCIIstr(pgMotionStats.wLastMotionStallTimer, WORD_WIDTH, szfnDisplayStr);
2240:                					AddDisplayStr(szfnDisplayStr);
2241:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2242:                					break;
2243:                
2244:                				case 8:
2245:                					AddDisplayStr("PWM DutyCycle: Accel Min: ");
2246:                					WORDtoASCIIstr(pgMotionStats.wPWM_AccelDutyCycleMin, WORD_WIDTH, szfnDisplayStr);
2247:                					AddDisplayStr(szfnDisplayStr);
2248:                					AddDisplayStr("  Accel Max: ");
2249:                					WORDtoASCIIstr(pgMotionStats.wPWM_AccelDutyCycleMax, WORD_WIDTH, szfnDisplayStr);
2250:                					AddDisplayStr(szfnDisplayStr);
2251:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2252:                					break;
2253:                
2254:                				case 9:
2255:                					AddDisplayStr("   Accel Correct Min: ");
2256:                					INT16StoASCIIstr(pgMotionStats.nPWM_AccelDutyCycleCorrectionMin, WORD_WIDTH, szfnDisplayStr);
2257:                					AddDisplayStr(szfnDisplayStr);
2258:                					AddDisplayStr("  Accel Correct Max: ");
2259:                					INT16StoASCIIstr(pgMotionStats.nPWM_AccelDutyCycleCorrectionMax, WORD_WIDTH, szfnDisplayStr);
2260:                					AddDisplayStr(szfnDisplayStr);
2261:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2262:                					break;
2263:                
2264:                				case 10:
2265:                					AddDisplayStr("PWM DutyCycle: Run Max: ");
2266:                					WORDtoASCIIstr(pgMotionStats.wPWM_RunDutyCycleMax, WORD_WIDTH, szfnDisplayStr);
2267:                					AddDisplayStr(szfnDisplayStr);
2268:                					AddDisplayStr(" Run Correct Min: ");
2269:                					INT16StoASCIIstr(pgMotionStats.nPWM_RunDutyCycleCorrectionMin, WORD_WIDTH, szfnDisplayStr);
2270:                					AddDisplayStr(szfnDisplayStr);
2271:                					AddDisplayStr(" Run Correct Max: ");
2272:                					INT16StoASCIIstr(pgMotionStats.nPWM_RunDutyCycleCorrectionMax, WORD_WIDTH, szfnDisplayStr);
2273:                					AddDisplayStr(szfnDisplayStr);
2274:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2275:                					break;
2276:                
2277:                				case 11:
2278:                					AddDisplayStr("Motion Profile Index: Accel: ");
2279:                					WORDtoASCIIstr(pgMotionStats.bPWMAccelMotionIndex, WORD_WIDTH, szfnDisplayStr);
2280:                					AddDisplayStr(szfnDisplayStr);
2281:                					AddDisplayStr("  Decel: ");
2282:                					WORDtoASCIIstr(pgMotionStats.bPWMDecelMotionIndex, WORD_WIDTH, szfnDisplayStr);
2283:                					AddDisplayStr(szfnDisplayStr);
2284:                					AddDisplayStr("  Speed: ");
2285:                					WORDtoASCIIstr(pgMotionStats.bSpeedlMotionIndex, WORD_WIDTH, szfnDisplayStr);
2286:                					AddDisplayStr(szfnDisplayStr);
2287:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2288:                					break;
2289:                
2290:                				case 12:
2291:                					AddDisplayStr("PWM DutyCycle: Decel Max: ");
2292:                					WORDtoASCIIstr(pgMotionStats.wPWM_DecelDutyCycleMax, WORD_WIDTH, szfnDisplayStr);
2293:                					AddDisplayStr(szfnDisplayStr);
2294:                					AddDisplayStr("  Decel Min: ");
2295:                					WORDtoASCIIstr(pgMotionStats.wPWM_DecelDutyCycleMin, WORD_WIDTH, szfnDisplayStr);
2296:                					AddDisplayStr(szfnDisplayStr);
2297:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2298:                					break;
2299:                
2300:                				case 13:
2301:                					AddDisplayStr("Accel PWM Adjust: ");
2302:                					WORDtoASCIIstr(pgMotionStats.wAccelerationPWMAdjustmentCount, WORD_WIDTH, szfnDisplayStr);
2303:                					AddDisplayStr(szfnDisplayStr);
2304:                					AddDisplayStr("  Constant PWM Adjust: ");
2305:                					WORDtoASCIIstr(pgMotionStats.wConstantSpeedPWMAdjustmentCount, WORD_WIDTH, szfnDisplayStr);
2306:                					AddDisplayStr(szfnDisplayStr);
2307:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2308:                					break;
2309:                
2310:                				case 14:
2311:                					AddDisplayStr("Accel Events: ");
2312:                					WORDtoHexASCIIstr(pgMotionStats.efAccelerationMotionEvents, szfnDisplayStr);
2313:                					AddDisplayStr(szfnDisplayStr);
2314:                					AddDisplayStr("  Run: ");
2315:                					WORDtoHexASCIIstr(pgMotionStats.efConstantSpeedMotionEvents, szfnDisplayStr);
2316:                					AddDisplayStr(szfnDisplayStr);
2317:                					AddDisplayStr("  Decel: ");
2318:                					WORDtoHexASCIIstr(pgMotionStats.efDecelerationMotionEvents, szfnDisplayStr);
2319:                					AddDisplayStr(szfnDisplayStr);
2320:                					AddDisplayStr("  MinPWM: ");
2321:                					WORDtoHexASCIIstr(pgMotionStats.efMinimumPWMMotionEvents, szfnDisplayStr);
2322:                					AddDisplayStr(szfnDisplayStr);
2323:                					AddDisplayStr("  Coast: ");
2324:                					WORDtoHexASCIIstr(pgMotionStats.efCoastingMotionEvents, szfnDisplayStr);
2325:                					AddDisplayStr(szfnDisplayStr);
2326:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2327:                					break;
2328:                
2329:                				case 15:
2330:                					AddDisplayStr("Starting Event: ");
2331:                					WORDtoHexASCIIstr(pgMotionStats.efStartingEvent, szfnDisplayStr);
2332:                					AddDisplayStr(szfnDisplayStr);
2333:                					AddDisplayStr("  Ending Event: ");
2334:                					WORDtoHexASCIIstr(pgMotionStats.efEndingEvent, szfnDisplayStr);
2335:                					AddDisplayStr(szfnDisplayStr);
2336:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
2337:                					break;
2338:                #endif
2339:                				default:
2340:                					bRetVal = FALSE;															// nothing to display
9D002E58  AFC00010   SW ZERO, 16(S8)
2341:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D002E5C  24020002   ADDIU V0, ZERO, 2
9D002E60  AF828048   SW V0, -32696(GP)
2342:                					break;
9D002E64  00000000   NOP
2343:                
2344:                				}
2345:                			}
2346:                			break;
9D002E68  0B401099   J 0x9D004264
9D002E6C  00000000   NOP
2347:                
2348:                		case RESULT_READ_REGISTERS_MTN_SENSOR_SETTINGS:
2349:                			{
2350:                			switch(fgwDisplayLineCtr)
9D002E70  97828110   LHU V0, -32496(GP)
9D002E74  2C430009   SLTIU V1, V0, 9
9D002E78  106000DB   BEQ V1, ZERO, 0x9D0031E8
9D002E7C  00000000   NOP
9D002E80  00021880   SLL V1, V0, 2
9D002E84  3C029D00   LUI V0, -25344
9D002E88  24422E9C   ADDIU V0, V0, 11932
9D002E8C  00621021   ADDU V0, V1, V0
9D002E90  8C420000   LW V0, 0(V0)
9D002E94  00400008   JR V0
9D002E98  00000000   NOP
2351:                				{
2352:                				case 0:
2353:                					AddDisplayStr("  Input Compare (IC) Register Values");
9D002EC0  3C029D00   LUI V0, -25344
9D002EC4  244460C4   ADDIU A0, V0, 24772
9D002EC8  0F402DC0   JAL AddDisplayStr
9D002ECC  00000000   NOP
2354:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D002ED0  97828110   LHU V0, -32496(GP)
9D002ED4  24420001   ADDIU V0, V0, 1
9D002ED8  3042FFFF   ANDI V0, V0, -1
9D002EDC  A7828110   SH V0, -32496(GP)
2355:                					break;
9D002EE0  0B400C7E   J 0x9D0031F8
9D002EE4  00000000   NOP
2356:                
2357:                				case 1:
2358:                					AddDisplayStr("\tIC1CON IC1 Control Register:     ");
9D002EE8  3C029D00   LUI V0, -25344
9D002EEC  244460EC   ADDIU A0, V0, 24812
9D002EF0  0F402DC0   JAL AddDisplayStr
9D002EF4  00000000   NOP
2359:                					INT32UtoHexASCIIstr(IC1CON, szfnDisplayStr);
9D002EF8  3C02BF80   LUI V0, -16512
9D002EFC  8C432000   LW V1, 8192(V0)
9D002F00  27C20018   ADDIU V0, S8, 24
9D002F04  00602021   ADDU A0, V1, ZERO
9D002F08  00402821   ADDU A1, V0, ZERO
9D002F0C  0F402D75   JAL INT32UtoHexASCIIstr
9D002F10  00000000   NOP
2360:                					AddDisplayStr(szfnDisplayStr);
9D002F14  27C20018   ADDIU V0, S8, 24
9D002F18  00402021   ADDU A0, V0, ZERO
9D002F1C  0F402DC0   JAL AddDisplayStr
9D002F20  00000000   NOP
2361:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D002F24  97828110   LHU V0, -32496(GP)
9D002F28  24420001   ADDIU V0, V0, 1
9D002F2C  3042FFFF   ANDI V0, V0, -1
9D002F30  A7828110   SH V0, -32496(GP)
2362:                					break;
9D002F34  0B400C7E   J 0x9D0031F8
9D002F38  00000000   NOP
2363:                
2364:                				case 2:
2365:                					AddDisplayStr("\tIC1BUF IC1 Data FIFO       :     ");
9D002F3C  3C029D00   LUI V0, -25344
9D002F40  24446110   ADDIU A0, V0, 24848
9D002F44  0F402DC0   JAL AddDisplayStr
9D002F48  00000000   NOP
2366:                					WORDtoHexASCIIstr(IC1BUF, szfnDisplayStr);
9D002F4C  3C02BF80   LUI V0, -16512
9D002F50  8C422010   LW V0, 8208(V0)
9D002F54  3042FFFF   ANDI V0, V0, -1
9D002F58  00401821   ADDU V1, V0, ZERO
9D002F5C  27C20018   ADDIU V0, S8, 24
9D002F60  00602021   ADDU A0, V1, ZERO
9D002F64  00402821   ADDU A1, V0, ZERO
9D002F68  0F402C22   JAL WORDtoHexASCIIstr
9D002F6C  00000000   NOP
2367:                					AddDisplayStr(szfnDisplayStr);
9D002F70  27C20018   ADDIU V0, S8, 24
9D002F74  00402021   ADDU A0, V0, ZERO
9D002F78  0F402DC0   JAL AddDisplayStr
9D002F7C  00000000   NOP
2368:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D002F80  97828110   LHU V0, -32496(GP)
9D002F84  24420001   ADDIU V0, V0, 1
9D002F88  3042FFFF   ANDI V0, V0, -1
9D002F8C  A7828110   SH V0, -32496(GP)
2369:                					break;
9D002F90  0B400C7E   J 0x9D0031F8
9D002F94  00000000   NOP
2370:                
2371:                				case 3:
2372:                					AddDisplayNewLine();
9D002F98  0F402E24   JAL AddDisplayNewLine
9D002F9C  00000000   NOP
2373:                					AddDisplayStr("\tIC2CON IC2 Control Register:     ");
9D002FA0  3C029D00   LUI V0, -25344
9D002FA4  24446134   ADDIU A0, V0, 24884
9D002FA8  0F402DC0   JAL AddDisplayStr
9D002FAC  00000000   NOP
2374:                					INT32UtoHexASCIIstr(IC2CON, szfnDisplayStr);
9D002FB0  3C02BF80   LUI V0, -16512
9D002FB4  8C432200   LW V1, 8704(V0)
9D002FB8  27C20018   ADDIU V0, S8, 24
9D002FBC  00602021   ADDU A0, V1, ZERO
9D002FC0  00402821   ADDU A1, V0, ZERO
9D002FC4  0F402D75   JAL INT32UtoHexASCIIstr
9D002FC8  00000000   NOP
2375:                					AddDisplayStr(szfnDisplayStr);
9D002FCC  27C20018   ADDIU V0, S8, 24
9D002FD0  00402021   ADDU A0, V0, ZERO
9D002FD4  0F402DC0   JAL AddDisplayStr
9D002FD8  00000000   NOP
2376:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D002FDC  97828110   LHU V0, -32496(GP)
9D002FE0  24420001   ADDIU V0, V0, 1
9D002FE4  3042FFFF   ANDI V0, V0, -1
9D002FE8  A7828110   SH V0, -32496(GP)
2377:                					break;
9D002FEC  0B400C7E   J 0x9D0031F8
9D002FF0  00000000   NOP
2378:                
2379:                				case 4:
2380:                					AddDisplayStr("\tIC2BUF IC1 Data FIFO       :     ");
9D002FF4  3C029D00   LUI V0, -25344
9D002FF8  24446158   ADDIU A0, V0, 24920
9D002FFC  0F402DC0   JAL AddDisplayStr
9D003000  00000000   NOP
2381:                					WORDtoHexASCIIstr(IC2BUF, szfnDisplayStr);
9D003004  3C02BF80   LUI V0, -16512
9D003008  8C422210   LW V0, 8720(V0)
9D00300C  3042FFFF   ANDI V0, V0, -1
9D003010  00401821   ADDU V1, V0, ZERO
9D003014  27C20018   ADDIU V0, S8, 24
9D003018  00602021   ADDU A0, V1, ZERO
9D00301C  00402821   ADDU A1, V0, ZERO
9D003020  0F402C22   JAL WORDtoHexASCIIstr
9D003024  00000000   NOP
2382:                					AddDisplayStr(szfnDisplayStr);
9D003028  27C20018   ADDIU V0, S8, 24
9D00302C  00402021   ADDU A0, V0, ZERO
9D003030  0F402DC0   JAL AddDisplayStr
9D003034  00000000   NOP
2383:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003038  97828110   LHU V0, -32496(GP)
9D00303C  24420001   ADDIU V0, V0, 1
9D003040  3042FFFF   ANDI V0, V0, -1
9D003044  A7828110   SH V0, -32496(GP)
2384:                					break;
9D003048  0B400C7E   J 0x9D0031F8
9D00304C  00000000   NOP
2385:                
2386:                				case 5:
2387:                					AddDisplayNewLine();
9D003050  0F402E24   JAL AddDisplayNewLine
9D003054  00000000   NOP
2388:                					AddDisplayStr("\tT3CON Timer 3 Control Register:  ");
9D003058  3C029D00   LUI V0, -25344
9D00305C  2444617C   ADDIU A0, V0, 24956
9D003060  0F402DC0   JAL AddDisplayStr
9D003064  00000000   NOP
2389:                					INT32UtoHexASCIIstr(T3CON, szfnDisplayStr);
9D003068  3C02BF80   LUI V0, -16512
9D00306C  8C430A00   LW V1, 2560(V0)
9D003070  27C20018   ADDIU V0, S8, 24
9D003074  00602021   ADDU A0, V1, ZERO
9D003078  00402821   ADDU A1, V0, ZERO
9D00307C  0F402D75   JAL INT32UtoHexASCIIstr
9D003080  00000000   NOP
2390:                					AddDisplayStr(szfnDisplayStr);
9D003084  27C20018   ADDIU V0, S8, 24
9D003088  00402021   ADDU A0, V0, ZERO
9D00308C  0F402DC0   JAL AddDisplayStr
9D003090  00000000   NOP
2391:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003094  97828110   LHU V0, -32496(GP)
9D003098  24420001   ADDIU V0, V0, 1
9D00309C  3042FFFF   ANDI V0, V0, -1
9D0030A0  A7828110   SH V0, -32496(GP)
2392:                					break;
9D0030A4  0B400C7E   J 0x9D0031F8
9D0030A8  00000000   NOP
2393:                
2394:                				case 6:
2395:                					AddDisplayStr("\tTMR3 Timer 3 Register:           ");
9D0030AC  3C029D00   LUI V0, -25344
9D0030B0  244461A0   ADDIU A0, V0, 24992
9D0030B4  0F402DC0   JAL AddDisplayStr
9D0030B8  00000000   NOP
2396:                					INT32UtoHexASCIIstr(TMR3, szfnDisplayStr);
9D0030BC  3C02BF80   LUI V0, -16512
9D0030C0  8C430A10   LW V1, 2576(V0)
9D0030C4  27C20018   ADDIU V0, S8, 24
9D0030C8  00602021   ADDU A0, V1, ZERO
9D0030CC  00402821   ADDU A1, V0, ZERO
9D0030D0  0F402D75   JAL INT32UtoHexASCIIstr
9D0030D4  00000000   NOP
2397:                					AddDisplayStr(szfnDisplayStr);
9D0030D8  27C20018   ADDIU V0, S8, 24
9D0030DC  00402021   ADDU A0, V0, ZERO
9D0030E0  0F402DC0   JAL AddDisplayStr
9D0030E4  00000000   NOP
2398:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0030E8  97828110   LHU V0, -32496(GP)
9D0030EC  24420001   ADDIU V0, V0, 1
9D0030F0  3042FFFF   ANDI V0, V0, -1
9D0030F4  A7828110   SH V0, -32496(GP)
2399:                					break;
9D0030F8  0B400C7E   J 0x9D0031F8
9D0030FC  00000000   NOP
2400:                
2401:                				case 7:
2402:                					AddDisplayStr("\tPR3 Period3 Register:            ");
9D003100  3C029D00   LUI V0, -25344
9D003104  244461C4   ADDIU A0, V0, 25028
9D003108  0F402DC0   JAL AddDisplayStr
9D00310C  00000000   NOP
2403:                					INT32UtoHexASCIIstr(PR3, szfnDisplayStr);
9D003110  3C02BF80   LUI V0, -16512
9D003114  8C430A20   LW V1, 2592(V0)
9D003118  27C20018   ADDIU V0, S8, 24
9D00311C  00602021   ADDU A0, V1, ZERO
9D003120  00402821   ADDU A1, V0, ZERO
9D003124  0F402D75   JAL INT32UtoHexASCIIstr
9D003128  00000000   NOP
2404:                					AddDisplayStr(szfnDisplayStr);
9D00312C  27C20018   ADDIU V0, S8, 24
9D003130  00402021   ADDU A0, V0, ZERO
9D003134  0F402DC0   JAL AddDisplayStr
9D003138  00000000   NOP
2405:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D00313C  97828110   LHU V0, -32496(GP)
9D003140  24420001   ADDIU V0, V0, 1
9D003144  3042FFFF   ANDI V0, V0, -1
9D003148  A7828110   SH V0, -32496(GP)
2406:                					break;
9D00314C  0B400C7E   J 0x9D0031F8
9D003150  00000000   NOP
2407:                
2408:                				case 8:
2409:                					AddDisplayNewLine();
9D003154  0F402E24   JAL AddDisplayNewLine
9D003158  00000000   NOP
2410:                					AddDisplayStr("\tIC frequency:            ");
9D00315C  3C029D00   LUI V0, -25344
9D003160  244461E8   ADDIU A0, V0, 25064
9D003164  0F402DC0   JAL AddDisplayStr
9D003168  00000000   NOP
2411:                					INT32UtoASCIIstr((INT32U)(GetPeripheralClock() / (INT32U)TIMER3_CLK_PRESCALE), INT32U_WIDTH, szfnDisplayStr);
9D00316C  3C02BF81   LUI V0, -16511
9D003170  8C42F000   LW V0, -4096(V0)
9D003174  7C420CC0   EXT V0, V0, 19, 2
9D003178  304200FF   ANDI V0, V0, 255
9D00317C  3C0304C4   LUI V1, 1220
9D003180  3463B400   ORI V1, V1, -19456
9D003184  00431006   SRLV V0, V1, V0
9D003188  00021A02   SRL V1, V0, 8
9D00318C  27C20018   ADDIU V0, S8, 24
9D003190  00602021   ADDU A0, V1, ZERO
9D003194  2405000A   ADDIU A1, ZERO, 10
9D003198  00403021   ADDU A2, V0, ZERO
9D00319C  0F402D22   JAL INT32UtoASCIIstr
9D0031A0  00000000   NOP
2412:                					AddDisplayStr(szfnDisplayStr);
9D0031A4  27C20018   ADDIU V0, S8, 24
9D0031A8  00402021   ADDU A0, V0, ZERO
9D0031AC  0F402DC0   JAL AddDisplayStr
9D0031B0  00000000   NOP
2413:                					AddDisplayStr("Hz");
9D0031B4  3C029D00   LUI V0, -25344
9D0031B8  24446204   ADDIU A0, V0, 25092
9D0031BC  0F402DC0   JAL AddDisplayStr
9D0031C0  00000000   NOP
2414:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0031C4  97828110   LHU V0, -32496(GP)
9D0031C8  24420001   ADDIU V0, V0, 1
9D0031CC  3042FFFF   ANDI V0, V0, -1
9D0031D0  A7828110   SH V0, -32496(GP)
2415:                					bRetVal = FALSE;															// nothing to display
9D0031D4  AFC00010   SW ZERO, 16(S8)
2416:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
9D0031D8  24020002   ADDIU V0, ZERO, 2
9D0031DC  AF828048   SW V0, -32696(GP)
2417:                					break;
9D0031E0  0B400C7E   J 0x9D0031F8
9D0031E4  00000000   NOP
2418:                
2419:                				default:
2420:                					bRetVal = FALSE;															// nothing to display
9D0031E8  AFC00010   SW ZERO, 16(S8)
2421:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D0031EC  24020002   ADDIU V0, ZERO, 2
9D0031F0  AF828048   SW V0, -32696(GP)
2422:                					break;
9D0031F4  00000000   NOP
2423:                
2424:                				}
2425:                			}
2426:                			break;
9D0031F8  0B401099   J 0x9D004264
9D0031FC  00000000   NOP
2427:                
2428:                
2429:                		case RESULT_READ_REGISTERS_PWM_SETTINGS:
2430:                			{
2431:                			switch(fgwDisplayLineCtr)
9D003200  97828110   LHU V0, -32496(GP)
9D003204  2C430011   SLTIU V1, V0, 17
9D003208  1060018B   BEQ V1, ZERO, 0x9D003838
9D00320C  00000000   NOP
9D003210  00021880   SLL V1, V0, 2
9D003214  3C029D00   LUI V0, -25344
9D003218  2442322C   ADDIU V0, V0, 12844
9D00321C  00621021   ADDU V0, V1, V0
9D003220  8C420000   LW V0, 0(V0)
9D003224  00400008   JR V0
9D003228  00000000   NOP
2432:                				{
2433:                				case 0:
2434:                					AddDisplayStr("  Output Compare (OC) Register Values");
9D003270  3C029D00   LUI V0, -25344
9D003274  24446208   ADDIU A0, V0, 25096
9D003278  0F402DC0   JAL AddDisplayStr
9D00327C  00000000   NOP
2435:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003280  97828110   LHU V0, -32496(GP)
9D003284  24420001   ADDIU V0, V0, 1
9D003288  3042FFFF   ANDI V0, V0, -1
9D00328C  A7828110   SH V0, -32496(GP)
2436:                					break;
9D003290  0B400E12   J 0x9D003848
9D003294  00000000   NOP
2437:                
2438:                				case 1:
2439:                					AddDisplayStr("\tOC1CON OC1 Control Register:     ");
9D003298  3C029D00   LUI V0, -25344
9D00329C  24446230   ADDIU A0, V0, 25136
9D0032A0  0F402DC0   JAL AddDisplayStr
9D0032A4  00000000   NOP
2440:                					INT32UtoHexASCIIstr(OC1CON, szfnDisplayStr);
9D0032A8  3C02BF80   LUI V0, -16512
9D0032AC  8C433000   LW V1, 12288(V0)
9D0032B0  27C20018   ADDIU V0, S8, 24
9D0032B4  00602021   ADDU A0, V1, ZERO
9D0032B8  00402821   ADDU A1, V0, ZERO
9D0032BC  0F402D75   JAL INT32UtoHexASCIIstr
9D0032C0  00000000   NOP
2441:                					AddDisplayStr(szfnDisplayStr);
9D0032C4  27C20018   ADDIU V0, S8, 24
9D0032C8  00402021   ADDU A0, V0, ZERO
9D0032CC  0F402DC0   JAL AddDisplayStr
9D0032D0  00000000   NOP
2442:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0032D4  97828110   LHU V0, -32496(GP)
9D0032D8  24420001   ADDIU V0, V0, 1
9D0032DC  3042FFFF   ANDI V0, V0, -1
9D0032E0  A7828110   SH V0, -32496(GP)
2443:                					break;
9D0032E4  0B400E12   J 0x9D003848
9D0032E8  00000000   NOP
2444:                
2445:                				case 2:
2446:                					AddDisplayStr("\tOC1R OC1 Compare Register:       ");
9D0032EC  3C029D00   LUI V0, -25344
9D0032F0  24446254   ADDIU A0, V0, 25172
9D0032F4  0F402DC0   JAL AddDisplayStr
9D0032F8  00000000   NOP
2447:                					INT32UtoHexASCIIstr(OC1R, szfnDisplayStr);
9D0032FC  3C02BF80   LUI V0, -16512
9D003300  8C433010   LW V1, 12304(V0)
9D003304  27C20018   ADDIU V0, S8, 24
9D003308  00602021   ADDU A0, V1, ZERO
9D00330C  00402821   ADDU A1, V0, ZERO
9D003310  0F402D75   JAL INT32UtoHexASCIIstr
9D003314  00000000   NOP
2448:                					AddDisplayStr(szfnDisplayStr);
9D003318  27C20018   ADDIU V0, S8, 24
9D00331C  00402021   ADDU A0, V0, ZERO
9D003320  0F402DC0   JAL AddDisplayStr
9D003324  00000000   NOP
2449:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003328  97828110   LHU V0, -32496(GP)
9D00332C  24420001   ADDIU V0, V0, 1
9D003330  3042FFFF   ANDI V0, V0, -1
9D003334  A7828110   SH V0, -32496(GP)
2450:                					break;
9D003338  0B400E12   J 0x9D003848
9D00333C  00000000   NOP
2451:                
2452:                				case 3:
2453:                					AddDisplayStr("\tOC1RS OC1 2nd Compare Register:  ");
9D003340  3C029D00   LUI V0, -25344
9D003344  24446278   ADDIU A0, V0, 25208
9D003348  0F402DC0   JAL AddDisplayStr
9D00334C  00000000   NOP
2454:                					INT32UtoHexASCIIstr(OC1RS, szfnDisplayStr);
9D003350  3C02BF80   LUI V0, -16512
9D003354  8C433020   LW V1, 12320(V0)
9D003358  27C20018   ADDIU V0, S8, 24
9D00335C  00602021   ADDU A0, V1, ZERO
9D003360  00402821   ADDU A1, V0, ZERO
9D003364  0F402D75   JAL INT32UtoHexASCIIstr
9D003368  00000000   NOP
2455:                					AddDisplayStr(szfnDisplayStr);
9D00336C  27C20018   ADDIU V0, S8, 24
9D003370  00402021   ADDU A0, V0, ZERO
9D003374  0F402DC0   JAL AddDisplayStr
9D003378  00000000   NOP
2456:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D00337C  97828110   LHU V0, -32496(GP)
9D003380  24420001   ADDIU V0, V0, 1
9D003384  3042FFFF   ANDI V0, V0, -1
9D003388  A7828110   SH V0, -32496(GP)
2457:                					break;
9D00338C  0B400E12   J 0x9D003848
9D003390  00000000   NOP
2458:                
2459:                				case 4:
2460:                					AddDisplayStr("\tOC2CON OC2 Control Register:     ");
9D003394  3C029D00   LUI V0, -25344
9D003398  2444629C   ADDIU A0, V0, 25244
9D00339C  0F402DC0   JAL AddDisplayStr
9D0033A0  00000000   NOP
2461:                					INT32UtoHexASCIIstr(OC2CON, szfnDisplayStr);
9D0033A4  3C02BF80   LUI V0, -16512
9D0033A8  8C433200   LW V1, 12800(V0)
9D0033AC  27C20018   ADDIU V0, S8, 24
9D0033B0  00602021   ADDU A0, V1, ZERO
9D0033B4  00402821   ADDU A1, V0, ZERO
9D0033B8  0F402D75   JAL INT32UtoHexASCIIstr
9D0033BC  00000000   NOP
2462:                					AddDisplayStr(szfnDisplayStr);
9D0033C0  27C20018   ADDIU V0, S8, 24
9D0033C4  00402021   ADDU A0, V0, ZERO
9D0033C8  0F402DC0   JAL AddDisplayStr
9D0033CC  00000000   NOP
2463:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0033D0  97828110   LHU V0, -32496(GP)
9D0033D4  24420001   ADDIU V0, V0, 1
9D0033D8  3042FFFF   ANDI V0, V0, -1
9D0033DC  A7828110   SH V0, -32496(GP)
2464:                					break;
9D0033E0  0B400E12   J 0x9D003848
9D0033E4  00000000   NOP
2465:                
2466:                				case 5:
2467:                					AddDisplayStr("\tOC2R OC2 Compare Register:       ");
9D0033E8  3C029D00   LUI V0, -25344
9D0033EC  244462C0   ADDIU A0, V0, 25280
9D0033F0  0F402DC0   JAL AddDisplayStr
9D0033F4  00000000   NOP
2468:                					INT32UtoHexASCIIstr(OC2R, szfnDisplayStr);
9D0033F8  3C02BF80   LUI V0, -16512
9D0033FC  8C433210   LW V1, 12816(V0)
9D003400  27C20018   ADDIU V0, S8, 24
9D003404  00602021   ADDU A0, V1, ZERO
9D003408  00402821   ADDU A1, V0, ZERO
9D00340C  0F402D75   JAL INT32UtoHexASCIIstr
9D003410  00000000   NOP
2469:                					AddDisplayStr(szfnDisplayStr);
9D003414  27C20018   ADDIU V0, S8, 24
9D003418  00402021   ADDU A0, V0, ZERO
9D00341C  0F402DC0   JAL AddDisplayStr
9D003420  00000000   NOP
2470:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003424  97828110   LHU V0, -32496(GP)
9D003428  24420001   ADDIU V0, V0, 1
9D00342C  3042FFFF   ANDI V0, V0, -1
9D003430  A7828110   SH V0, -32496(GP)
2471:                					break;
9D003434  0B400E12   J 0x9D003848
9D003438  00000000   NOP
2472:                
2473:                				case 6:
2474:                					AddDisplayStr("\tOC2RS OC2 2nd Compare Register:  ");
9D00343C  3C029D00   LUI V0, -25344
9D003440  244462E4   ADDIU A0, V0, 25316
9D003444  0F402DC0   JAL AddDisplayStr
9D003448  00000000   NOP
2475:                					INT32UtoHexASCIIstr(OC2RS, szfnDisplayStr);
9D00344C  3C02BF80   LUI V0, -16512
9D003450  8C433220   LW V1, 12832(V0)
9D003454  27C20018   ADDIU V0, S8, 24
9D003458  00602021   ADDU A0, V1, ZERO
9D00345C  00402821   ADDU A1, V0, ZERO
9D003460  0F402D75   JAL INT32UtoHexASCIIstr
9D003464  00000000   NOP
2476:                					AddDisplayStr(szfnDisplayStr);
9D003468  27C20018   ADDIU V0, S8, 24
9D00346C  00402021   ADDU A0, V0, ZERO
9D003470  0F402DC0   JAL AddDisplayStr
9D003474  00000000   NOP
2477:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003478  97828110   LHU V0, -32496(GP)
9D00347C  24420001   ADDIU V0, V0, 1
9D003480  3042FFFF   ANDI V0, V0, -1
9D003484  A7828110   SH V0, -32496(GP)
2478:                					break;
9D003488  0B400E12   J 0x9D003848
9D00348C  00000000   NOP
2479:                
2480:                				case 7:
2481:                					AddDisplayStr("\tOC3CON OC3 Control Register:     ");
9D003490  3C029D00   LUI V0, -25344
9D003494  24446308   ADDIU A0, V0, 25352
9D003498  0F402DC0   JAL AddDisplayStr
9D00349C  00000000   NOP
2482:                					INT32UtoHexASCIIstr(OC3CON, szfnDisplayStr);
9D0034A0  3C02BF80   LUI V0, -16512
9D0034A4  8C433400   LW V1, 13312(V0)
9D0034A8  27C20018   ADDIU V0, S8, 24
9D0034AC  00602021   ADDU A0, V1, ZERO
9D0034B0  00402821   ADDU A1, V0, ZERO
9D0034B4  0F402D75   JAL INT32UtoHexASCIIstr
9D0034B8  00000000   NOP
2483:                					AddDisplayStr(szfnDisplayStr);
9D0034BC  27C20018   ADDIU V0, S8, 24
9D0034C0  00402021   ADDU A0, V0, ZERO
9D0034C4  0F402DC0   JAL AddDisplayStr
9D0034C8  00000000   NOP
2484:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0034CC  97828110   LHU V0, -32496(GP)
9D0034D0  24420001   ADDIU V0, V0, 1
9D0034D4  3042FFFF   ANDI V0, V0, -1
9D0034D8  A7828110   SH V0, -32496(GP)
2485:                					break;
9D0034DC  0B400E12   J 0x9D003848
9D0034E0  00000000   NOP
2486:                
2487:                				case 8:
2488:                					AddDisplayStr("\tOC3R OC3 Compare Register:       ");
9D0034E4  3C029D00   LUI V0, -25344
9D0034E8  2444632C   ADDIU A0, V0, 25388
9D0034EC  0F402DC0   JAL AddDisplayStr
9D0034F0  00000000   NOP
2489:                					INT32UtoHexASCIIstr(OC3R, szfnDisplayStr);
9D0034F4  3C02BF80   LUI V0, -16512
9D0034F8  8C433410   LW V1, 13328(V0)
9D0034FC  27C20018   ADDIU V0, S8, 24
9D003500  00602021   ADDU A0, V1, ZERO
9D003504  00402821   ADDU A1, V0, ZERO
9D003508  0F402D75   JAL INT32UtoHexASCIIstr
9D00350C  00000000   NOP
2490:                					AddDisplayStr(szfnDisplayStr);
9D003510  27C20018   ADDIU V0, S8, 24
9D003514  00402021   ADDU A0, V0, ZERO
9D003518  0F402DC0   JAL AddDisplayStr
9D00351C  00000000   NOP
2491:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003520  97828110   LHU V0, -32496(GP)
9D003524  24420001   ADDIU V0, V0, 1
9D003528  3042FFFF   ANDI V0, V0, -1
9D00352C  A7828110   SH V0, -32496(GP)
2492:                					break;
9D003530  0B400E12   J 0x9D003848
9D003534  00000000   NOP
2493:                
2494:                				case 9:
2495:                					AddDisplayStr("\tOC3RS OC3 2nd Compare Register:  ");
9D003538  3C029D00   LUI V0, -25344
9D00353C  24446350   ADDIU A0, V0, 25424
9D003540  0F402DC0   JAL AddDisplayStr
9D003544  00000000   NOP
2496:                					INT32UtoHexASCIIstr(OC3RS, szfnDisplayStr);
9D003548  3C02BF80   LUI V0, -16512
9D00354C  8C433420   LW V1, 13344(V0)
9D003550  27C20018   ADDIU V0, S8, 24
9D003554  00602021   ADDU A0, V1, ZERO
9D003558  00402821   ADDU A1, V0, ZERO
9D00355C  0F402D75   JAL INT32UtoHexASCIIstr
9D003560  00000000   NOP
2497:                					AddDisplayStr(szfnDisplayStr);
9D003564  27C20018   ADDIU V0, S8, 24
9D003568  00402021   ADDU A0, V0, ZERO
9D00356C  0F402DC0   JAL AddDisplayStr
9D003570  00000000   NOP
2498:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003574  97828110   LHU V0, -32496(GP)
9D003578  24420001   ADDIU V0, V0, 1
9D00357C  3042FFFF   ANDI V0, V0, -1
9D003580  A7828110   SH V0, -32496(GP)
2499:                					break;
9D003584  0B400E12   J 0x9D003848
9D003588  00000000   NOP
2500:                
2501:                				case 10:
2502:                					AddDisplayStr("\tOC4CON OC4 Control Register:     ");
9D00358C  3C029D00   LUI V0, -25344
9D003590  24446374   ADDIU A0, V0, 25460
9D003594  0F402DC0   JAL AddDisplayStr
9D003598  00000000   NOP
2503:                					INT32UtoHexASCIIstr(OC4CON, szfnDisplayStr);
9D00359C  3C02BF80   LUI V0, -16512
9D0035A0  8C433600   LW V1, 13824(V0)
9D0035A4  27C20018   ADDIU V0, S8, 24
9D0035A8  00602021   ADDU A0, V1, ZERO
9D0035AC  00402821   ADDU A1, V0, ZERO
9D0035B0  0F402D75   JAL INT32UtoHexASCIIstr
9D0035B4  00000000   NOP
2504:                					AddDisplayStr(szfnDisplayStr);
9D0035B8  27C20018   ADDIU V0, S8, 24
9D0035BC  00402021   ADDU A0, V0, ZERO
9D0035C0  0F402DC0   JAL AddDisplayStr
9D0035C4  00000000   NOP
2505:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0035C8  97828110   LHU V0, -32496(GP)
9D0035CC  24420001   ADDIU V0, V0, 1
9D0035D0  3042FFFF   ANDI V0, V0, -1
9D0035D4  A7828110   SH V0, -32496(GP)
2506:                					break;
9D0035D8  0B400E12   J 0x9D003848
9D0035DC  00000000   NOP
2507:                
2508:                				case 11:
2509:                					AddDisplayStr("\tOC4R OC4 Compare Register:       ");
9D0035E0  3C029D00   LUI V0, -25344
9D0035E4  24446398   ADDIU A0, V0, 25496
9D0035E8  0F402DC0   JAL AddDisplayStr
9D0035EC  00000000   NOP
2510:                					INT32UtoHexASCIIstr(OC4R, szfnDisplayStr);
9D0035F0  3C02BF80   LUI V0, -16512
9D0035F4  8C433610   LW V1, 13840(V0)
9D0035F8  27C20018   ADDIU V0, S8, 24
9D0035FC  00602021   ADDU A0, V1, ZERO
9D003600  00402821   ADDU A1, V0, ZERO
9D003604  0F402D75   JAL INT32UtoHexASCIIstr
9D003608  00000000   NOP
2511:                					AddDisplayStr(szfnDisplayStr);
9D00360C  27C20018   ADDIU V0, S8, 24
9D003610  00402021   ADDU A0, V0, ZERO
9D003614  0F402DC0   JAL AddDisplayStr
9D003618  00000000   NOP
2512:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D00361C  97828110   LHU V0, -32496(GP)
9D003620  24420001   ADDIU V0, V0, 1
9D003624  3042FFFF   ANDI V0, V0, -1
9D003628  A7828110   SH V0, -32496(GP)
2513:                					break;
9D00362C  0B400E12   J 0x9D003848
9D003630  00000000   NOP
2514:                
2515:                				case 12:
2516:                					AddDisplayStr("\tOC4RS OC4 2nd Compare Register:  ");
9D003634  3C029D00   LUI V0, -25344
9D003638  244463BC   ADDIU A0, V0, 25532
9D00363C  0F402DC0   JAL AddDisplayStr
9D003640  00000000   NOP
2517:                					INT32UtoHexASCIIstr(OC4RS, szfnDisplayStr);
9D003644  3C02BF80   LUI V0, -16512
9D003648  8C433620   LW V1, 13856(V0)
9D00364C  27C20018   ADDIU V0, S8, 24
9D003650  00602021   ADDU A0, V1, ZERO
9D003654  00402821   ADDU A1, V0, ZERO
9D003658  0F402D75   JAL INT32UtoHexASCIIstr
9D00365C  00000000   NOP
2518:                					AddDisplayStr(szfnDisplayStr);
9D003660  27C20018   ADDIU V0, S8, 24
9D003664  00402021   ADDU A0, V0, ZERO
9D003668  0F402DC0   JAL AddDisplayStr
9D00366C  00000000   NOP
2519:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003670  97828110   LHU V0, -32496(GP)
9D003674  24420001   ADDIU V0, V0, 1
9D003678  3042FFFF   ANDI V0, V0, -1
9D00367C  A7828110   SH V0, -32496(GP)
2520:                					break;
9D003680  0B400E12   J 0x9D003848
9D003684  00000000   NOP
2521:                
2522:                				case 13:
2523:                					AddDisplayNewLine();
9D003688  0F402E24   JAL AddDisplayNewLine
9D00368C  00000000   NOP
2524:                					AddDisplayStr("\tT2CON Timer 2 Control Register:  ");
9D003690  3C029D00   LUI V0, -25344
9D003694  244463E0   ADDIU A0, V0, 25568
9D003698  0F402DC0   JAL AddDisplayStr
9D00369C  00000000   NOP
2525:                					INT32UtoHexASCIIstr(T2CON, szfnDisplayStr);
9D0036A0  3C02BF80   LUI V0, -16512
9D0036A4  8C430800   LW V1, 2048(V0)
9D0036A8  27C20018   ADDIU V0, S8, 24
9D0036AC  00602021   ADDU A0, V1, ZERO
9D0036B0  00402821   ADDU A1, V0, ZERO
9D0036B4  0F402D75   JAL INT32UtoHexASCIIstr
9D0036B8  00000000   NOP
2526:                					AddDisplayStr(szfnDisplayStr);
9D0036BC  27C20018   ADDIU V0, S8, 24
9D0036C0  00402021   ADDU A0, V0, ZERO
9D0036C4  0F402DC0   JAL AddDisplayStr
9D0036C8  00000000   NOP
2527:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0036CC  97828110   LHU V0, -32496(GP)
9D0036D0  24420001   ADDIU V0, V0, 1
9D0036D4  3042FFFF   ANDI V0, V0, -1
9D0036D8  A7828110   SH V0, -32496(GP)
2528:                					break;
9D0036DC  0B400E12   J 0x9D003848
9D0036E0  00000000   NOP
2529:                
2530:                				case 14:
2531:                					AddDisplayStr("\tTMR2 Timer 2 Register:           ");
9D0036E4  3C029D00   LUI V0, -25344
9D0036E8  24446404   ADDIU A0, V0, 25604
9D0036EC  0F402DC0   JAL AddDisplayStr
9D0036F0  00000000   NOP
2532:                					INT32UtoHexASCIIstr(TMR2, szfnDisplayStr);
9D0036F4  3C02BF80   LUI V0, -16512
9D0036F8  8C430810   LW V1, 2064(V0)
9D0036FC  27C20018   ADDIU V0, S8, 24
9D003700  00602021   ADDU A0, V1, ZERO
9D003704  00402821   ADDU A1, V0, ZERO
9D003708  0F402D75   JAL INT32UtoHexASCIIstr
9D00370C  00000000   NOP
2533:                					AddDisplayStr(szfnDisplayStr);
9D003710  27C20018   ADDIU V0, S8, 24
9D003714  00402021   ADDU A0, V0, ZERO
9D003718  0F402DC0   JAL AddDisplayStr
9D00371C  00000000   NOP
2534:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003720  97828110   LHU V0, -32496(GP)
9D003724  24420001   ADDIU V0, V0, 1
9D003728  3042FFFF   ANDI V0, V0, -1
9D00372C  A7828110   SH V0, -32496(GP)
2535:                					break;
9D003730  0B400E12   J 0x9D003848
9D003734  00000000   NOP
2536:                
2537:                				case 15:
2538:                					AddDisplayStr("\tPR2 Period2 Register:            ");
9D003738  3C029D00   LUI V0, -25344
9D00373C  24446428   ADDIU A0, V0, 25640
9D003740  0F402DC0   JAL AddDisplayStr
9D003744  00000000   NOP
2539:                					INT32UtoHexASCIIstr(PR2, szfnDisplayStr);
9D003748  3C02BF80   LUI V0, -16512
9D00374C  8C430820   LW V1, 2080(V0)
9D003750  27C20018   ADDIU V0, S8, 24
9D003754  00602021   ADDU A0, V1, ZERO
9D003758  00402821   ADDU A1, V0, ZERO
9D00375C  0F402D75   JAL INT32UtoHexASCIIstr
9D003760  00000000   NOP
2540:                					AddDisplayStr(szfnDisplayStr);
9D003764  27C20018   ADDIU V0, S8, 24
9D003768  00402021   ADDU A0, V0, ZERO
9D00376C  0F402DC0   JAL AddDisplayStr
9D003770  00000000   NOP
2541:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003774  97828110   LHU V0, -32496(GP)
9D003778  24420001   ADDIU V0, V0, 1
9D00377C  3042FFFF   ANDI V0, V0, -1
9D003780  A7828110   SH V0, -32496(GP)
2542:                					break;
9D003784  0B400E12   J 0x9D003848
9D003788  00000000   NOP
2543:                
2544:                				case 16:
2545:                					AddDisplayNewLine();
9D00378C  0F402E24   JAL AddDisplayNewLine
9D003790  00000000   NOP
2546:                					AddDisplayStr("\tPWM frequency:           ");
9D003794  3C029D00   LUI V0, -25344
9D003798  2444644C   ADDIU A0, V0, 25676
9D00379C  0F402DC0   JAL AddDisplayStr
9D0037A0  00000000   NOP
2547:                					INT32UtoASCIIstr((INT32U)(GetPeripheralClock() / PR2), WORD_WIDTH, szfnDisplayStr);
9D0037A4  3C02BF81   LUI V0, -16511
9D0037A8  8C42F000   LW V0, -4096(V0)
9D0037AC  7C420CC0   EXT V0, V0, 19, 2
9D0037B0  304200FF   ANDI V0, V0, 255
9D0037B4  3C0304C4   LUI V1, 1220
9D0037B8  3463B400   ORI V1, V1, -19456
9D0037BC  00431806   SRLV V1, V1, V0
9D0037C0  3C02BF80   LUI V0, -16512
9D0037C4  8C420820   LW V0, 2080(V0)
9D0037C8  0062001B   DIVU V1, V0
9D0037CC  004001F4   TEQ V0, ZERO
9D0037D0  00001810   MFHI V1
9D0037D4  00001012   MFLO V0
9D0037D8  00401821   ADDU V1, V0, ZERO
9D0037DC  27C20018   ADDIU V0, S8, 24
9D0037E0  00602021   ADDU A0, V1, ZERO
9D0037E4  24050005   ADDIU A1, ZERO, 5
9D0037E8  00403021   ADDU A2, V0, ZERO
9D0037EC  0F402D22   JAL INT32UtoASCIIstr
9D0037F0  00000000   NOP
2548:                					AddDisplayStr(szfnDisplayStr);
9D0037F4  27C20018   ADDIU V0, S8, 24
9D0037F8  00402021   ADDU A0, V0, ZERO
9D0037FC  0F402DC0   JAL AddDisplayStr
9D003800  00000000   NOP
2549:                					AddDisplayStr("Hz");
9D003804  3C029D00   LUI V0, -25344
9D003808  24446204   ADDIU A0, V0, 25092
9D00380C  0F402DC0   JAL AddDisplayStr
9D003810  00000000   NOP
2550:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003814  97828110   LHU V0, -32496(GP)
9D003818  24420001   ADDIU V0, V0, 1
9D00381C  3042FFFF   ANDI V0, V0, -1
9D003820  A7828110   SH V0, -32496(GP)
2551:                					bRetVal = FALSE;															// nothing to display
9D003824  AFC00010   SW ZERO, 16(S8)
2552:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
9D003828  24020002   ADDIU V0, ZERO, 2
9D00382C  AF828048   SW V0, -32696(GP)
2553:                					break;
9D003830  0B400E12   J 0x9D003848
9D003834  00000000   NOP
2554:                
2555:                				default:
2556:                					bRetVal = FALSE;															// nothing to display
9D003838  AFC00010   SW ZERO, 16(S8)
2557:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D00383C  24020002   ADDIU V0, ZERO, 2
9D003840  AF828048   SW V0, -32696(GP)
2558:                					break;
9D003844  00000000   NOP
2559:                
2560:                				}
2561:                			}
2562:                			break;
9D003848  0B401099   J 0x9D004264
9D00384C  00000000   NOP
2563:                
2564:                		case RESULT_MOTOR_PWM_WIDTHS:
2565:                			{
2566:                			switch(fgwDisplayLineCtr)
9D003850  97828110   LHU V0, -32496(GP)
9D003854  2C430005   SLTIU V1, V0, 5
9D003858  106000CE   BEQ V1, ZERO, 0x9D003B94
9D00385C  00000000   NOP
9D003860  00021880   SLL V1, V0, 2
9D003864  3C029D00   LUI V0, -25344
9D003868  2442387C   ADDIU V0, V0, 14460
9D00386C  00621021   ADDU V0, V1, V0
9D003870  8C420000   LW V0, 0(V0)
9D003874  00400008   JR V0
9D003878  00000000   NOP
2567:                				{
2568:                				case 0:
2569:                					AddDisplayStr("\tCurrent PWM1 Duty Cycle: ");
9D003890  3C029D00   LUI V0, -25344
9D003894  24446468   ADDIU A0, V0, 25704
9D003898  0F402DC0   JAL AddDisplayStr
9D00389C  00000000   NOP
2570:                					lDutyCycle = (INT32U)OC1R / (INT32U)(PR2/100);
9D0038A0  3C02BF80   LUI V0, -16512
9D0038A4  8C443010   LW A0, 12304(V0)
9D0038A8  3C02BF80   LUI V0, -16512
9D0038AC  8C430820   LW V1, 2080(V0)
9D0038B0  3C0251EB   LUI V0, 20971
9D0038B4  3442851F   ORI V0, V0, -31457
9D0038B8  00620019   MULTU V1, V0
9D0038BC  00001012   MFLO V0
9D0038C0  00001810   MFHI V1
9D0038C4  00031142   SRL V0, V1, 5
9D0038C8  0082001B   DIVU A0, V0
9D0038CC  004001F4   TEQ V0, ZERO
9D0038D0  00001810   MFHI V1
9D0038D4  00001012   MFLO V0
9D0038D8  AFC20014   SW V0, 20(S8)
2571:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D0038DC  8FC20014   LW V0, 20(S8)
9D0038E0  3042FFFF   ANDI V0, V0, -1
9D0038E4  00401821   ADDU V1, V0, ZERO
9D0038E8  27C20018   ADDIU V0, S8, 24
9D0038EC  00602021   ADDU A0, V1, ZERO
9D0038F0  24050003   ADDIU A1, ZERO, 3
9D0038F4  00403021   ADDU A2, V0, ZERO
9D0038F8  0F402C67   JAL WORDtoASCIIstr
9D0038FC  00000000   NOP
2572:                					AddDisplayStr(szfnDisplayStr);
9D003900  27C20018   ADDIU V0, S8, 24
9D003904  00402021   ADDU A0, V0, ZERO
9D003908  0F402DC0   JAL AddDisplayStr
9D00390C  00000000   NOP
2573:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003910  97828110   LHU V0, -32496(GP)
9D003914  24420001   ADDIU V0, V0, 1
9D003918  3042FFFF   ANDI V0, V0, -1
9D00391C  A7828110   SH V0, -32496(GP)
2574:                					break;
9D003920  0B400EE9   J 0x9D003BA4
9D003924  00000000   NOP
2575:                
2576:                				case 1:
2577:                					AddDisplayStr("\tCurrent PWM2 Duty Cycle: ");
9D003928  3C029D00   LUI V0, -25344
9D00392C  24446484   ADDIU A0, V0, 25732
9D003930  0F402DC0   JAL AddDisplayStr
9D003934  00000000   NOP
2578:                					lDutyCycle = (INT32U)OC2R / (INT32U)(PR2/100);
9D003938  3C02BF80   LUI V0, -16512
9D00393C  8C443210   LW A0, 12816(V0)
9D003940  3C02BF80   LUI V0, -16512
9D003944  8C430820   LW V1, 2080(V0)
9D003948  3C0251EB   LUI V0, 20971
9D00394C  3442851F   ORI V0, V0, -31457
9D003950  00620019   MULTU V1, V0
9D003954  00001012   MFLO V0
9D003958  00001810   MFHI V1
9D00395C  00031142   SRL V0, V1, 5
9D003960  0082001B   DIVU A0, V0
9D003964  004001F4   TEQ V0, ZERO
9D003968  00001810   MFHI V1
9D00396C  00001012   MFLO V0
9D003970  AFC20014   SW V0, 20(S8)
2579:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D003974  8FC20014   LW V0, 20(S8)
9D003978  3042FFFF   ANDI V0, V0, -1
9D00397C  00401821   ADDU V1, V0, ZERO
9D003980  27C20018   ADDIU V0, S8, 24
9D003984  00602021   ADDU A0, V1, ZERO
9D003988  24050003   ADDIU A1, ZERO, 3
9D00398C  00403021   ADDU A2, V0, ZERO
9D003990  0F402C67   JAL WORDtoASCIIstr
9D003994  00000000   NOP
2580:                					AddDisplayStr(szfnDisplayStr);
9D003998  27C20018   ADDIU V0, S8, 24
9D00399C  00402021   ADDU A0, V0, ZERO
9D0039A0  0F402DC0   JAL AddDisplayStr
9D0039A4  00000000   NOP
2581:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0039A8  97828110   LHU V0, -32496(GP)
9D0039AC  24420001   ADDIU V0, V0, 1
9D0039B0  3042FFFF   ANDI V0, V0, -1
9D0039B4  A7828110   SH V0, -32496(GP)
2582:                					break;
9D0039B8  0B400EE9   J 0x9D003BA4
9D0039BC  00000000   NOP
2583:                
2584:                				case 2:
2585:                					AddDisplayStr("\tCurrent PWM3 Duty Cycle: ");
9D0039C0  3C029D00   LUI V0, -25344
9D0039C4  244464A0   ADDIU A0, V0, 25760
9D0039C8  0F402DC0   JAL AddDisplayStr
9D0039CC  00000000   NOP
2586:                					lDutyCycle = (INT32U)OC3R / (INT32U)(PR2/100);
9D0039D0  3C02BF80   LUI V0, -16512
9D0039D4  8C443410   LW A0, 13328(V0)
9D0039D8  3C02BF80   LUI V0, -16512
9D0039DC  8C430820   LW V1, 2080(V0)
9D0039E0  3C0251EB   LUI V0, 20971
9D0039E4  3442851F   ORI V0, V0, -31457
9D0039E8  00620019   MULTU V1, V0
9D0039EC  00001012   MFLO V0
9D0039F0  00001810   MFHI V1
9D0039F4  00031142   SRL V0, V1, 5
9D0039F8  0082001B   DIVU A0, V0
9D0039FC  004001F4   TEQ V0, ZERO
9D003A00  00001810   MFHI V1
9D003A04  00001012   MFLO V0
9D003A08  AFC20014   SW V0, 20(S8)
2587:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D003A0C  8FC20014   LW V0, 20(S8)
9D003A10  3042FFFF   ANDI V0, V0, -1
9D003A14  00401821   ADDU V1, V0, ZERO
9D003A18  27C20018   ADDIU V0, S8, 24
9D003A1C  00602021   ADDU A0, V1, ZERO
9D003A20  24050003   ADDIU A1, ZERO, 3
9D003A24  00403021   ADDU A2, V0, ZERO
9D003A28  0F402C67   JAL WORDtoASCIIstr
9D003A2C  00000000   NOP
2588:                					AddDisplayStr(szfnDisplayStr);
9D003A30  27C20018   ADDIU V0, S8, 24
9D003A34  00402021   ADDU A0, V0, ZERO
9D003A38  0F402DC0   JAL AddDisplayStr
9D003A3C  00000000   NOP
2589:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003A40  97828110   LHU V0, -32496(GP)
9D003A44  24420001   ADDIU V0, V0, 1
9D003A48  3042FFFF   ANDI V0, V0, -1
9D003A4C  A7828110   SH V0, -32496(GP)
2590:                					break;
9D003A50  0B400EE9   J 0x9D003BA4
9D003A54  00000000   NOP
2591:                
2592:                				case 3:
2593:                					AddDisplayStr("\tCurrent PWM4 Duty Cycle: ");
9D003A58  3C029D00   LUI V0, -25344
9D003A5C  244464BC   ADDIU A0, V0, 25788
9D003A60  0F402DC0   JAL AddDisplayStr
9D003A64  00000000   NOP
2594:                					lDutyCycle = (INT32U)OC4R / (INT32U)(PR2/100);
9D003A68  3C02BF80   LUI V0, -16512
9D003A6C  8C443610   LW A0, 13840(V0)
9D003A70  3C02BF80   LUI V0, -16512
9D003A74  8C430820   LW V1, 2080(V0)
9D003A78  3C0251EB   LUI V0, 20971
9D003A7C  3442851F   ORI V0, V0, -31457
9D003A80  00620019   MULTU V1, V0
9D003A84  00001012   MFLO V0
9D003A88  00001810   MFHI V1
9D003A8C  00031142   SRL V0, V1, 5
9D003A90  0082001B   DIVU A0, V0
9D003A94  004001F4   TEQ V0, ZERO
9D003A98  00001810   MFHI V1
9D003A9C  00001012   MFLO V0
9D003AA0  AFC20014   SW V0, 20(S8)
2595:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D003AA4  8FC20014   LW V0, 20(S8)
9D003AA8  3042FFFF   ANDI V0, V0, -1
9D003AAC  00401821   ADDU V1, V0, ZERO
9D003AB0  27C20018   ADDIU V0, S8, 24
9D003AB4  00602021   ADDU A0, V1, ZERO
9D003AB8  24050003   ADDIU A1, ZERO, 3
9D003ABC  00403021   ADDU A2, V0, ZERO
9D003AC0  0F402C67   JAL WORDtoASCIIstr
9D003AC4  00000000   NOP
2596:                					AddDisplayStr(szfnDisplayStr);
9D003AC8  27C20018   ADDIU V0, S8, 24
9D003ACC  00402021   ADDU A0, V0, ZERO
9D003AD0  0F402DC0   JAL AddDisplayStr
9D003AD4  00000000   NOP
2597:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003AD8  97828110   LHU V0, -32496(GP)
9D003ADC  24420001   ADDIU V0, V0, 1
9D003AE0  3042FFFF   ANDI V0, V0, -1
9D003AE4  A7828110   SH V0, -32496(GP)
2598:                					break;
9D003AE8  0B400EE9   J 0x9D003BA4
9D003AEC  00000000   NOP
2599:                
2600:                				case 4:
2601:                					AddDisplayStr("\tPWM frequency:           ");
9D003AF0  3C029D00   LUI V0, -25344
9D003AF4  2444644C   ADDIU A0, V0, 25676
9D003AF8  0F402DC0   JAL AddDisplayStr
9D003AFC  00000000   NOP
2602:                					INT32UtoASCIIstr((INT32U)(GetPeripheralClock() / PR2), WORD_WIDTH, szfnDisplayStr);
9D003B00  3C02BF81   LUI V0, -16511
9D003B04  8C42F000   LW V0, -4096(V0)
9D003B08  7C420CC0   EXT V0, V0, 19, 2
9D003B0C  304200FF   ANDI V0, V0, 255
9D003B10  3C0304C4   LUI V1, 1220
9D003B14  3463B400   ORI V1, V1, -19456
9D003B18  00431806   SRLV V1, V1, V0
9D003B1C  3C02BF80   LUI V0, -16512
9D003B20  8C420820   LW V0, 2080(V0)
9D003B24  0062001B   DIVU V1, V0
9D003B28  004001F4   TEQ V0, ZERO
9D003B2C  00001810   MFHI V1
9D003B30  00001012   MFLO V0
9D003B34  00401821   ADDU V1, V0, ZERO
9D003B38  27C20018   ADDIU V0, S8, 24
9D003B3C  00602021   ADDU A0, V1, ZERO
9D003B40  24050005   ADDIU A1, ZERO, 5
9D003B44  00403021   ADDU A2, V0, ZERO
9D003B48  0F402D22   JAL INT32UtoASCIIstr
9D003B4C  00000000   NOP
2603:                					AddDisplayStr(szfnDisplayStr);
9D003B50  27C20018   ADDIU V0, S8, 24
9D003B54  00402021   ADDU A0, V0, ZERO
9D003B58  0F402DC0   JAL AddDisplayStr
9D003B5C  00000000   NOP
2604:                					AddDisplayStr("Hz");
9D003B60  3C029D00   LUI V0, -25344
9D003B64  24446204   ADDIU A0, V0, 25092
9D003B68  0F402DC0   JAL AddDisplayStr
9D003B6C  00000000   NOP
2605:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003B70  97828110   LHU V0, -32496(GP)
9D003B74  24420001   ADDIU V0, V0, 1
9D003B78  3042FFFF   ANDI V0, V0, -1
9D003B7C  A7828110   SH V0, -32496(GP)
2606:                					bRetVal = FALSE;															// nothing to display
9D003B80  AFC00010   SW ZERO, 16(S8)
2607:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
9D003B84  24020002   ADDIU V0, ZERO, 2
9D003B88  AF828048   SW V0, -32696(GP)
2608:                					break;
9D003B8C  0B400EE9   J 0x9D003BA4
9D003B90  00000000   NOP
2609:                
2610:                				default:
2611:                					bRetVal = FALSE;															// nothing to display
9D003B94  AFC00010   SW ZERO, 16(S8)
2612:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D003B98  24020002   ADDIU V0, ZERO, 2
9D003B9C  AF828048   SW V0, -32696(GP)
2613:                					break;
9D003BA0  00000000   NOP
2614:                				}
2615:                			}
2616:                			break;
9D003BA4  0B401099   J 0x9D004264
9D003BA8  00000000   NOP
2617:                
2618:                		// is there a way to read the configuration bits registers?
2619:                		// actual physical address is 0xf80004 in PROGRAM SPACE (determined from MPLAP map file)
2620:                		// AddDisplayStr("\tFBORPOR: BOR AND POR Device Configuration Register: ");
2621:                		// WORDtoHexASCIIstr(FBORPOR, szfnDisplayStr);
2622:                		// AddDisplayStr(szfnDisplayStr);
2623:                
2624:                		case RESULT_READ_INPUTS_MOTION_SENSORS:
2625:                			{
2626:                			// this directly reads the register values
2627:                			switch(fgwDisplayLineCtr)
9D003BAC  97828110   LHU V0, -32496(GP)
9D003BB0  24030001   ADDIU V1, ZERO, 1
9D003BB4  10430012   BEQ V0, V1, 0x9D003C00
9D003BB8  00000000   NOP
9D003BBC  24030002   ADDIU V1, ZERO, 2
9D003BC0  10430021   BEQ V0, V1, 0x9D003C48
9D003BC4  00000000   NOP
9D003BC8  14400046   BNE V0, ZERO, 0x9D003CE4
9D003BCC  00000000   NOP
2628:                				{
2629:                				case 0:
2630:                					AddDisplayNewLine();
9D003BD0  0F402E24   JAL AddDisplayNewLine
9D003BD4  00000000   NOP
2631:                					AddDisplayStrAndNewLine("  Motion (Hall) Sensor Tracking Values");
9D003BD8  3C029D00   LUI V0, -25344
9D003BDC  244464D8   ADDIU A0, V0, 25816
9D003BE0  0F402DDD   JAL AddDisplayStrAndNewLine
9D003BE4  00000000   NOP
2632:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003BE8  97828110   LHU V0, -32496(GP)
9D003BEC  24420001   ADDIU V0, V0, 1
9D003BF0  3042FFFF   ANDI V0, V0, -1
9D003BF4  A7828110   SH V0, -32496(GP)
2633:                					break;
9D003BF8  0B400F3D   J 0x9D003CF4
9D003BFC  00000000   NOP
2634:                
2635:                				case 1:
2636:                					AddDisplayStrAndNewLine("\tOrientation: ");
9D003C00  3C029D00   LUI V0, -25344
9D003C04  24445DD4   ADDIU A0, V0, 24020
9D003C08  0F402DDD   JAL AddDisplayStrAndNewLine
9D003C0C  00000000   NOP
2637:                					CurrentOrientation_Format(szfnDisplayStr);
9D003C10  27C20018   ADDIU V0, S8, 24
9D003C14  00402021   ADDU A0, V0, ZERO
9D003C18  0F4034C2   JAL CurrentOrientation_Format
9D003C1C  00000000   NOP
2638:                					AddDisplayStr(szfnDisplayStr);
9D003C20  27C20018   ADDIU V0, S8, 24
9D003C24  00402021   ADDU A0, V0, ZERO
9D003C28  0F402DC0   JAL AddDisplayStr
9D003C2C  00000000   NOP
2639:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003C30  97828110   LHU V0, -32496(GP)
9D003C34  24420001   ADDIU V0, V0, 1
9D003C38  3042FFFF   ANDI V0, V0, -1
9D003C3C  A7828110   SH V0, -32496(GP)
2640:                					break;
9D003C40  0B400F3D   J 0x9D003CF4
9D003C44  00000000   NOP
2641:                
2642:                				case 2:
2643:                					AddDisplayStr("\tTotal Counts: Az ");
9D003C48  3C029D00   LUI V0, -25344
9D003C4C  24446500   ADDIU A0, V0, 25856
9D003C50  0F402DC0   JAL AddDisplayStr
9D003C54  00000000   NOP
2644:                					WORDtoASCIIstr(pgwMoveTotalMSICtr[AXIS_AZIMUTH], WORD_WIDTH, szfnDisplayStr);
9D003C58  3C02A000   LUI V0, -24576
9D003C5C  944202B8   LHU V0, 696(V0)
9D003C60  00401821   ADDU V1, V0, ZERO
9D003C64  27C20018   ADDIU V0, S8, 24
9D003C68  00602021   ADDU A0, V1, ZERO
9D003C6C  24050005   ADDIU A1, ZERO, 5
9D003C70  00403021   ADDU A2, V0, ZERO
9D003C74  0F402C67   JAL WORDtoASCIIstr
9D003C78  00000000   NOP
2645:                					AddDisplayStr(szfnDisplayStr);
9D003C7C  27C20018   ADDIU V0, S8, 24
9D003C80  00402021   ADDU A0, V0, ZERO
9D003C84  0F402DC0   JAL AddDisplayStr
9D003C88  00000000   NOP
2646:                					AddDisplayStr("  El ");
9D003C8C  3C029D00   LUI V0, -25344
9D003C90  24446514   ADDIU A0, V0, 25876
9D003C94  0F402DC0   JAL AddDisplayStr
9D003C98  00000000   NOP
2647:                					WORDtoASCIIstr(pgwMoveTotalMSICtr[AXIS_ELEVATION], WORD_WIDTH, szfnDisplayStr);
9D003C9C  3C02A000   LUI V0, -24576
9D003CA0  244202B8   ADDIU V0, V0, 696
9D003CA4  94420002   LHU V0, 2(V0)
9D003CA8  00401821   ADDU V1, V0, ZERO
9D003CAC  27C20018   ADDIU V0, S8, 24
9D003CB0  00602021   ADDU A0, V1, ZERO
9D003CB4  24050005   ADDIU A1, ZERO, 5
9D003CB8  00403021   ADDU A2, V0, ZERO
9D003CBC  0F402C67   JAL WORDtoASCIIstr
9D003CC0  00000000   NOP
2648:                					AddDisplayStr(szfnDisplayStr);
9D003CC4  27C20018   ADDIU V0, S8, 24
9D003CC8  00402021   ADDU A0, V0, ZERO
9D003CCC  0F402DC0   JAL AddDisplayStr
9D003CD0  00000000   NOP
2649:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
9D003CD4  24020002   ADDIU V0, ZERO, 2
9D003CD8  AF828048   SW V0, -32696(GP)
2650:                					break;
9D003CDC  0B400F3D   J 0x9D003CF4
9D003CE0  00000000   NOP
2651:                
2652:                				default:
2653:                					bRetVal = FALSE;															// nothing to display
9D003CE4  AFC00010   SW ZERO, 16(S8)
2654:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D003CE8  24020002   ADDIU V0, ZERO, 2
9D003CEC  AF828048   SW V0, -32696(GP)
2655:                					break;
9D003CF0  00000000   NOP
2656:                				}
2657:                			}
2658:                			break;
9D003CF4  0B401099   J 0x9D004264
9D003CF8  00000000   NOP
2659:                
2660:                		case RESULT_READ_REGISTERS_TIMERS:
2661:                			{
2662:                			// the timers are read through the Microchip I/O library, NOT neccesarily directly from the hardware
2663:                			switch(fgwDisplayLineCtr)
9D003CFC  97828110   LHU V0, -32496(GP)
9D003D00  2C43000B   SLTIU V1, V0, 11
9D003D04  106000FD   BEQ V1, ZERO, 0x9D0040FC
9D003D08  00000000   NOP
9D003D0C  00021880   SLL V1, V0, 2
9D003D10  3C029D00   LUI V0, -25344
9D003D14  24423D28   ADDIU V0, V0, 15656
9D003D18  00621021   ADDU V0, V1, V0
9D003D1C  8C420000   LW V0, 0(V0)
9D003D20  00400008   JR V0
9D003D24  00000000   NOP
2664:                				{
2665:                				case 0:
2666:                					AddDisplayNewLine();
9D003D54  0F402E24   JAL AddDisplayNewLine
9D003D58  00000000   NOP
2667:                					AddDisplayStr("  Timer Register Values");
9D003D5C  3C029D00   LUI V0, -25344
9D003D60  2444651C   ADDIU A0, V0, 25884
9D003D64  0F402DC0   JAL AddDisplayStr
9D003D68  00000000   NOP
2668:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003D6C  97828110   LHU V0, -32496(GP)
9D003D70  24420001   ADDIU V0, V0, 1
9D003D74  3042FFFF   ANDI V0, V0, -1
9D003D78  A7828110   SH V0, -32496(GP)
2669:                					break;
9D003D7C  0B401043   J 0x9D00410C
9D003D80  00000000   NOP
2670:                
2671:                				case 1:
2672:                					AddDisplayStr("\tCore Timer(Scheduler 5mS Tick Timing): \t");
9D003D84  3C029D00   LUI V0, -25344
9D003D88  24446534   ADDIU A0, V0, 25908
9D003D8C  0F402DC0   JAL AddDisplayStr
9D003D90  00000000   NOP
2673:                					WORDtoASCIIstr(ReadCoreTimer(), WORD_WIDTH, szfnDisplayStr);
9D003D94  0F403A35   JAL ReadCoreTimer
9D003D98  00000000   NOP
9D003D9C  3042FFFF   ANDI V0, V0, -1
9D003DA0  00401821   ADDU V1, V0, ZERO
9D003DA4  27C20018   ADDIU V0, S8, 24
9D003DA8  00602021   ADDU A0, V1, ZERO
9D003DAC  24050005   ADDIU A1, ZERO, 5
9D003DB0  00403021   ADDU A2, V0, ZERO
9D003DB4  0F402C67   JAL WORDtoASCIIstr
9D003DB8  00000000   NOP
2674:                					AddDisplayStr(szfnDisplayStr);
9D003DBC  27C20018   ADDIU V0, S8, 24
9D003DC0  00402021   ADDU A0, V0, ZERO
9D003DC4  0F402DC0   JAL AddDisplayStr
9D003DC8  00000000   NOP
2675:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003DCC  97828110   LHU V0, -32496(GP)
9D003DD0  24420001   ADDIU V0, V0, 1
9D003DD4  3042FFFF   ANDI V0, V0, -1
9D003DD8  A7828110   SH V0, -32496(GP)
2676:                					break;
9D003DDC  0B401043   J 0x9D00410C
9D003DE0  00000000   NOP
2677:                
2678:                				case 2:
2679:                					AddDisplayNewLine();
9D003DE4  0F402E24   JAL AddDisplayNewLine
9D003DE8  00000000   NOP
2680:                					AddDisplayStr("\tT1CON Timer 1 Control Register:  ");
9D003DEC  3C029D00   LUI V0, -25344
9D003DF0  24446560   ADDIU A0, V0, 25952
9D003DF4  0F402DC0   JAL AddDisplayStr
9D003DF8  00000000   NOP
2681:                					INT32UtoHexASCIIstr(T1CON, szfnDisplayStr);
9D003DFC  3C02BF80   LUI V0, -16512
9D003E00  8C430600   LW V1, 1536(V0)
9D003E04  27C20018   ADDIU V0, S8, 24
9D003E08  00602021   ADDU A0, V1, ZERO
9D003E0C  00402821   ADDU A1, V0, ZERO
9D003E10  0F402D75   JAL INT32UtoHexASCIIstr
9D003E14  00000000   NOP
2682:                					AddDisplayStr(szfnDisplayStr);
9D003E18  27C20018   ADDIU V0, S8, 24
9D003E1C  00402021   ADDU A0, V0, ZERO
9D003E20  0F402DC0   JAL AddDisplayStr
9D003E24  00000000   NOP
2683:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003E28  97828110   LHU V0, -32496(GP)
9D003E2C  24420001   ADDIU V0, V0, 1
9D003E30  3042FFFF   ANDI V0, V0, -1
9D003E34  A7828110   SH V0, -32496(GP)
2684:                					break;
9D003E38  0B401043   J 0x9D00410C
9D003E3C  00000000   NOP
2685:                
2686:                				case 3:
2687:                					AddDisplayStr("\tTMR1 Timer 1 Register:           ");
9D003E40  3C029D00   LUI V0, -25344
9D003E44  24446584   ADDIU A0, V0, 25988
9D003E48  0F402DC0   JAL AddDisplayStr
9D003E4C  00000000   NOP
2688:                					INT32UtoHexASCIIstr(TMR1, szfnDisplayStr);
9D003E50  3C02BF80   LUI V0, -16512
9D003E54  8C430610   LW V1, 1552(V0)
9D003E58  27C20018   ADDIU V0, S8, 24
9D003E5C  00602021   ADDU A0, V1, ZERO
9D003E60  00402821   ADDU A1, V0, ZERO
9D003E64  0F402D75   JAL INT32UtoHexASCIIstr
9D003E68  00000000   NOP
2689:                					AddDisplayStr(szfnDisplayStr);
9D003E6C  27C20018   ADDIU V0, S8, 24
9D003E70  00402021   ADDU A0, V0, ZERO
9D003E74  0F402DC0   JAL AddDisplayStr
9D003E78  00000000   NOP
2690:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003E7C  97828110   LHU V0, -32496(GP)
9D003E80  24420001   ADDIU V0, V0, 1
9D003E84  3042FFFF   ANDI V0, V0, -1
9D003E88  A7828110   SH V0, -32496(GP)
2691:                					break;
9D003E8C  0B401043   J 0x9D00410C
9D003E90  00000000   NOP
2692:                
2693:                				case 4:
2694:                					AddDisplayStr("\tPR1 Period1 Register:            ");
9D003E94  3C029D00   LUI V0, -25344
9D003E98  244465A8   ADDIU A0, V0, 26024
9D003E9C  0F402DC0   JAL AddDisplayStr
9D003EA0  00000000   NOP
2695:                					INT32UtoHexASCIIstr(PR1, szfnDisplayStr);
9D003EA4  3C02BF80   LUI V0, -16512
9D003EA8  8C430620   LW V1, 1568(V0)
9D003EAC  27C20018   ADDIU V0, S8, 24
9D003EB0  00602021   ADDU A0, V1, ZERO
9D003EB4  00402821   ADDU A1, V0, ZERO
9D003EB8  0F402D75   JAL INT32UtoHexASCIIstr
9D003EBC  00000000   NOP
2696:                					AddDisplayStr(szfnDisplayStr);
9D003EC0  27C20018   ADDIU V0, S8, 24
9D003EC4  00402021   ADDU A0, V0, ZERO
9D003EC8  0F402DC0   JAL AddDisplayStr
9D003ECC  00000000   NOP
2697:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003ED0  97828110   LHU V0, -32496(GP)
9D003ED4  24420001   ADDIU V0, V0, 1
9D003ED8  3042FFFF   ANDI V0, V0, -1
9D003EDC  A7828110   SH V0, -32496(GP)
2698:                					break;
9D003EE0  0B401043   J 0x9D00410C
9D003EE4  00000000   NOP
2699:                
2700:                				case 5:
2701:                					AddDisplayNewLine();
9D003EE8  0F402E24   JAL AddDisplayNewLine
9D003EEC  00000000   NOP
2702:                					AddDisplayStr("\tT2CON Timer 2 Control Register:  ");
9D003EF0  3C029D00   LUI V0, -25344
9D003EF4  244463E0   ADDIU A0, V0, 25568
9D003EF8  0F402DC0   JAL AddDisplayStr
9D003EFC  00000000   NOP
2703:                					INT32UtoHexASCIIstr(T2CON, szfnDisplayStr);
9D003F00  3C02BF80   LUI V0, -16512
9D003F04  8C430800   LW V1, 2048(V0)
9D003F08  27C20018   ADDIU V0, S8, 24
9D003F0C  00602021   ADDU A0, V1, ZERO
9D003F10  00402821   ADDU A1, V0, ZERO
9D003F14  0F402D75   JAL INT32UtoHexASCIIstr
9D003F18  00000000   NOP
2704:                					AddDisplayStr(szfnDisplayStr);
9D003F1C  27C20018   ADDIU V0, S8, 24
9D003F20  00402021   ADDU A0, V0, ZERO
9D003F24  0F402DC0   JAL AddDisplayStr
9D003F28  00000000   NOP
2705:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003F2C  97828110   LHU V0, -32496(GP)
9D003F30  24420001   ADDIU V0, V0, 1
9D003F34  3042FFFF   ANDI V0, V0, -1
9D003F38  A7828110   SH V0, -32496(GP)
2706:                					break;
9D003F3C  0B401043   J 0x9D00410C
9D003F40  00000000   NOP
2707:                
2708:                				case 6:
2709:                					AddDisplayStr("\tTMR2 Timer 2 Register:           ");
9D003F44  3C029D00   LUI V0, -25344
9D003F48  24446404   ADDIU A0, V0, 25604
9D003F4C  0F402DC0   JAL AddDisplayStr
9D003F50  00000000   NOP
2710:                					INT32UtoHexASCIIstr(TMR2, szfnDisplayStr);
9D003F54  3C02BF80   LUI V0, -16512
9D003F58  8C430810   LW V1, 2064(V0)
9D003F5C  27C20018   ADDIU V0, S8, 24
9D003F60  00602021   ADDU A0, V1, ZERO
9D003F64  00402821   ADDU A1, V0, ZERO
9D003F68  0F402D75   JAL INT32UtoHexASCIIstr
9D003F6C  00000000   NOP
2711:                					AddDisplayStr(szfnDisplayStr);
9D003F70  27C20018   ADDIU V0, S8, 24
9D003F74  00402021   ADDU A0, V0, ZERO
9D003F78  0F402DC0   JAL AddDisplayStr
9D003F7C  00000000   NOP
2712:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003F80  97828110   LHU V0, -32496(GP)
9D003F84  24420001   ADDIU V0, V0, 1
9D003F88  3042FFFF   ANDI V0, V0, -1
9D003F8C  A7828110   SH V0, -32496(GP)
2713:                					break;
9D003F90  0B401043   J 0x9D00410C
9D003F94  00000000   NOP
2714:                
2715:                				case 7:
2716:                					AddDisplayStr("\tPR2 Period2 Register (PWM):      ");
9D003F98  3C029D00   LUI V0, -25344
9D003F9C  244465CC   ADDIU A0, V0, 26060
9D003FA0  0F402DC0   JAL AddDisplayStr
9D003FA4  00000000   NOP
2717:                					INT32UtoHexASCIIstr(PR2, szfnDisplayStr);
9D003FA8  3C02BF80   LUI V0, -16512
9D003FAC  8C430820   LW V1, 2080(V0)
9D003FB0  27C20018   ADDIU V0, S8, 24
9D003FB4  00602021   ADDU A0, V1, ZERO
9D003FB8  00402821   ADDU A1, V0, ZERO
9D003FBC  0F402D75   JAL INT32UtoHexASCIIstr
9D003FC0  00000000   NOP
2718:                					AddDisplayStr(szfnDisplayStr);
9D003FC4  27C20018   ADDIU V0, S8, 24
9D003FC8  00402021   ADDU A0, V0, ZERO
9D003FCC  0F402DC0   JAL AddDisplayStr
9D003FD0  00000000   NOP
2719:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D003FD4  97828110   LHU V0, -32496(GP)
9D003FD8  24420001   ADDIU V0, V0, 1
9D003FDC  3042FFFF   ANDI V0, V0, -1
9D003FE0  A7828110   SH V0, -32496(GP)
2720:                					break;
9D003FE4  0B401043   J 0x9D00410C
9D003FE8  00000000   NOP
2721:                
2722:                				case 8:
2723:                					AddDisplayNewLine();
9D003FEC  0F402E24   JAL AddDisplayNewLine
9D003FF0  00000000   NOP
2724:                					AddDisplayStr("\tT3CON Timer 3 Control Register:  ");
9D003FF4  3C029D00   LUI V0, -25344
9D003FF8  2444617C   ADDIU A0, V0, 24956
9D003FFC  0F402DC0   JAL AddDisplayStr
9D004000  00000000   NOP
2725:                					INT32UtoHexASCIIstr(T3CON, szfnDisplayStr);
9D004004  3C02BF80   LUI V0, -16512
9D004008  8C430A00   LW V1, 2560(V0)
9D00400C  27C20018   ADDIU V0, S8, 24
9D004010  00602021   ADDU A0, V1, ZERO
9D004014  00402821   ADDU A1, V0, ZERO
9D004018  0F402D75   JAL INT32UtoHexASCIIstr
9D00401C  00000000   NOP
2726:                					AddDisplayStr(szfnDisplayStr);
9D004020  27C20018   ADDIU V0, S8, 24
9D004024  00402021   ADDU A0, V0, ZERO
9D004028  0F402DC0   JAL AddDisplayStr
9D00402C  00000000   NOP
2727:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D004030  97828110   LHU V0, -32496(GP)
9D004034  24420001   ADDIU V0, V0, 1
9D004038  3042FFFF   ANDI V0, V0, -1
9D00403C  A7828110   SH V0, -32496(GP)
2728:                					break;
9D004040  0B401043   J 0x9D00410C
9D004044  00000000   NOP
2729:                
2730:                				case 9:
2731:                					AddDisplayStr("\tTMR3 Timer 3 Register:           ");
9D004048  3C029D00   LUI V0, -25344
9D00404C  244461A0   ADDIU A0, V0, 24992
9D004050  0F402DC0   JAL AddDisplayStr
9D004054  00000000   NOP
2732:                					INT32UtoHexASCIIstr(TMR3, szfnDisplayStr);
9D004058  3C02BF80   LUI V0, -16512
9D00405C  8C430A10   LW V1, 2576(V0)
9D004060  27C20018   ADDIU V0, S8, 24
9D004064  00602021   ADDU A0, V1, ZERO
9D004068  00402821   ADDU A1, V0, ZERO
9D00406C  0F402D75   JAL INT32UtoHexASCIIstr
9D004070  00000000   NOP
2733:                					AddDisplayStr(szfnDisplayStr);
9D004074  27C20018   ADDIU V0, S8, 24
9D004078  00402021   ADDU A0, V0, ZERO
9D00407C  0F402DC0   JAL AddDisplayStr
9D004080  00000000   NOP
2734:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D004084  97828110   LHU V0, -32496(GP)
9D004088  24420001   ADDIU V0, V0, 1
9D00408C  3042FFFF   ANDI V0, V0, -1
9D004090  A7828110   SH V0, -32496(GP)
2735:                					break;
9D004094  0B401043   J 0x9D00410C
9D004098  00000000   NOP
2736:                
2737:                				case 10:
2738:                					AddDisplayStr("\tPR3 Period3 Register (Encoders): ");
9D00409C  3C029D00   LUI V0, -25344
9D0040A0  244465F0   ADDIU A0, V0, 26096
9D0040A4  0F402DC0   JAL AddDisplayStr
9D0040A8  00000000   NOP
2739:                					INT32UtoHexASCIIstr(PR3, szfnDisplayStr);
9D0040AC  3C02BF80   LUI V0, -16512
9D0040B0  8C430A20   LW V1, 2592(V0)
9D0040B4  27C20018   ADDIU V0, S8, 24
9D0040B8  00602021   ADDU A0, V1, ZERO
9D0040BC  00402821   ADDU A1, V0, ZERO
9D0040C0  0F402D75   JAL INT32UtoHexASCIIstr
9D0040C4  00000000   NOP
2740:                					AddDisplayStr(szfnDisplayStr);
9D0040C8  27C20018   ADDIU V0, S8, 24
9D0040CC  00402021   ADDU A0, V0, ZERO
9D0040D0  0F402DC0   JAL AddDisplayStr
9D0040D4  00000000   NOP
2741:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D0040D8  97828110   LHU V0, -32496(GP)
9D0040DC  24420001   ADDIU V0, V0, 1
9D0040E0  3042FFFF   ANDI V0, V0, -1
9D0040E4  A7828110   SH V0, -32496(GP)
2742:                //					break;
2743:                
2744:                // TBD: timers 4, 5
2745:                
2746:                					bRetVal = FALSE;															// nothing to display
9D0040E8  AFC00010   SW ZERO, 16(S8)
2747:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D0040EC  24020002   ADDIU V0, ZERO, 2
9D0040F0  AF828048   SW V0, -32696(GP)
2748:                					break;
9D0040F4  0B401043   J 0x9D00410C
9D0040F8  00000000   NOP
2749:                
2750:                
2751:                				default:
2752:                					bRetVal = FALSE;															// nothing to display
9D0040FC  AFC00010   SW ZERO, 16(S8)
2753:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D004100  24020002   ADDIU V0, ZERO, 2
9D004104  AF828048   SW V0, -32696(GP)
2754:                					break;
9D004108  00000000   NOP
2755:                				}
2756:                			}
2757:                			break;
9D00410C  0B401099   J 0x9D004264
9D004110  00000000   NOP
2758:                
2759:                		case RESULT_READ_REGISTERS_ADC_SETTINGS:
2760:                			{
2761:                			switch(fgwDisplayLineCtr)
9D004114  97828110   LHU V0, -32496(GP)
9D004118  1440000D   BNE V0, ZERO, 0x9D004150
9D00411C  00000000   NOP
2762:                				{
2763:                				case 0:
2764:                					AddDisplayNewLine();
9D004120  0F402E24   JAL AddDisplayNewLine
9D004124  00000000   NOP
2765:                					AddDisplayStrAndNewLine("  ADC Register values");
9D004128  3C029D00   LUI V0, -25344
9D00412C  24446614   ADDIU A0, V0, 26132
9D004130  0F402DDD   JAL AddDisplayStrAndNewLine
9D004134  00000000   NOP
2766:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D004138  97828110   LHU V0, -32496(GP)
9D00413C  24420001   ADDIU V0, V0, 1
9D004140  3042FFFF   ANDI V0, V0, -1
9D004144  A7828110   SH V0, -32496(GP)
2767:                					break;
9D004148  0B401058   J 0x9D004160
9D00414C  00000000   NOP
2768:                #ifdef NOTDEF
2769:                				case 1:
2770:                					AddDisplayStr("\tADCON0: Channel Select, Status, ADON: \t");
2771:                					WORDtoHexASCIIstr(ADCON0, szfnDisplayStr);
2772:                					AddDisplayStr(szfnDisplayStr);
2773:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2774:                					break;
2775:                
2776:                				case 2:
2777:                					AddDisplayStr("\tADCON1: Vref, Port Config: \t\t");
2778:                					WORDtoHexASCIIstr(ADCON1, szfnDisplayStr);
2779:                					AddDisplayStr(szfnDisplayStr);
2780:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2781:                					break;
2782:                
2783:                				case 3:
2784:                					AddDisplayStr("\tADCON2: Acq time, Clock Select: \t");
2785:                					WORDtoHexASCIIstr(ADCON2, szfnDisplayStr);
2786:                					AddDisplayStr(szfnDisplayStr);
2787:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2788:                					break;
2789:                
2790:                				case 4:
2791:                					AddDisplayStr("\tTRISA: Port A Config: \t\t\t");
2792:                					WORDtoHexASCIIstr(TRISA, szfnDisplayStr);
2793:                					AddDisplayStr(szfnDisplayStr);
2794:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2795:                					break;
2796:                
2797:                
2798:                				case 5:
2799:                					AddDisplayStr("\tCCP2CON: CCP Special Event Trigger: \t");
2800:                					WORDtoHexASCIIstr(CCP2CON, szfnDisplayStr);
2801:                					AddDisplayStr(szfnDisplayStr);
2802:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2803:                					break;
2804:                
2805:                				case 6:
2806:                					AddDisplayStr("\tADRESx: A/D Result Registers: \t\t");
2807:                					WORDtoHexASCIIstr((ADRESH * 256) + ADRESL, szfnDisplayStr);
2808:                					AddDisplayStr(szfnDisplayStr);
2809:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
2810:                					break;
2811:                #endif
2812:                
2813:                				default:
2814:                					bRetVal = FALSE;															// nothing to display
9D004150  AFC00010   SW ZERO, 16(S8)
2815:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D004154  24020002   ADDIU V0, ZERO, 2
9D004158  AF828048   SW V0, -32696(GP)
2816:                					break;
9D00415C  00000000   NOP
2817:                				}
2818:                			}
2819:                			break;
9D004160  0B401099   J 0x9D004264
9D004164  00000000   NOP
2820:                
2821:                
2822:                		case RESULT_READ_INPUTS_ADC:
2823:                			{
2824:                			switch(fgwDisplayLineCtr)
9D004168  97828110   LHU V0, -32496(GP)
9D00416C  1440000D   BNE V0, ZERO, 0x9D0041A4
9D004170  00000000   NOP
2825:                				{
2826:                				case 0:
2827:                					AddDisplayNewLine();
9D004174  0F402E24   JAL AddDisplayNewLine
9D004178  00000000   NOP
2828:                					AddDisplayStrAndNewLine("  ADC Register values");
9D00417C  3C029D00   LUI V0, -25344
9D004180  24446614   ADDIU A0, V0, 26132
9D004184  0F402DDD   JAL AddDisplayStrAndNewLine
9D004188  00000000   NOP
2829:                					++fgwDisplayLineCtr;														// bump display line counter to next line
9D00418C  97828110   LHU V0, -32496(GP)
9D004190  24420001   ADDIU V0, V0, 1
9D004194  3042FFFF   ANDI V0, V0, -1
9D004198  A7828110   SH V0, -32496(GP)
2830:                					break;
9D00419C  0B40106D   J 0x9D0041B4
9D0041A0  00000000   NOP
2831:                #ifdef NOTDEF
2832:                				case 1:
2833:                					AddDisplayStr("Battery (AN0): \t\t");
2834:                					wADCValue = ADC_Read_Basic(ADC_CH_BATTERY);
2835:                					WORDtoASCIIstr(wADCValue, TEN_BIT_WORD_WIDTH, szfnDisplayStr);
2836:                					AddDisplayStr(szfnDisplayStr);
2837:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2838:                					break;
2839:                
2840:                				case 2:
2841:                					AddDisplayStr("Thermistor (AN1/AN2): \t");
2842:                					wADCValue = ADC_Read_Basic(ADC_CH_THERMISTOR);
2843:                					WORDtoASCIIstr(wADCValue, TEN_BIT_WORD_WIDTH, szfnDisplayStr);
2844:                					AddDisplayStr(szfnDisplayStr);
2845:                					++fgwDisplayLineCtr;														// bump display line counter to next line
2846:                					break;
2847:                
2848:                				case 3:
2849:                					AddDisplayStr("End-of-Travel OUT (AN4): ");
2850:                					wADCValue = ADC_Read_Basic(ADC_CH_EOT_OUT);
2851:                					WORDtoASCIIstr(wADCValue, TEN_BIT_WORD_WIDTH, szfnDisplayStr);
2852:                					AddDisplayStr(szfnDisplayStr);
2853:                					eResultLine = RESULT_LAST_LINE;												// this is the last line to display
2854:                					break;
2855:                #endif
2856:                
2857:                				default:
2858:                					bRetVal = FALSE;															// nothing to display
9D0041A4  AFC00010   SW ZERO, 16(S8)
2859:                					eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D0041A8  24020002   ADDIU V0, ZERO, 2
9D0041AC  AF828048   SW V0, -32696(GP)
2860:                					break;
9D0041B0  00000000   NOP
2861:                				}
2862:                			}
2863:                			break;
9D0041B4  0B401099   J 0x9D004264
9D0041B8  00000000   NOP
2864:                
2865:                		case RESULT_READ_INPUTS_SWITCHES:
2866:                			{
2867:                			// display current state of input switches, debounced switch events
2868:                			AddDisplayStr("Raw Input Pins: ");
9D0041BC  3C029D00   LUI V0, -25344
9D0041C0  2444662C   ADDIU A0, V0, 26156
9D0041C4  0F402DC0   JAL AddDisplayStr
9D0041C8  00000000   NOP
2869:                			BYTEtoHexASCIIstr(GetInputSwitchState(), szfnDisplayStr);		// this actually reads the hardware
9D0041CC  0F403521   JAL GetInputSwitchState
9D0041D0  00000000   NOP
9D0041D4  00401821   ADDU V1, V0, ZERO
9D0041D8  27C20018   ADDIU V0, S8, 24
9D0041DC  00602021   ADDU A0, V1, ZERO
9D0041E0  00402821   ADDU A1, V0, ZERO
9D0041E4  0F402BFC   JAL BYTEtoHexASCIIstr
9D0041E8  00000000   NOP
2870:                			AddDisplayStr(szfnDisplayStr);
9D0041EC  27C20018   ADDIU V0, S8, 24
9D0041F0  00402021   ADDU A0, V0, ZERO
9D0041F4  0F402DC0   JAL AddDisplayStr
9D0041F8  00000000   NOP
2871:                
2872:                			AddDisplayStr("\tDebounced Events: ");
9D0041FC  3C029D00   LUI V0, -25344
9D004200  24446640   ADDIU A0, V0, 26176
9D004204  0F402DC0   JAL AddDisplayStr
9D004208  00000000   NOP
2873:                			WORDtoHexASCIIstr(efSwitchEvents, szfnDisplayStr);				// event flags are 16 bit words
9D00420C  978280EC   LHU V0, -32532(GP)
9D004210  00401821   ADDU V1, V0, ZERO
9D004214  27C20018   ADDIU V0, S8, 24
9D004218  00602021   ADDU A0, V1, ZERO
9D00421C  00402821   ADDU A1, V0, ZERO
9D004220  0F402C22   JAL WORDtoHexASCIIstr
9D004224  00000000   NOP
2874:                			AddDisplayStr(szfnDisplayStr);
9D004228  27C20018   ADDIU V0, S8, 24
9D00422C  00402021   ADDU A0, V0, ZERO
9D004230  0F402DC0   JAL AddDisplayStr
9D004234  00000000   NOP
2875:                			eStreamLine = STREAM_LINE;					// mark display of {some} line of data
9D004238  24020001   ADDIU V0, ZERO, 1
9D00423C  AF82811C   SW V0, -32484(GP)
2876:                
2877:                			bRetVal = FALSE;															// nothing to display
9D004240  AFC00010   SW ZERO, 16(S8)
2878:                			eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D004244  24020002   ADDIU V0, ZERO, 2
9D004248  AF828048   SW V0, -32696(GP)
2879:                			}
2880:                			break;
9D00424C  0B401099   J 0x9D004264
9D004250  00000000   NOP
2881:                
2882:                
2883:                		case RESULT_NONE:
2884:                		default:
2885:                			bRetVal = FALSE;															// nothing to display
9D004254  AFC00010   SW ZERO, 16(S8)
2886:                			eResultLine = RESULT_LAST_LINE;												// this is (effectively) the last line to display
9D004258  24020002   ADDIU V0, ZERO, 2
9D00425C  AF828048   SW V0, -32696(GP)
2887:                			break;
9D004260  00000000   NOP
2888:                		}
2889:                
2890:                	if (eResultLine IS_NOT RESULT_LAST_LINE)
9D004264  8F838048   LW V1, -32696(GP)
9D004268  24020002   ADDIU V0, ZERO, 2
9D00426C  10620003   BEQ V1, V0, 0x9D00427C
9D004270  00000000   NOP
2891:                		AddDisplayNewLine();							// add line terminator unless this is the LAST line
9D004274  0F402E24   JAL AddDisplayNewLine
9D004278  00000000   NOP
2892:                
2893:                	DisplayStr(UARTid);										// start display (serial output) of line
9D00427C  8FC40078   LW A0, 120(S8)
9D004280  0F402E32   JAL DisplayStr
9D004284  00000000   NOP
2894:                
2895:                	return bRetVal;										// TRUE if more data to display, FALSE if last line
9D004288  8FC20010   LW V0, 16(S8)
2896:                }
9D00428C  03C0E821   ADDU SP, S8, ZERO
9D004290  8FBF0074   LW RA, 116(SP)
9D004294  8FBE0070   LW S8, 112(SP)
9D004298  27BD0078   ADDIU SP, SP, 120
9D00429C  03E00008   JR RA
9D0042A0  00000000   NOP
2897:                
2898:                
2899:                //*****************************************************************************
2900:                //							D i s p l a y S t a t u s ( ) 
2901:                //*****************************************************************************
2902:                
2903:                // streaming status of current motor direction, speed, position
2904:                BOOL DisplayStatus(UART_MODULE UARTid)
2905:                {
9D0042A4  27BDFF88   ADDIU SP, SP, -120
9D0042A8  AFBF0074   SW RA, 116(SP)
9D0042AC  AFBE0070   SW S8, 112(SP)
9D0042B0  03A0F021   ADDU S8, SP, ZERO
9D0042B4  AFC40078   SW A0, 120(S8)
2906:                
2907:                	LOCAL ARRAY char szfnDisplayStr[DISPLAY_LINE_SIZE + 1];
2908:                //	unsigned int nADCValue;
2909:                	INT32U lDutyCycle;
2910:                	BOOL bRetVal;
2911:                	int eMotor = 0;			// kludge!
9D0042B8  AFC00014   SW ZERO, 20(S8)
2912:                
2913:                	ClearDisplayStr();
9D0042BC  0F402DB6   JAL ClearDisplayStr
9D0042C0  00000000   NOP
2914:                
2915:                	switch(eCurrentStatus)
9D0042C4  8F828118   LW V0, -32488(GP)
9D0042C8  24030001   ADDIU V1, ZERO, 1
9D0042CC  10430063   BEQ V0, V1, 0x9D00445C
9D0042D0  00000000   NOP
9D0042D4  2C430001   SLTIU V1, V0, 1
9D0042D8  14600009   BNE V1, ZERO, 0x9D004300
9D0042DC  00000000   NOP
9D0042E0  24030002   ADDIU V1, ZERO, 2
9D0042E4  104302AA   BEQ V0, V1, 0x9D004D90
9D0042E8  00000000   NOP
9D0042EC  24030003   ADDIU V1, ZERO, 3
9D0042F0  104302CC   BEQ V0, V1, 0x9D004E24
9D0042F4  00000000   NOP
9D0042F8  0B4013BE   J 0x9D004EF8
9D0042FC  00000000   NOP
2916:                		{
2917:                		case FSM_STATUS:
2918:                			// display speed and position
2919:                			eMotor = MOTOR_AZIMUTH;
9D004300  AFC00014   SW ZERO, 20(S8)
2920:                			AddDisplayStr("AZ Spd: ");
9D004304  3C029D00   LUI V0, -25344
9D004308  24446654   ADDIU A0, V0, 26196
9D00430C  0F402DC0   JAL AddDisplayStr
9D004310  00000000   NOP
2921:                			WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D004314  8FC20014   LW V0, 20(S8)
9D004318  00402021   ADDU A0, V0, ZERO
9D00431C  0F401AD0   JAL CurrentSpeed_Read
9D004320  00000000   NOP
9D004324  3042FFFF   ANDI V0, V0, -1
9D004328  00401821   ADDU V1, V0, ZERO
9D00432C  27C2001C   ADDIU V0, S8, 28
9D004330  00602021   ADDU A0, V1, ZERO
9D004334  24050005   ADDIU A1, ZERO, 5
9D004338  00403021   ADDU A2, V0, ZERO
9D00433C  0F402C67   JAL WORDtoASCIIstr
9D004340  00000000   NOP
2922:                			AddDisplayStr(szfnDisplayStr);
9D004344  27C2001C   ADDIU V0, S8, 28
9D004348  00402021   ADDU A0, V0, ZERO
9D00434C  0F402DC0   JAL AddDisplayStr
9D004350  00000000   NOP
2923:                			AddDisplayStr("  Pos: ");
9D004354  3C029D00   LUI V0, -25344
9D004358  24446660   ADDIU A0, V0, 26208
9D00435C  0F402DC0   JAL AddDisplayStr
9D004360  00000000   NOP
2924:                			INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004364  8FC20014   LW V0, 20(S8)
9D004368  00402021   ADDU A0, V0, ZERO
9D00436C  0F401B14   JAL CurrentPosition_Read
9D004370  00000000   NOP
9D004374  00401821   ADDU V1, V0, ZERO
9D004378  27C2001C   ADDIU V0, S8, 28
9D00437C  00602021   ADDU A0, V1, ZERO
9D004380  24050006   ADDIU A1, ZERO, 6
9D004384  00403021   ADDU A2, V0, ZERO
9D004388  0F402CB7   JAL INT16StoASCIIstr
9D00438C  00000000   NOP
2925:                			AddDisplayStr(szfnDisplayStr);
9D004390  27C2001C   ADDIU V0, S8, 28
9D004394  00402021   ADDU A0, V0, ZERO
9D004398  0F402DC0   JAL AddDisplayStr
9D00439C  00000000   NOP
2926:                
2927:                			eMotor = MOTOR_ELEVATION;
9D0043A0  24020001   ADDIU V0, ZERO, 1
9D0043A4  AFC20014   SW V0, 20(S8)
2928:                			AddDisplayStr("\tEL Spd: ");
9D0043A8  3C029D00   LUI V0, -25344
9D0043AC  24446668   ADDIU A0, V0, 26216
9D0043B0  0F402DC0   JAL AddDisplayStr
9D0043B4  00000000   NOP
2929:                			WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D0043B8  8FC20014   LW V0, 20(S8)
9D0043BC  00402021   ADDU A0, V0, ZERO
9D0043C0  0F401AD0   JAL CurrentSpeed_Read
9D0043C4  00000000   NOP
9D0043C8  3042FFFF   ANDI V0, V0, -1
9D0043CC  00401821   ADDU V1, V0, ZERO
9D0043D0  27C2001C   ADDIU V0, S8, 28
9D0043D4  00602021   ADDU A0, V1, ZERO
9D0043D8  24050005   ADDIU A1, ZERO, 5
9D0043DC  00403021   ADDU A2, V0, ZERO
9D0043E0  0F402C67   JAL WORDtoASCIIstr
9D0043E4  00000000   NOP
2930:                			AddDisplayStr(szfnDisplayStr);
9D0043E8  27C2001C   ADDIU V0, S8, 28
9D0043EC  00402021   ADDU A0, V0, ZERO
9D0043F0  0F402DC0   JAL AddDisplayStr
9D0043F4  00000000   NOP
2931:                			AddDisplayStr("  Pos: ");
9D0043F8  3C029D00   LUI V0, -25344
9D0043FC  24446660   ADDIU A0, V0, 26208
9D004400  0F402DC0   JAL AddDisplayStr
9D004404  00000000   NOP
2932:                			INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004408  8FC20014   LW V0, 20(S8)
9D00440C  00402021   ADDU A0, V0, ZERO
9D004410  0F401B14   JAL CurrentPosition_Read
9D004414  00000000   NOP
9D004418  00401821   ADDU V1, V0, ZERO
9D00441C  27C2001C   ADDIU V0, S8, 28
9D004420  00602021   ADDU A0, V1, ZERO
9D004424  24050006   ADDIU A1, ZERO, 6
9D004428  00403021   ADDU A2, V0, ZERO
9D00442C  0F402CB7   JAL INT16StoASCIIstr
9D004430  00000000   NOP
2933:                			AddDisplayStr(szfnDisplayStr);
9D004434  27C2001C   ADDIU V0, S8, 28
9D004438  00402021   ADDU A0, V0, ZERO
9D00443C  0F402DC0   JAL AddDisplayStr
9D004440  00000000   NOP
2934:                
2935:                #ifdef NOTDEF
2936:                			// display FSM state strings
2937:                			AddDisplayStr(" User: ");
2938:                			AddDisplayStr(GetCommandStateString());
2939:                			AddDisplayStr("   Motion: ");
2940:                			AddDisplayStr(GetMotionStateString());
2941:                			//AddDisplayStr("   Motion Sequencer: ");
2942:                			//AddDisplayStr(GetMotionSeqStateString());
2943:                #endif
2944:                			eStreamLine = STREAM_LINE;					// mark display of {some} line of data
9D004444  24020001   ADDIU V0, ZERO, 1
9D004448  AF82811C   SW V0, -32484(GP)
2945:                
2946:                			bRetVal = TRUE;								// always returns true; no limit to available data
9D00444C  24020001   ADDIU V0, ZERO, 1
9D004450  AFC20010   SW V0, 16(S8)
2947:                			break;
9D004454  0B4013C0   J 0x9D004F00
9D004458  00000000   NOP
2948:                
2949:                		case MOTOR_STATUS:
2950:                			{
2951:                
2952:                			// DEBUG_PIN1_HI;
2953:                
2954:                			eMotor = MOTOR_AZIMUTH;
9D00445C  AFC00014   SW ZERO, 20(S8)
2955:                			AddDisplayStr("AZ ");
9D004460  3C029D00   LUI V0, -25344
9D004464  24446674   ADDIU A0, V0, 26228
9D004468  0F402DC0   JAL AddDisplayStr
9D00446C  00000000   NOP
2956:                
2957:                			switch(pgePWMDirection[eMotor])
9D004470  3C02A000   LUI V0, -24576
9D004474  8FC30014   LW V1, 20(S8)
9D004478  00031880   SLL V1, V1, 2
9D00447C  2442020C   ADDIU V0, V0, 524
9D004480  00621021   ADDU V0, V1, V0
9D004484  8C420000   LW V0, 0(V0)
9D004488  10400078   BEQ V0, ZERO, 0x9D00466C
9D00448C  00000000   NOP
9D004490  24030001   ADDIU V1, ZERO, 1
9D004494  1043009E   BEQ V0, V1, 0x9D004710
9D004498  00000000   NOP
9D00449C  2403FFFF   ADDIU V1, ZERO, -1
9D0044A0  1443010C   BNE V0, V1, 0x9D0048D4
9D0044A4  00000000   NOP
2958:                				{
2959:                				case PWM_DIR_REVERSE:
2960:                					AddDisplayStr("R S: ");
9D0044A8  3C029D00   LUI V0, -25344
9D0044AC  24446678   ADDIU A0, V0, 26232
9D0044B0  0F402DC0   JAL AddDisplayStr
9D0044B4  00000000   NOP
2961:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D0044B8  8FC20014   LW V0, 20(S8)
9D0044BC  00402021   ADDU A0, V0, ZERO
9D0044C0  0F401AD0   JAL CurrentSpeed_Read
9D0044C4  00000000   NOP
9D0044C8  3042FFFF   ANDI V0, V0, -1
9D0044CC  00401821   ADDU V1, V0, ZERO
9D0044D0  27C2001C   ADDIU V0, S8, 28
9D0044D4  00602021   ADDU A0, V1, ZERO
9D0044D8  24050005   ADDIU A1, ZERO, 5
9D0044DC  00403021   ADDU A2, V0, ZERO
9D0044E0  0F402C67   JAL WORDtoASCIIstr
9D0044E4  00000000   NOP
2962:                					AddDisplayStr(szfnDisplayStr);
9D0044E8  27C2001C   ADDIU V0, S8, 28
9D0044EC  00402021   ADDU A0, V0, ZERO
9D0044F0  0F402DC0   JAL AddDisplayStr
9D0044F4  00000000   NOP
2963:                #ifdef NOTDEF
2964:                					#ifdef CALC_AVERAGE_SPEED
2965:                						AddDisplayStr(" Sa: ");
2966:                						WORDtoASCIIstr(pgwAverageSpeed, WORD_WIDTH, szfnDisplayStr);
2967:                						AddDisplayStr(szfnDisplayStr);
2968:                	
2969:                						AddDisplayStr(" Sae: ");
2970:                						INT16StoASCIIstr(pgnErrorFromAverage, INT16S_WIDTH, szfnDisplayStr);
2971:                						AddDisplayStr(szfnDisplayStr);
2972:                	
2973:                						AddDisplayStr(" Se: ");
2974:                						INT16StoASCIIstr(pgnErrorFromSample, INT16S_WIDTH, szfnDisplayStr);
2975:                						AddDisplayStr(szfnDisplayStr);
2976:                					#endif
2977:                
2978:                					AddDisplayStr(" S Err: ");
2979:                					INT16StoASCIIstr(pgnSpeedError, INT16S_WIDTH, szfnDisplayStr);
2980:                					AddDisplayStr(szfnDisplayStr);
2981:                
2982:                					AddDisplayStr(" PWM Corr: ");
2983:                					INT16StoASCIIstr(pgnDutyCycleCorrection, INT16S_WIDTH, szfnDisplayStr);
2984:                					AddDisplayStr(szfnDisplayStr);
2985:                #endif
2986:                
2987:                					AddDisplayStr(" P: ");
9D0044F8  3C029D00   LUI V0, -25344
9D0044FC  24446680   ADDIU A0, V0, 26240
9D004500  0F402DC0   JAL AddDisplayStr
9D004504  00000000   NOP
2988:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor ), INT16S_WIDTH, szfnDisplayStr);
9D004508  8FC20014   LW V0, 20(S8)
9D00450C  00402021   ADDU A0, V0, ZERO
9D004510  0F401B14   JAL CurrentPosition_Read
9D004514  00000000   NOP
9D004518  00401821   ADDU V1, V0, ZERO
9D00451C  27C2001C   ADDIU V0, S8, 28
9D004520  00602021   ADDU A0, V1, ZERO
9D004524  24050006   ADDIU A1, ZERO, 6
9D004528  00403021   ADDU A2, V0, ZERO
9D00452C  0F402CB7   JAL INT16StoASCIIstr
9D004530  00000000   NOP
2989:                					AddDisplayStr(szfnDisplayStr);
9D004534  27C2001C   ADDIU V0, S8, 28
9D004538  00402021   ADDU A0, V0, ZERO
9D00453C  0F402DC0   JAL AddDisplayStr
9D004540  00000000   NOP
2990:                
2991:                					AddDisplayStr("  PWM1 DC: ");
9D004544  3C029D00   LUI V0, -25344
9D004548  24446688   ADDIU A0, V0, 26248
9D00454C  0F402DC0   JAL AddDisplayStr
9D004550  00000000   NOP
2992:                					lDutyCycle = (INT32U)OC1R / (INT32U)(PR2/100);
9D004554  3C02BF80   LUI V0, -16512
9D004558  8C443010   LW A0, 12304(V0)
9D00455C  3C02BF80   LUI V0, -16512
9D004560  8C430820   LW V1, 2080(V0)
9D004564  3C0251EB   LUI V0, 20971
9D004568  3442851F   ORI V0, V0, -31457
9D00456C  00620019   MULTU V1, V0
9D004570  00001012   MFLO V0
9D004574  00001810   MFHI V1
9D004578  00031142   SRL V0, V1, 5
9D00457C  0082001B   DIVU A0, V0
9D004580  004001F4   TEQ V0, ZERO
9D004584  00001810   MFHI V1
9D004588  00001012   MFLO V0
9D00458C  AFC20018   SW V0, 24(S8)
2993:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004590  8FC20018   LW V0, 24(S8)
9D004594  3042FFFF   ANDI V0, V0, -1
9D004598  00401821   ADDU V1, V0, ZERO
9D00459C  27C2001C   ADDIU V0, S8, 28
9D0045A0  00602021   ADDU A0, V1, ZERO
9D0045A4  24050003   ADDIU A1, ZERO, 3
9D0045A8  00403021   ADDU A2, V0, ZERO
9D0045AC  0F402C67   JAL WORDtoASCIIstr
9D0045B0  00000000   NOP
2994:                					AddDisplayStr(szfnDisplayStr);
9D0045B4  27C2001C   ADDIU V0, S8, 28
9D0045B8  00402021   ADDU A0, V0, ZERO
9D0045BC  0F402DC0   JAL AddDisplayStr
9D0045C0  00000000   NOP
2995:                					AddDisplayStr("%");
9D0045C4  3C029D00   LUI V0, -25344
9D0045C8  24446694   ADDIU A0, V0, 26260
9D0045CC  0F402DC0   JAL AddDisplayStr
9D0045D0  00000000   NOP
2996:                
2997:                					AddDisplayStr("  PWM2 DC: ");
9D0045D4  3C029D00   LUI V0, -25344
9D0045D8  24446698   ADDIU A0, V0, 26264
9D0045DC  0F402DC0   JAL AddDisplayStr
9D0045E0  00000000   NOP
2998:                					lDutyCycle = (INT32U)OC2R / (INT32U)(PR2/100);
9D0045E4  3C02BF80   LUI V0, -16512
9D0045E8  8C443210   LW A0, 12816(V0)
9D0045EC  3C02BF80   LUI V0, -16512
9D0045F0  8C430820   LW V1, 2080(V0)
9D0045F4  3C0251EB   LUI V0, 20971
9D0045F8  3442851F   ORI V0, V0, -31457
9D0045FC  00620019   MULTU V1, V0
9D004600  00001012   MFLO V0
9D004604  00001810   MFHI V1
9D004608  00031142   SRL V0, V1, 5
9D00460C  0082001B   DIVU A0, V0
9D004610  004001F4   TEQ V0, ZERO
9D004614  00001810   MFHI V1
9D004618  00001012   MFLO V0
9D00461C  AFC20018   SW V0, 24(S8)
2999:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004620  8FC20018   LW V0, 24(S8)
9D004624  3042FFFF   ANDI V0, V0, -1
9D004628  00401821   ADDU V1, V0, ZERO
9D00462C  27C2001C   ADDIU V0, S8, 28
9D004630  00602021   ADDU A0, V1, ZERO
9D004634  24050003   ADDIU A1, ZERO, 3
9D004638  00403021   ADDU A2, V0, ZERO
9D00463C  0F402C67   JAL WORDtoASCIIstr
9D004640  00000000   NOP
3000:                					AddDisplayStr(szfnDisplayStr);
9D004644  27C2001C   ADDIU V0, S8, 28
9D004648  00402021   ADDU A0, V0, ZERO
9D00464C  0F402DC0   JAL AddDisplayStr
9D004650  00000000   NOP
3001:                					AddDisplayStr("%");
9D004654  3C029D00   LUI V0, -25344
9D004658  24446694   ADDIU A0, V0, 26260
9D00465C  0F402DC0   JAL AddDisplayStr
9D004660  00000000   NOP
3002:                
3003:                					break;
9D004664  0B40123A   J 0x9D0048E8
9D004668  00000000   NOP
3004:                
3005:                				case PWM_DIR_STOPPED:
3006:                					AddDisplayStr("S  S: ");
9D00466C  3C029D00   LUI V0, -25344
9D004670  244466A4   ADDIU A0, V0, 26276
9D004674  0F402DC0   JAL AddDisplayStr
9D004678  00000000   NOP
3007:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D00467C  8FC20014   LW V0, 20(S8)
9D004680  00402021   ADDU A0, V0, ZERO
9D004684  0F401AD0   JAL CurrentSpeed_Read
9D004688  00000000   NOP
9D00468C  3042FFFF   ANDI V0, V0, -1
9D004690  00401821   ADDU V1, V0, ZERO
9D004694  27C2001C   ADDIU V0, S8, 28
9D004698  00602021   ADDU A0, V1, ZERO
9D00469C  24050005   ADDIU A1, ZERO, 5
9D0046A0  00403021   ADDU A2, V0, ZERO
9D0046A4  0F402C67   JAL WORDtoASCIIstr
9D0046A8  00000000   NOP
3008:                					AddDisplayStr(szfnDisplayStr);
9D0046AC  27C2001C   ADDIU V0, S8, 28
9D0046B0  00402021   ADDU A0, V0, ZERO
9D0046B4  0F402DC0   JAL AddDisplayStr
9D0046B8  00000000   NOP
3009:                					AddDisplayStr("  P: ");
9D0046BC  3C029D00   LUI V0, -25344
9D0046C0  244466AC   ADDIU A0, V0, 26284
9D0046C4  0F402DC0   JAL AddDisplayStr
9D0046C8  00000000   NOP
3010:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D0046CC  8FC20014   LW V0, 20(S8)
9D0046D0  00402021   ADDU A0, V0, ZERO
9D0046D4  0F401B14   JAL CurrentPosition_Read
9D0046D8  00000000   NOP
9D0046DC  00401821   ADDU V1, V0, ZERO
9D0046E0  27C2001C   ADDIU V0, S8, 28
9D0046E4  00602021   ADDU A0, V1, ZERO
9D0046E8  24050006   ADDIU A1, ZERO, 6
9D0046EC  00403021   ADDU A2, V0, ZERO
9D0046F0  0F402CB7   JAL INT16StoASCIIstr
9D0046F4  00000000   NOP
3011:                					AddDisplayStr(szfnDisplayStr);
9D0046F8  27C2001C   ADDIU V0, S8, 28
9D0046FC  00402021   ADDU A0, V0, ZERO
9D004700  0F402DC0   JAL AddDisplayStr
9D004704  00000000   NOP
3012:                
3013:                					break;
9D004708  0B40123A   J 0x9D0048E8
9D00470C  00000000   NOP
3014:                
3015:                				case PWM_DIR_FORWARD:
3016:                					AddDisplayStr("F S: ");
9D004710  3C029D00   LUI V0, -25344
9D004714  244466B4   ADDIU A0, V0, 26292
9D004718  0F402DC0   JAL AddDisplayStr
9D00471C  00000000   NOP
3017:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D004720  8FC20014   LW V0, 20(S8)
9D004724  00402021   ADDU A0, V0, ZERO
9D004728  0F401AD0   JAL CurrentSpeed_Read
9D00472C  00000000   NOP
9D004730  3042FFFF   ANDI V0, V0, -1
9D004734  00401821   ADDU V1, V0, ZERO
9D004738  27C2001C   ADDIU V0, S8, 28
9D00473C  00602021   ADDU A0, V1, ZERO
9D004740  24050005   ADDIU A1, ZERO, 5
9D004744  00403021   ADDU A2, V0, ZERO
9D004748  0F402C67   JAL WORDtoASCIIstr
9D00474C  00000000   NOP
3018:                					AddDisplayStr(szfnDisplayStr);
9D004750  27C2001C   ADDIU V0, S8, 28
9D004754  00402021   ADDU A0, V0, ZERO
9D004758  0F402DC0   JAL AddDisplayStr
9D00475C  00000000   NOP
3019:                
3020:                					#ifdef CALC_AVERAGE_SPEED
3021:                						AddDisplayStr(" Sa: ");
3022:                						WORDtoASCIIstr(pgwAverageSpeed, WORD_WIDTH, szfnDisplayStr);
3023:                						AddDisplayStr(szfnDisplayStr);
3024:                	
3025:                						AddDisplayStr(" Sae: ");
3026:                						INT16StoASCIIstr(pgnErrorFromAverage, INT16S_WIDTH, szfnDisplayStr);
3027:                						AddDisplayStr(szfnDisplayStr);
3028:                	
3029:                						AddDisplayStr(" Se: ");
3030:                						INT16StoASCIIstr(pgnErrorFromSample, INT16S_WIDTH, szfnDisplayStr);
3031:                						AddDisplayStr(szfnDisplayStr);
3032:                					#endif
3033:                #ifdef NOTDEF
3034:                					AddDisplayStr(" S Err: ");
3035:                					INT16StoASCIIstr(pgnSpeedError, INT16S_WIDTH, szfnDisplayStr);
3036:                					AddDisplayStr(szfnDisplayStr);
3037:                
3038:                					AddDisplayStr(" PWM Corr: ");
3039:                					INT16StoASCIIstr(pgnDutyCycleCorrection, INT16S_WIDTH, szfnDisplayStr);
3040:                					AddDisplayStr(szfnDisplayStr);
3041:                #endif
3042:                					AddDisplayStr(" P: ");
9D004760  3C029D00   LUI V0, -25344
9D004764  24446680   ADDIU A0, V0, 26240
9D004768  0F402DC0   JAL AddDisplayStr
9D00476C  00000000   NOP
3043:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004770  8FC20014   LW V0, 20(S8)
9D004774  00402021   ADDU A0, V0, ZERO
9D004778  0F401B14   JAL CurrentPosition_Read
9D00477C  00000000   NOP
9D004780  00401821   ADDU V1, V0, ZERO
9D004784  27C2001C   ADDIU V0, S8, 28
9D004788  00602021   ADDU A0, V1, ZERO
9D00478C  24050006   ADDIU A1, ZERO, 6
9D004790  00403021   ADDU A2, V0, ZERO
9D004794  0F402CB7   JAL INT16StoASCIIstr
9D004798  00000000   NOP
3044:                					AddDisplayStr(szfnDisplayStr);
9D00479C  27C2001C   ADDIU V0, S8, 28
9D0047A0  00402021   ADDU A0, V0, ZERO
9D0047A4  0F402DC0   JAL AddDisplayStr
9D0047A8  00000000   NOP
3045:                
3046:                					AddDisplayStr("  PWM1 DC: ");
9D0047AC  3C029D00   LUI V0, -25344
9D0047B0  24446688   ADDIU A0, V0, 26248
9D0047B4  0F402DC0   JAL AddDisplayStr
9D0047B8  00000000   NOP
3047:                					lDutyCycle = (INT32U)OC1R / (INT32U)(PR2/100);
9D0047BC  3C02BF80   LUI V0, -16512
9D0047C0  8C443010   LW A0, 12304(V0)
9D0047C4  3C02BF80   LUI V0, -16512
9D0047C8  8C430820   LW V1, 2080(V0)
9D0047CC  3C0251EB   LUI V0, 20971
9D0047D0  3442851F   ORI V0, V0, -31457
9D0047D4  00620019   MULTU V1, V0
9D0047D8  00001012   MFLO V0
9D0047DC  00001810   MFHI V1
9D0047E0  00031142   SRL V0, V1, 5
9D0047E4  0082001B   DIVU A0, V0
9D0047E8  004001F4   TEQ V0, ZERO
9D0047EC  00001810   MFHI V1
9D0047F0  00001012   MFLO V0
9D0047F4  AFC20018   SW V0, 24(S8)
3048:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D0047F8  8FC20018   LW V0, 24(S8)
9D0047FC  3042FFFF   ANDI V0, V0, -1
9D004800  00401821   ADDU V1, V0, ZERO
9D004804  27C2001C   ADDIU V0, S8, 28
9D004808  00602021   ADDU A0, V1, ZERO
9D00480C  24050003   ADDIU A1, ZERO, 3
9D004810  00403021   ADDU A2, V0, ZERO
9D004814  0F402C67   JAL WORDtoASCIIstr
9D004818  00000000   NOP
3049:                					AddDisplayStr(szfnDisplayStr);
9D00481C  27C2001C   ADDIU V0, S8, 28
9D004820  00402021   ADDU A0, V0, ZERO
9D004824  0F402DC0   JAL AddDisplayStr
9D004828  00000000   NOP
3050:                					AddDisplayStr("%");
9D00482C  3C029D00   LUI V0, -25344
9D004830  24446694   ADDIU A0, V0, 26260
9D004834  0F402DC0   JAL AddDisplayStr
9D004838  00000000   NOP
3051:                
3052:                					AddDisplayStr("  PWM2 DC: ");
9D00483C  3C029D00   LUI V0, -25344
9D004840  24446698   ADDIU A0, V0, 26264
9D004844  0F402DC0   JAL AddDisplayStr
9D004848  00000000   NOP
3053:                					lDutyCycle = (INT32U)OC2R / (INT32U)(PR2/100);
9D00484C  3C02BF80   LUI V0, -16512
9D004850  8C443210   LW A0, 12816(V0)
9D004854  3C02BF80   LUI V0, -16512
9D004858  8C430820   LW V1, 2080(V0)
9D00485C  3C0251EB   LUI V0, 20971
9D004860  3442851F   ORI V0, V0, -31457
9D004864  00620019   MULTU V1, V0
9D004868  00001012   MFLO V0
9D00486C  00001810   MFHI V1
9D004870  00031142   SRL V0, V1, 5
9D004874  0082001B   DIVU A0, V0
9D004878  004001F4   TEQ V0, ZERO
9D00487C  00001810   MFHI V1
9D004880  00001012   MFLO V0
9D004884  AFC20018   SW V0, 24(S8)
3054:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004888  8FC20018   LW V0, 24(S8)
9D00488C  3042FFFF   ANDI V0, V0, -1
9D004890  00401821   ADDU V1, V0, ZERO
9D004894  27C2001C   ADDIU V0, S8, 28
9D004898  00602021   ADDU A0, V1, ZERO
9D00489C  24050003   ADDIU A1, ZERO, 3
9D0048A0  00403021   ADDU A2, V0, ZERO
9D0048A4  0F402C67   JAL WORDtoASCIIstr
9D0048A8  00000000   NOP
3055:                					AddDisplayStr(szfnDisplayStr);
9D0048AC  27C2001C   ADDIU V0, S8, 28
9D0048B0  00402021   ADDU A0, V0, ZERO
9D0048B4  0F402DC0   JAL AddDisplayStr
9D0048B8  00000000   NOP
3056:                					AddDisplayStr("%");
9D0048BC  3C029D00   LUI V0, -25344
9D0048C0  24446694   ADDIU A0, V0, 26260
9D0048C4  0F402DC0   JAL AddDisplayStr
9D0048C8  00000000   NOP
3057:                
3058:                					break;
9D0048CC  0B40123A   J 0x9D0048E8
9D0048D0  00000000   NOP
3059:                				case PWM_DIR_UNKNOWN:
3060:                
3061:                				default:
3062:                					AddDisplayStr("?  ");
9D0048D4  3C029D00   LUI V0, -25344
9D0048D8  244466BC   ADDIU A0, V0, 26300
9D0048DC  0F402DC0   JAL AddDisplayStr
9D0048E0  00000000   NOP
3063:                					break;
9D0048E4  00000000   NOP
3064:                				}
3065:                
3066:                			eMotor = MOTOR_ELEVATION;
9D0048E8  24020001   ADDIU V0, ZERO, 1
9D0048EC  AFC20014   SW V0, 20(S8)
3067:                			AddDisplayStr(" EL ");
9D0048F0  3C029D00   LUI V0, -25344
9D0048F4  244466C0   ADDIU A0, V0, 26304
9D0048F8  0F402DC0   JAL AddDisplayStr
9D0048FC  00000000   NOP
3068:                
3069:                			switch(pgePWMDirection[eMotor])
9D004900  3C02A000   LUI V0, -24576
9D004904  8FC30014   LW V1, 20(S8)
9D004908  00031880   SLL V1, V1, 2
9D00490C  2442020C   ADDIU V0, V0, 524
9D004910  00621021   ADDU V0, V1, V0
9D004914  8C420000   LW V0, 0(V0)
9D004918  10400078   BEQ V0, ZERO, 0x9D004AFC
9D00491C  00000000   NOP
9D004920  24030001   ADDIU V1, ZERO, 1
9D004924  1043009E   BEQ V0, V1, 0x9D004BA0
9D004928  00000000   NOP
9D00492C  2403FFFF   ADDIU V1, ZERO, -1
9D004930  1443010C   BNE V0, V1, 0x9D004D64
9D004934  00000000   NOP
3070:                				{
3071:                				case PWM_DIR_REVERSE:
3072:                					AddDisplayStr("R S: ");
9D004938  3C029D00   LUI V0, -25344
9D00493C  24446678   ADDIU A0, V0, 26232
9D004940  0F402DC0   JAL AddDisplayStr
9D004944  00000000   NOP
3073:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D004948  8FC20014   LW V0, 20(S8)
9D00494C  00402021   ADDU A0, V0, ZERO
9D004950  0F401AD0   JAL CurrentSpeed_Read
9D004954  00000000   NOP
9D004958  3042FFFF   ANDI V0, V0, -1
9D00495C  00401821   ADDU V1, V0, ZERO
9D004960  27C2001C   ADDIU V0, S8, 28
9D004964  00602021   ADDU A0, V1, ZERO
9D004968  24050005   ADDIU A1, ZERO, 5
9D00496C  00403021   ADDU A2, V0, ZERO
9D004970  0F402C67   JAL WORDtoASCIIstr
9D004974  00000000   NOP
3074:                					AddDisplayStr(szfnDisplayStr);
9D004978  27C2001C   ADDIU V0, S8, 28
9D00497C  00402021   ADDU A0, V0, ZERO
9D004980  0F402DC0   JAL AddDisplayStr
9D004984  00000000   NOP
3075:                #ifdef NOTDEF
3076:                					#ifdef CALC_AVERAGE_SPEED
3077:                						AddDisplayStr(" Sa: ");
3078:                						WORDtoASCIIstr(pgwAverageSpeed, WORD_WIDTH, szfnDisplayStr);
3079:                						AddDisplayStr(szfnDisplayStr);
3080:                
3081:                						AddDisplayStr(" Sae: ");
3082:                						INT16StoASCIIstr(pgnErrorFromAverage, INT16S_WIDTH, szfnDisplayStr);
3083:                						AddDisplayStr(szfnDisplayStr);
3084:                
3085:                						AddDisplayStr(" Se: ");
3086:                						INT16StoASCIIstr(pgnErrorFromSample, INT16S_WIDTH, szfnDisplayStr);
3087:                						AddDisplayStr(szfnDisplayStr);
3088:                					#endif
3089:                
3090:                					AddDisplayStr(" S Err: ");
3091:                					INT16StoASCIIstr(pgnSpeedError, INT16S_WIDTH, szfnDisplayStr);
3092:                					AddDisplayStr(szfnDisplayStr);
3093:                
3094:                					AddDisplayStr(" PWM Corr: ");
3095:                					INT16StoASCIIstr(pgnDutyCycleCorrection, INT16S_WIDTH, szfnDisplayStr);
3096:                					AddDisplayStr(szfnDisplayStr);
3097:                #endif
3098:                
3099:                					AddDisplayStr(" P: ");
9D004988  3C029D00   LUI V0, -25344
9D00498C  24446680   ADDIU A0, V0, 26240
9D004990  0F402DC0   JAL AddDisplayStr
9D004994  00000000   NOP
3100:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004998  8FC20014   LW V0, 20(S8)
9D00499C  00402021   ADDU A0, V0, ZERO
9D0049A0  0F401B14   JAL CurrentPosition_Read
9D0049A4  00000000   NOP
9D0049A8  00401821   ADDU V1, V0, ZERO
9D0049AC  27C2001C   ADDIU V0, S8, 28
9D0049B0  00602021   ADDU A0, V1, ZERO
9D0049B4  24050006   ADDIU A1, ZERO, 6
9D0049B8  00403021   ADDU A2, V0, ZERO
9D0049BC  0F402CB7   JAL INT16StoASCIIstr
9D0049C0  00000000   NOP
3101:                					AddDisplayStr(szfnDisplayStr);
9D0049C4  27C2001C   ADDIU V0, S8, 28
9D0049C8  00402021   ADDU A0, V0, ZERO
9D0049CC  0F402DC0   JAL AddDisplayStr
9D0049D0  00000000   NOP
3102:                
3103:                					AddDisplayStr("  PWM3 DC: ");
9D0049D4  3C029D00   LUI V0, -25344
9D0049D8  244466C8   ADDIU A0, V0, 26312
9D0049DC  0F402DC0   JAL AddDisplayStr
9D0049E0  00000000   NOP
3104:                					lDutyCycle = (INT32U)OC3R / (INT32U)(PR2/100);
9D0049E4  3C02BF80   LUI V0, -16512
9D0049E8  8C443410   LW A0, 13328(V0)
9D0049EC  3C02BF80   LUI V0, -16512
9D0049F0  8C430820   LW V1, 2080(V0)
9D0049F4  3C0251EB   LUI V0, 20971
9D0049F8  3442851F   ORI V0, V0, -31457
9D0049FC  00620019   MULTU V1, V0
9D004A00  00001012   MFLO V0
9D004A04  00001810   MFHI V1
9D004A08  00031142   SRL V0, V1, 5
9D004A0C  0082001B   DIVU A0, V0
9D004A10  004001F4   TEQ V0, ZERO
9D004A14  00001810   MFHI V1
9D004A18  00001012   MFLO V0
9D004A1C  AFC20018   SW V0, 24(S8)
3105:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004A20  8FC20018   LW V0, 24(S8)
9D004A24  3042FFFF   ANDI V0, V0, -1
9D004A28  00401821   ADDU V1, V0, ZERO
9D004A2C  27C2001C   ADDIU V0, S8, 28
9D004A30  00602021   ADDU A0, V1, ZERO
9D004A34  24050003   ADDIU A1, ZERO, 3
9D004A38  00403021   ADDU A2, V0, ZERO
9D004A3C  0F402C67   JAL WORDtoASCIIstr
9D004A40  00000000   NOP
3106:                					AddDisplayStr(szfnDisplayStr);
9D004A44  27C2001C   ADDIU V0, S8, 28
9D004A48  00402021   ADDU A0, V0, ZERO
9D004A4C  0F402DC0   JAL AddDisplayStr
9D004A50  00000000   NOP
3107:                					AddDisplayStr("%");
9D004A54  3C029D00   LUI V0, -25344
9D004A58  24446694   ADDIU A0, V0, 26260
9D004A5C  0F402DC0   JAL AddDisplayStr
9D004A60  00000000   NOP
3108:                
3109:                					AddDisplayStr("  PWM4 DC: ");
9D004A64  3C029D00   LUI V0, -25344
9D004A68  244466D4   ADDIU A0, V0, 26324
9D004A6C  0F402DC0   JAL AddDisplayStr
9D004A70  00000000   NOP
3110:                					lDutyCycle = (INT32U)OC4R / (INT32U)(PR2/100);
9D004A74  3C02BF80   LUI V0, -16512
9D004A78  8C443610   LW A0, 13840(V0)
9D004A7C  3C02BF80   LUI V0, -16512
9D004A80  8C430820   LW V1, 2080(V0)
9D004A84  3C0251EB   LUI V0, 20971
9D004A88  3442851F   ORI V0, V0, -31457
9D004A8C  00620019   MULTU V1, V0
9D004A90  00001012   MFLO V0
9D004A94  00001810   MFHI V1
9D004A98  00031142   SRL V0, V1, 5
9D004A9C  0082001B   DIVU A0, V0
9D004AA0  004001F4   TEQ V0, ZERO
9D004AA4  00001810   MFHI V1
9D004AA8  00001012   MFLO V0
9D004AAC  AFC20018   SW V0, 24(S8)
3111:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004AB0  8FC20018   LW V0, 24(S8)
9D004AB4  3042FFFF   ANDI V0, V0, -1
9D004AB8  00401821   ADDU V1, V0, ZERO
9D004ABC  27C2001C   ADDIU V0, S8, 28
9D004AC0  00602021   ADDU A0, V1, ZERO
9D004AC4  24050003   ADDIU A1, ZERO, 3
9D004AC8  00403021   ADDU A2, V0, ZERO
9D004ACC  0F402C67   JAL WORDtoASCIIstr
9D004AD0  00000000   NOP
3112:                					AddDisplayStr(szfnDisplayStr);
9D004AD4  27C2001C   ADDIU V0, S8, 28
9D004AD8  00402021   ADDU A0, V0, ZERO
9D004ADC  0F402DC0   JAL AddDisplayStr
9D004AE0  00000000   NOP
3113:                					AddDisplayStr("%");
9D004AE4  3C029D00   LUI V0, -25344
9D004AE8  24446694   ADDIU A0, V0, 26260
9D004AEC  0F402DC0   JAL AddDisplayStr
9D004AF0  00000000   NOP
3114:                
3115:                					break;
9D004AF4  0B40135E   J 0x9D004D78
9D004AF8  00000000   NOP
3116:                
3117:                				case PWM_DIR_STOPPED:
3118:                					AddDisplayStr("S  S: ");
9D004AFC  3C029D00   LUI V0, -25344
9D004B00  244466A4   ADDIU A0, V0, 26276
9D004B04  0F402DC0   JAL AddDisplayStr
9D004B08  00000000   NOP
3119:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D004B0C  8FC20014   LW V0, 20(S8)
9D004B10  00402021   ADDU A0, V0, ZERO
9D004B14  0F401AD0   JAL CurrentSpeed_Read
9D004B18  00000000   NOP
9D004B1C  3042FFFF   ANDI V0, V0, -1
9D004B20  00401821   ADDU V1, V0, ZERO
9D004B24  27C2001C   ADDIU V0, S8, 28
9D004B28  00602021   ADDU A0, V1, ZERO
9D004B2C  24050005   ADDIU A1, ZERO, 5
9D004B30  00403021   ADDU A2, V0, ZERO
9D004B34  0F402C67   JAL WORDtoASCIIstr
9D004B38  00000000   NOP
3120:                					AddDisplayStr(szfnDisplayStr);
9D004B3C  27C2001C   ADDIU V0, S8, 28
9D004B40  00402021   ADDU A0, V0, ZERO
9D004B44  0F402DC0   JAL AddDisplayStr
9D004B48  00000000   NOP
3121:                					AddDisplayStr("  P: ");
9D004B4C  3C029D00   LUI V0, -25344
9D004B50  244466AC   ADDIU A0, V0, 26284
9D004B54  0F402DC0   JAL AddDisplayStr
9D004B58  00000000   NOP
3122:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004B5C  8FC20014   LW V0, 20(S8)
9D004B60  00402021   ADDU A0, V0, ZERO
9D004B64  0F401B14   JAL CurrentPosition_Read
9D004B68  00000000   NOP
9D004B6C  00401821   ADDU V1, V0, ZERO
9D004B70  27C2001C   ADDIU V0, S8, 28
9D004B74  00602021   ADDU A0, V1, ZERO
9D004B78  24050006   ADDIU A1, ZERO, 6
9D004B7C  00403021   ADDU A2, V0, ZERO
9D004B80  0F402CB7   JAL INT16StoASCIIstr
9D004B84  00000000   NOP
3123:                					AddDisplayStr(szfnDisplayStr);
9D004B88  27C2001C   ADDIU V0, S8, 28
9D004B8C  00402021   ADDU A0, V0, ZERO
9D004B90  0F402DC0   JAL AddDisplayStr
9D004B94  00000000   NOP
3124:                
3125:                					break;
9D004B98  0B40135E   J 0x9D004D78
9D004B9C  00000000   NOP
3126:                
3127:                				case PWM_DIR_FORWARD:
3128:                					AddDisplayStr("F S: ");
9D004BA0  3C029D00   LUI V0, -25344
9D004BA4  244466B4   ADDIU A0, V0, 26292
9D004BA8  0F402DC0   JAL AddDisplayStr
9D004BAC  00000000   NOP
3129:                					WORDtoASCIIstr(CurrentSpeed_Read(eMotor), WORD_WIDTH, szfnDisplayStr);
9D004BB0  8FC20014   LW V0, 20(S8)
9D004BB4  00402021   ADDU A0, V0, ZERO
9D004BB8  0F401AD0   JAL CurrentSpeed_Read
9D004BBC  00000000   NOP
9D004BC0  3042FFFF   ANDI V0, V0, -1
9D004BC4  00401821   ADDU V1, V0, ZERO
9D004BC8  27C2001C   ADDIU V0, S8, 28
9D004BCC  00602021   ADDU A0, V1, ZERO
9D004BD0  24050005   ADDIU A1, ZERO, 5
9D004BD4  00403021   ADDU A2, V0, ZERO
9D004BD8  0F402C67   JAL WORDtoASCIIstr
9D004BDC  00000000   NOP
3130:                					AddDisplayStr(szfnDisplayStr);
9D004BE0  27C2001C   ADDIU V0, S8, 28
9D004BE4  00402021   ADDU A0, V0, ZERO
9D004BE8  0F402DC0   JAL AddDisplayStr
9D004BEC  00000000   NOP
3131:                
3132:                					#ifdef CALC_AVERAGE_SPEED
3133:                						AddDisplayStr(" Sa: ");
3134:                						WORDtoASCIIstr(pgwAverageSpeed, WORD_WIDTH, szfnDisplayStr);
3135:                						AddDisplayStr(szfnDisplayStr);
3136:                
3137:                						AddDisplayStr(" Sae: ");
3138:                						INT16StoASCIIstr(pgnErrorFromAverage, INT16S_WIDTH, szfnDisplayStr);
3139:                						AddDisplayStr(szfnDisplayStr);
3140:                
3141:                						AddDisplayStr(" Se: ");
3142:                						INT16StoASCIIstr(pgnErrorFromSample, INT16S_WIDTH, szfnDisplayStr);
3143:                						AddDisplayStr(szfnDisplayStr);
3144:                					#endif
3145:                #ifdef NOTDEF
3146:                					AddDisplayStr(" S Err: ");
3147:                					INT16StoASCIIstr(pgnSpeedError, INT16S_WIDTH, szfnDisplayStr);
3148:                					AddDisplayStr(szfnDisplayStr);
3149:                
3150:                					AddDisplayStr(" PWM Corr: ");
3151:                					INT16StoASCIIstr(pgnDutyCycleCorrection, INT16S_WIDTH, szfnDisplayStr);
3152:                					AddDisplayStr(szfnDisplayStr);
3153:                #endif
3154:                					AddDisplayStr(" P: ");
9D004BF0  3C029D00   LUI V0, -25344
9D004BF4  24446680   ADDIU A0, V0, 26240
9D004BF8  0F402DC0   JAL AddDisplayStr
9D004BFC  00000000   NOP
3155:                					INT16StoASCIIstr((INT16S) CurrentPosition_Read(eMotor), INT16S_WIDTH, szfnDisplayStr);
9D004C00  8FC20014   LW V0, 20(S8)
9D004C04  00402021   ADDU A0, V0, ZERO
9D004C08  0F401B14   JAL CurrentPosition_Read
9D004C0C  00000000   NOP
9D004C10  00401821   ADDU V1, V0, ZERO
9D004C14  27C2001C   ADDIU V0, S8, 28
9D004C18  00602021   ADDU A0, V1, ZERO
9D004C1C  24050006   ADDIU A1, ZERO, 6
9D004C20  00403021   ADDU A2, V0, ZERO
9D004C24  0F402CB7   JAL INT16StoASCIIstr
9D004C28  00000000   NOP
3156:                					AddDisplayStr(szfnDisplayStr);
9D004C2C  27C2001C   ADDIU V0, S8, 28
9D004C30  00402021   ADDU A0, V0, ZERO
9D004C34  0F402DC0   JAL AddDisplayStr
9D004C38  00000000   NOP
3157:                
3158:                					AddDisplayStr("  PWM3 DC: ");
9D004C3C  3C029D00   LUI V0, -25344
9D004C40  244466C8   ADDIU A0, V0, 26312
9D004C44  0F402DC0   JAL AddDisplayStr
9D004C48  00000000   NOP
3159:                					lDutyCycle = (INT32U)OC3R / (INT32U)(PR2/100);
9D004C4C  3C02BF80   LUI V0, -16512
9D004C50  8C443410   LW A0, 13328(V0)
9D004C54  3C02BF80   LUI V0, -16512
9D004C58  8C430820   LW V1, 2080(V0)
9D004C5C  3C0251EB   LUI V0, 20971
9D004C60  3442851F   ORI V0, V0, -31457
9D004C64  00620019   MULTU V1, V0
9D004C68  00001012   MFLO V0
9D004C6C  00001810   MFHI V1
9D004C70  00031142   SRL V0, V1, 5
9D004C74  0082001B   DIVU A0, V0
9D004C78  004001F4   TEQ V0, ZERO
9D004C7C  00001810   MFHI V1
9D004C80  00001012   MFLO V0
9D004C84  AFC20018   SW V0, 24(S8)
3160:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004C88  8FC20018   LW V0, 24(S8)
9D004C8C  3042FFFF   ANDI V0, V0, -1
9D004C90  00401821   ADDU V1, V0, ZERO
9D004C94  27C2001C   ADDIU V0, S8, 28
9D004C98  00602021   ADDU A0, V1, ZERO
9D004C9C  24050003   ADDIU A1, ZERO, 3
9D004CA0  00403021   ADDU A2, V0, ZERO
9D004CA4  0F402C67   JAL WORDtoASCIIstr
9D004CA8  00000000   NOP
3161:                					AddDisplayStr(szfnDisplayStr);
9D004CAC  27C2001C   ADDIU V0, S8, 28
9D004CB0  00402021   ADDU A0, V0, ZERO
9D004CB4  0F402DC0   JAL AddDisplayStr
9D004CB8  00000000   NOP
3162:                					AddDisplayStr("%");
9D004CBC  3C029D00   LUI V0, -25344
9D004CC0  24446694   ADDIU A0, V0, 26260
9D004CC4  0F402DC0   JAL AddDisplayStr
9D004CC8  00000000   NOP
3163:                
3164:                					AddDisplayStr("  PWM4 DC: ");
9D004CCC  3C029D00   LUI V0, -25344
9D004CD0  244466D4   ADDIU A0, V0, 26324
9D004CD4  0F402DC0   JAL AddDisplayStr
9D004CD8  00000000   NOP
3165:                					lDutyCycle = (INT32U)OC4R / (INT32U)(PR2/100);
9D004CDC  3C02BF80   LUI V0, -16512
9D004CE0  8C443610   LW A0, 13840(V0)
9D004CE4  3C02BF80   LUI V0, -16512
9D004CE8  8C430820   LW V1, 2080(V0)
9D004CEC  3C0251EB   LUI V0, 20971
9D004CF0  3442851F   ORI V0, V0, -31457
9D004CF4  00620019   MULTU V1, V0
9D004CF8  00001012   MFLO V0
9D004CFC  00001810   MFHI V1
9D004D00  00031142   SRL V0, V1, 5
9D004D04  0082001B   DIVU A0, V0
9D004D08  004001F4   TEQ V0, ZERO
9D004D0C  00001810   MFHI V1
9D004D10  00001012   MFLO V0
9D004D14  AFC20018   SW V0, 24(S8)
3166:                					WORDtoASCIIstr((INT16U)lDutyCycle, BYTE_WIDTH, szfnDisplayStr);				// note that we can limit the width to just 3 characters
9D004D18  8FC20018   LW V0, 24(S8)
9D004D1C  3042FFFF   ANDI V0, V0, -1
9D004D20  00401821   ADDU V1, V0, ZERO
9D004D24  27C2001C   ADDIU V0, S8, 28
9D004D28  00602021   ADDU A0, V1, ZERO
9D004D2C  24050003   ADDIU A1, ZERO, 3
9D004D30  00403021   ADDU A2, V0, ZERO
9D004D34  0F402C67   JAL WORDtoASCIIstr
9D004D38  00000000   NOP
3167:                					AddDisplayStr(szfnDisplayStr);
9D004D3C  27C2001C   ADDIU V0, S8, 28
9D004D40  00402021   ADDU A0, V0, ZERO
9D004D44  0F402DC0   JAL AddDisplayStr
9D004D48  00000000   NOP
3168:                					AddDisplayStr("%");
9D004D4C  3C029D00   LUI V0, -25344
9D004D50  24446694   ADDIU A0, V0, 26260
9D004D54  0F402DC0   JAL AddDisplayStr
9D004D58  00000000   NOP
3169:                
3170:                					break;
9D004D5C  0B40135E   J 0x9D004D78
9D004D60  00000000   NOP
3171:                				case PWM_DIR_UNKNOWN:
3172:                
3173:                				default:
3174:                					AddDisplayStr("?  ");
9D004D64  3C029D00   LUI V0, -25344
9D004D68  244466BC   ADDIU A0, V0, 26300
9D004D6C  0F402DC0   JAL AddDisplayStr
9D004D70  00000000   NOP
3175:                					break;
9D004D74  00000000   NOP
3176:                				}
3177:                
3178:                
3179:                			// DEBUG_PIN1_LOW;
3180:                			eStreamLine = STREAM_LINE;					// mark display of {some} line of data
9D004D78  24020001   ADDIU V0, ZERO, 1
9D004D7C  AF82811C   SW V0, -32484(GP)
3181:                
3182:                			bRetVal = TRUE;								// always returns true; no limit to available data
9D004D80  24020001   ADDIU V0, ZERO, 1
9D004D84  AFC20010   SW V0, 16(S8)
3183:                			}
3184:                			break;
9D004D88  0B4013C0   J 0x9D004F00
9D004D8C  00000000   NOP
3185:                
3186:                
3187:                		case INPUT_SWITCH_STATUS:
3188:                			{
3189:                			// display current state of input switches, debounced switch events
3190:                			AddDisplayStr("Raw Input Pins: ");
9D004D90  3C029D00   LUI V0, -25344
9D004D94  2444662C   ADDIU A0, V0, 26156
9D004D98  0F402DC0   JAL AddDisplayStr
9D004D9C  00000000   NOP
3191:                			BYTEtoHexASCIIstr(GetInputSwitchState(), szfnDisplayStr);		// this actually reads the hardware
9D004DA0  0F403521   JAL GetInputSwitchState
9D004DA4  00000000   NOP
9D004DA8  00401821   ADDU V1, V0, ZERO
9D004DAC  27C2001C   ADDIU V0, S8, 28
9D004DB0  00602021   ADDU A0, V1, ZERO
9D004DB4  00402821   ADDU A1, V0, ZERO
9D004DB8  0F402BFC   JAL BYTEtoHexASCIIstr
9D004DBC  00000000   NOP
3192:                			AddDisplayStr(szfnDisplayStr);
9D004DC0  27C2001C   ADDIU V0, S8, 28
9D004DC4  00402021   ADDU A0, V0, ZERO
9D004DC8  0F402DC0   JAL AddDisplayStr
9D004DCC  00000000   NOP
3193:                
3194:                			AddDisplayStr("\tDebounced Events: ");
9D004DD0  3C029D00   LUI V0, -25344
9D004DD4  24446640   ADDIU A0, V0, 26176
9D004DD8  0F402DC0   JAL AddDisplayStr
9D004DDC  00000000   NOP
3195:                			WORDtoHexASCIIstr(efSwitchEvents, szfnDisplayStr);				// event flags are 16 bit words
9D004DE0  978280EC   LHU V0, -32532(GP)
9D004DE4  00401821   ADDU V1, V0, ZERO
9D004DE8  27C2001C   ADDIU V0, S8, 28
9D004DEC  00602021   ADDU A0, V1, ZERO
9D004DF0  00402821   ADDU A1, V0, ZERO
9D004DF4  0F402C22   JAL WORDtoHexASCIIstr
9D004DF8  00000000   NOP
3196:                			AddDisplayStr(szfnDisplayStr);
9D004DFC  27C2001C   ADDIU V0, S8, 28
9D004E00  00402021   ADDU A0, V0, ZERO
9D004E04  0F402DC0   JAL AddDisplayStr
9D004E08  00000000   NOP
3197:                			eStreamLine = STREAM_LINE;					// mark display of {some} line of data
9D004E0C  24020001   ADDIU V0, ZERO, 1
9D004E10  AF82811C   SW V0, -32484(GP)
3198:                
3199:                			bRetVal = TRUE;								// always returns true; no limit to available data
9D004E14  24020001   ADDIU V0, ZERO, 1
9D004E18  AFC20010   SW V0, 16(S8)
3200:                			}
3201:                			break;
9D004E1C  0B4013C0   J 0x9D004F00
9D004E20  00000000   NOP
3202:                
3203:                		case RUNTIME_ERROR_STATUS:
3204:                			{
3205:                			// display the contents of the runtime error buffer
3206:                			// note that we do not actually remove anything from the buffer; we just bump a display index that is initialized to 0
3207:                			if ((gwErrorDisplayIndex < ERROR_BUFFER_SIZE) AND (pgbRuntimeErrorBuffer[gwErrorDisplayIndex] IS_NOT ZERO))
9D004E24  97828104   LHU V0, -32508(GP)
9D004E28  2C420100   SLTIU V0, V0, 256
9D004E2C  10400027   BEQ V0, ZERO, 0x9D004ECC
9D004E30  00000000   NOP
9D004E34  97828104   LHU V0, -32508(GP)
9D004E38  00401821   ADDU V1, V0, ZERO
9D004E3C  3C02A000   LUI V0, -24576
9D004E40  2442058C   ADDIU V0, V0, 1420
9D004E44  00621021   ADDU V0, V1, V0
9D004E48  90420000   LBU V0, 0(V0)
9D004E4C  1040001F   BEQ V0, ZERO, 0x9D004ECC
9D004E50  00000000   NOP
3208:                				{
3209:                				eStreamLine = STREAM_LINE;				// mark display of {some} line of data
9D004E54  24020001   ADDIU V0, ZERO, 1
9D004E58  AF82811C   SW V0, -32484(GP)
3210:                
3211:                				AddDisplayStr("0x");					// leading characters
9D004E5C  3C029D00   LUI V0, -25344
9D004E60  244466E0   ADDIU A0, V0, 26336
9D004E64  0F402DC0   JAL AddDisplayStr
9D004E68  00000000   NOP
3212:                				BYTEtoHexASCIIstr(pgbRuntimeErrorBuffer[gwErrorDisplayIndex], szfnDisplayStr);
9D004E6C  97828104   LHU V0, -32508(GP)
9D004E70  00401821   ADDU V1, V0, ZERO
9D004E74  3C02A000   LUI V0, -24576
9D004E78  2442058C   ADDIU V0, V0, 1420
9D004E7C  00621021   ADDU V0, V1, V0
9D004E80  90420000   LBU V0, 0(V0)
9D004E84  00401821   ADDU V1, V0, ZERO
9D004E88  27C2001C   ADDIU V0, S8, 28
9D004E8C  00602021   ADDU A0, V1, ZERO
9D004E90  00402821   ADDU A1, V0, ZERO
9D004E94  0F402BFC   JAL BYTEtoHexASCIIstr
9D004E98  00000000   NOP
3213:                				AddDisplayStr(szfnDisplayStr);
9D004E9C  27C2001C   ADDIU V0, S8, 28
9D004EA0  00402021   ADDU A0, V0, ZERO
9D004EA4  0F402DC0   JAL AddDisplayStr
9D004EA8  00000000   NOP
3214:                
3215:                				++gwErrorDisplayIndex;					// bump display index
9D004EAC  97828104   LHU V0, -32508(GP)
9D004EB0  24420001   ADDIU V0, V0, 1
9D004EB4  3042FFFF   ANDI V0, V0, -1
9D004EB8  A7828104   SH V0, -32508(GP)
3216:                				bRetVal = TRUE;							// data to display
9D004EBC  24020001   ADDIU V0, ZERO, 1
9D004EC0  AFC20010   SW V0, 16(S8)
3217:                				}
3218:                			else
3219:                				{
3220:                				eStreamLine = STREAM_LAST_LINE;			// mark display of LAST line of available data
9D004ECC  24020002   ADDIU V0, ZERO, 2
9D004ED0  AF82811C   SW V0, -32484(GP)
3221:                
3222:                				AddDisplayStr(" -end-");				// really not a good way to do things; does not wait for completion
9D004ED4  3C029D00   LUI V0, -25344
9D004ED8  244466E4   ADDIU A0, V0, 26340
9D004EDC  0F402DC0   JAL AddDisplayStr
9D004EE0  00000000   NOP
3223:                
3224:                				ResetRuntimeError();					// reset the buffer pointer; has the effect of clearing the Runtime Error buffer
9D004EE4  0F403680   JAL ResetRuntimeError
9D004EE8  00000000   NOP
3225:                
3226:                				bRetVal = FALSE;						// no more data to display
9D004EEC  AFC00010   SW ZERO, 16(S8)
3227:                				}
3228:                			}
3229:                			break;
9D004EC4  0B4013C0   J 0x9D004F00
9D004EC8  00000000   NOP
9D004EF0  0B4013C0   J 0x9D004F00
9D004EF4  00000000   NOP
3230:                
3231:                		default:
3232:                			bRetVal = FALSE;							// no more data to display
9D004EF8  AFC00010   SW ZERO, 16(S8)
3233:                			break;
9D004EFC  00000000   NOP
3234:                
3235:                		}			// end switch
3236:                
3237:                	AddDisplayNewLine();								// add line terminator
9D004F00  0F402E24   JAL AddDisplayNewLine
9D004F04  00000000   NOP
3238:                
3239:                	DisplayStr(UARTid);										// start display (serial output) of line
9D004F08  8FC40078   LW A0, 120(S8)
9D004F0C  0F402E32   JAL DisplayStr
9D004F10  00000000   NOP
3240:                
3241:                	return bRetVal;										// TRUE if more data to display, FALSE if last line
9D004F14  8FC20010   LW V0, 16(S8)
3242:                }
9D004F18  03C0E821   ADDU SP, S8, ZERO
9D004F1C  8FBF0074   LW RA, 116(SP)
9D004F20  8FBE0070   LW S8, 112(SP)
9D004F24  27BD0078   ADDIU SP, SP, 120
9D004F28  03E00008   JR RA
9D004F2C  00000000   NOP
3243:                
3244:                // at the present time, only parameters related to Endpoint operation are updated
3245:                
3246:                BOOL UpdateParameter(enum tagParameter eParameterToUpdate)
3247:                {
9D004F30  27BDFFD0   ADDIU SP, SP, -48
9D004F34  AFBF002C   SW RA, 44(SP)
9D004F38  AFBE0028   SW S8, 40(SP)
9D004F3C  AFB00024   SW S0, 36(SP)
9D004F40  03A0F021   ADDU S8, SP, ZERO
9D004F44  AFC40030   SW A0, 48(S8)
3248:                
3249:                	UINT8 bParameterValue;
3250:                	UINT16 nParameterValue;
3251:                	double fParameterValue;
3252:                	BOOL bValueValid = TRUE;
9D004F48  24020001   ADDIU V0, ZERO, 1
9D004F4C  AFC20010   SW V0, 16(S8)
3253:                
3254:                	ClearDisplayStr();											// initialize output buffer for possible serial output string
9D004F50  0F402DB6   JAL ClearDisplayStr
9D004F54  00000000   NOP
3255:                
3256:                	switch(eParameterToUpdate)
9D004F58  8FC20030   LW V0, 48(S8)
9D004F5C  2C42000A   SLTIU V0, V0, 10
9D004F60  10400136   BEQ V0, ZERO, 0x9D00543C
9D004F64  00000000   NOP
9D004F68  8FC20030   LW V0, 48(S8)
9D004F6C  00021880   SLL V1, V0, 2
9D004F70  3C029D00   LUI V0, -25344
9D004F74  24424F88   ADDIU V0, V0, 20360
9D004F78  00621021   ADDU V0, V1, V0
9D004F7C  8C420000   LW V0, 0(V0)
9D004F80  00400008   JR V0
9D004F84  00000000   NOP
3257:                	{
3258:                		case PARAMETER_LATITUDE:
3259:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D004FB0  3C02A000   LUI V0, -24576
9D004FB4  24440470   ADDIU A0, V0, 1136
9D004FB8  0F4039B9   JAL atof
9D004FBC  00000000   NOP
9D004FC0  AFC20014   SW V0, 20(S8)
3260:                
3261:                			// bounds check
3262:                			if ((fParameterValue >= MIN_LATITUDE) AND (fParameterValue <= MAX_LATITUDE))
9D004FC4  24100001   ADDIU S0, ZERO, 1
9D004FC8  3C029D00   LUI V0, -25344
9D004FCC  8C4466EC   LW A0, 26348(V0)
9D004FD0  8FC50014   LW A1, 20(S8)
9D004FD4  0F402BA6   JAL __lesf2
9D004FD8  00000000   NOP
9D004FDC  18400002   BLEZ V0, 0x9D004FE8
9D004FE0  00000000   NOP
9D004FE4  00008021   ADDU S0, ZERO, ZERO
9D004FE8  320200FF   ANDI V0, S0, 255
9D004FEC  10400012   BEQ V0, ZERO, 0x9D005038
9D004FF0  00000000   NOP
9D004FF4  24100001   ADDIU S0, ZERO, 1
9D004FF8  3C029D00   LUI V0, -25344
9D004FFC  8FC40014   LW A0, 20(S8)
9D005000  8C4566F0   LW A1, 26352(V0)
9D005004  0F402BA6   JAL __lesf2
9D005008  00000000   NOP
9D00500C  18400002   BLEZ V0, 0x9D005018
9D005010  00000000   NOP
9D005014  00008021   ADDU S0, ZERO, ZERO
9D005018  320200FF   ANDI V0, S0, 255
9D00501C  10400006   BEQ V0, ZERO, 0x9D005038
9D005020  00000000   NOP
3263:                				{
3264:                				ptrRAM_SystemParameters->fLatitude = (float)fParameterValue;
9D005024  8F828010   LW V0, -32752(GP)
9D005028  8FC30014   LW V1, 20(S8)
9D00502C  AC430004   SW V1, 4(V0)
3265:                				}
3266:                			else
3267:                				{
3268:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D005038  24040038   ADDIU A0, ZERO, 56
9D00503C  0F40365E   JAL _RuntimeError
9D005040  00000000   NOP
3269:                				bValueValid = FALSE;							// not a valid entry
9D005044  AFC00010   SW ZERO, 16(S8)
3270:                				}
3271:                			break;
9D005030  0B401519   J 0x9D005464
9D005034  00000000   NOP
9D005048  0B401519   J 0x9D005464
9D00504C  00000000   NOP
3272:                
3273:                		case PARAMETER_LONGITUDE:
3274:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D005050  3C02A000   LUI V0, -24576
9D005054  24440470   ADDIU A0, V0, 1136
9D005058  0F4039B9   JAL atof
9D00505C  00000000   NOP
9D005060  AFC20014   SW V0, 20(S8)
3275:                
3276:                			// bounds check
3277:                			if ((fParameterValue >= MIN_LONGITUDE) AND (fParameterValue <= MAX_LONGITUDE))
9D005064  24100001   ADDIU S0, ZERO, 1
9D005068  3C029D00   LUI V0, -25344
9D00506C  8C4466F4   LW A0, 26356(V0)
9D005070  8FC50014   LW A1, 20(S8)
9D005074  0F402BA6   JAL __lesf2
9D005078  00000000   NOP
9D00507C  18400002   BLEZ V0, 0x9D005088
9D005080  00000000   NOP
9D005084  00008021   ADDU S0, ZERO, ZERO
9D005088  320200FF   ANDI V0, S0, 255
9D00508C  10400012   BEQ V0, ZERO, 0x9D0050D8
9D005090  00000000   NOP
9D005094  24100001   ADDIU S0, ZERO, 1
9D005098  3C029D00   LUI V0, -25344
9D00509C  8FC40014   LW A0, 20(S8)
9D0050A0  8C4566F8   LW A1, 26360(V0)
9D0050A4  0F402BA6   JAL __lesf2
9D0050A8  00000000   NOP
9D0050AC  18400002   BLEZ V0, 0x9D0050B8
9D0050B0  00000000   NOP
9D0050B4  00008021   ADDU S0, ZERO, ZERO
9D0050B8  320200FF   ANDI V0, S0, 255
9D0050BC  10400006   BEQ V0, ZERO, 0x9D0050D8
9D0050C0  00000000   NOP
3278:                				{
3279:                				ptrRAM_SystemParameters->fLongitude = (float)fParameterValue;
9D0050C4  8F828010   LW V0, -32752(GP)
9D0050C8  8FC30014   LW V1, 20(S8)
9D0050CC  AC430008   SW V1, 8(V0)
3280:                				}
3281:                			else
3282:                				{
3283:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D0050D8  24040038   ADDIU A0, ZERO, 56
9D0050DC  0F40365E   JAL _RuntimeError
9D0050E0  00000000   NOP
3284:                				bValueValid = FALSE;							// not a valid entry
9D0050E4  AFC00010   SW ZERO, 16(S8)
3285:                				}
3286:                			break;
9D0050D0  0B401519   J 0x9D005464
9D0050D4  00000000   NOP
9D0050E8  0B401519   J 0x9D005464
9D0050EC  00000000   NOP
3287:                
3288:                		case PARAMETER_ELEVATION:
3289:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D0050F0  3C02A000   LUI V0, -24576
9D0050F4  24440470   ADDIU A0, V0, 1136
9D0050F8  0F4039B9   JAL atof
9D0050FC  00000000   NOP
9D005100  AFC20014   SW V0, 20(S8)
3290:                
3291:                			// bounds check
3292:                			if ((fParameterValue >= MIN_ELEVATION) AND (fParameterValue <= MAX_ELEVATION))
9D005104  24100001   ADDIU S0, ZERO, 1
9D005108  3C029D00   LUI V0, -25344
9D00510C  8C4466FC   LW A0, 26364(V0)
9D005110  8FC50014   LW A1, 20(S8)
9D005114  0F402BA6   JAL __lesf2
9D005118  00000000   NOP
9D00511C  18400002   BLEZ V0, 0x9D005128
9D005120  00000000   NOP
9D005124  00008021   ADDU S0, ZERO, ZERO
9D005128  320200FF   ANDI V0, S0, 255
9D00512C  10400012   BEQ V0, ZERO, 0x9D005178
9D005130  00000000   NOP
9D005134  24100001   ADDIU S0, ZERO, 1
9D005138  3C029D00   LUI V0, -25344
9D00513C  8FC40014   LW A0, 20(S8)
9D005140  8C456700   LW A1, 26368(V0)
9D005144  0F402BA6   JAL __lesf2
9D005148  00000000   NOP
9D00514C  18400002   BLEZ V0, 0x9D005158
9D005150  00000000   NOP
9D005154  00008021   ADDU S0, ZERO, ZERO
9D005158  320200FF   ANDI V0, S0, 255
9D00515C  10400006   BEQ V0, ZERO, 0x9D005178
9D005160  00000000   NOP
3293:                				{
3294:                				ptrRAM_SystemParameters->fElevation = (float)fParameterValue;
9D005164  8F828010   LW V0, -32752(GP)
9D005168  8FC30014   LW V1, 20(S8)
9D00516C  AC43000C   SW V1, 12(V0)
3295:                				}
3296:                			else
3297:                				{
3298:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D005178  24040038   ADDIU A0, ZERO, 56
9D00517C  0F40365E   JAL _RuntimeError
9D005180  00000000   NOP
3299:                				bValueValid = FALSE;							// not a valid entry
9D005184  AFC00010   SW ZERO, 16(S8)
3300:                				}
3301:                			break;
9D005170  0B401519   J 0x9D005464
9D005174  00000000   NOP
9D005188  0B401519   J 0x9D005464
9D00518C  00000000   NOP
3302:                
3303:                		case PARAMETER_REFRACTION:
3304:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D005190  3C02A000   LUI V0, -24576
9D005194  24440470   ADDIU A0, V0, 1136
9D005198  0F4039B9   JAL atof
9D00519C  00000000   NOP
9D0051A0  AFC20014   SW V0, 20(S8)
3305:                
3306:                			// bounds check
3307:                			if ((fParameterValue >= MIN_REFRACTION) AND (fParameterValue <= MAX_REFRACTION))
9D0051A4  24100001   ADDIU S0, ZERO, 1
9D0051A8  00002021   ADDU A0, ZERO, ZERO
9D0051AC  8FC50014   LW A1, 20(S8)
9D0051B0  0F402BA6   JAL __lesf2
9D0051B4  00000000   NOP
9D0051B8  18400002   BLEZ V0, 0x9D0051C4
9D0051BC  00000000   NOP
9D0051C0  00008021   ADDU S0, ZERO, ZERO
9D0051C4  320200FF   ANDI V0, S0, 255
9D0051C8  10400012   BEQ V0, ZERO, 0x9D005214
9D0051CC  00000000   NOP
9D0051D0  24100001   ADDIU S0, ZERO, 1
9D0051D4  3C029D00   LUI V0, -25344
9D0051D8  8FC40014   LW A0, 20(S8)
9D0051DC  8C456704   LW A1, 26372(V0)
9D0051E0  0F402BA6   JAL __lesf2
9D0051E4  00000000   NOP
9D0051E8  18400002   BLEZ V0, 0x9D0051F4
9D0051EC  00000000   NOP
9D0051F0  00008021   ADDU S0, ZERO, ZERO
9D0051F4  320200FF   ANDI V0, S0, 255
9D0051F8  10400006   BEQ V0, ZERO, 0x9D005214
9D0051FC  00000000   NOP
3308:                				{
3309:                				ptrRAM_SystemParameters->fRefraction = (float)fParameterValue;
9D005200  8F828010   LW V0, -32752(GP)
9D005204  8FC30014   LW V1, 20(S8)
9D005208  AC430010   SW V1, 16(V0)
3310:                				}
3311:                			else
3312:                				{
3313:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D005214  24040038   ADDIU A0, ZERO, 56
9D005218  0F40365E   JAL _RuntimeError
9D00521C  00000000   NOP
3314:                				bValueValid = FALSE;							// not a valid entry
9D005220  AFC00010   SW ZERO, 16(S8)
3315:                				}
3316:                			break;
9D00520C  0B401519   J 0x9D005464
9D005210  00000000   NOP
9D005224  0B401519   J 0x9D005464
9D005228  00000000   NOP
3317:                
3318:                		case PARAMETER_TIMEZONE:
3319:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D00522C  3C02A000   LUI V0, -24576
9D005230  24440470   ADDIU A0, V0, 1136
9D005234  0F4039B9   JAL atof
9D005238  00000000   NOP
9D00523C  AFC20014   SW V0, 20(S8)
3320:                
3321:                			// bounds check
3322:                			if ((fParameterValue >= MIN_TIMEZONE) AND (fParameterValue <= MAX_TIMEZONE))
9D005240  24100001   ADDIU S0, ZERO, 1
9D005244  3C029D00   LUI V0, -25344
9D005248  8C446708   LW A0, 26376(V0)
9D00524C  8FC50014   LW A1, 20(S8)
9D005250  0F402BA6   JAL __lesf2
9D005254  00000000   NOP
9D005258  18400002   BLEZ V0, 0x9D005264
9D00525C  00000000   NOP
9D005260  00008021   ADDU S0, ZERO, ZERO
9D005264  320200FF   ANDI V0, S0, 255
9D005268  10400012   BEQ V0, ZERO, 0x9D0052B4
9D00526C  00000000   NOP
9D005270  24100001   ADDIU S0, ZERO, 1
9D005274  3C029D00   LUI V0, -25344
9D005278  8FC40014   LW A0, 20(S8)
9D00527C  8C45670C   LW A1, 26380(V0)
9D005280  0F402BA6   JAL __lesf2
9D005284  00000000   NOP
9D005288  18400002   BLEZ V0, 0x9D005294
9D00528C  00000000   NOP
9D005290  00008021   ADDU S0, ZERO, ZERO
9D005294  320200FF   ANDI V0, S0, 255
9D005298  10400006   BEQ V0, ZERO, 0x9D0052B4
9D00529C  00000000   NOP
3323:                				{
3324:                				ptrRAM_SystemParameters->fTimeZone = (float)fParameterValue;
9D0052A0  8F828010   LW V0, -32752(GP)
9D0052A4  8FC30014   LW V1, 20(S8)
9D0052A8  AC430014   SW V1, 20(V0)
3325:                				}
3326:                			else
3327:                				{
3328:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D0052B4  24040038   ADDIU A0, ZERO, 56
9D0052B8  0F40365E   JAL _RuntimeError
9D0052BC  00000000   NOP
3329:                				bValueValid = FALSE;							// not a valid entry
9D0052C0  AFC00010   SW ZERO, 16(S8)
3330:                				}
3331:                			break;
9D0052AC  0B401519   J 0x9D005464
9D0052B0  00000000   NOP
9D0052C4  0B401519   J 0x9D005464
9D0052C8  00000000   NOP
3332:                
3333:                		case PARAMETER_TRACKER_STATE:
3334:                			bParameterValue = (UINT8)atoi(pgcInputBuffer);		// convert input string to BYTE
9D0052CC  3C02A000   LUI V0, -24576
9D0052D0  24440470   ADDIU A0, V0, 1136
9D0052D4  0F403782   JAL atoi
9D0052D8  00000000   NOP
9D0052DC  A3C20018   SB V0, 24(S8)
3335:                
3336:                			// bounds check
3337:                			if ((bParameterValue >= POS_TRACKING) AND (bParameterValue <= POS_WIND_STOW))
9D0052E0  93C20018   LBU V0, 24(S8)
9D0052E4  2C420003   SLTIU V0, V0, 3
9D0052E8  10400006   BEQ V0, ZERO, 0x9D005304
9D0052EC  00000000   NOP
3338:                				{
3339:                				ptrRAM_SystemParameters->ucTracker_State = bParameterValue;
9D0052F0  8F828010   LW V0, -32752(GP)
9D0052F4  93C30018   LBU V1, 24(S8)
9D0052F8  A0430080   SB V1, 128(V0)
3340:                				}
3341:                			else
3342:                				{
3343:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D005304  24040038   ADDIU A0, ZERO, 56
9D005308  0F40365E   JAL _RuntimeError
9D00530C  00000000   NOP
3344:                				bValueValid = FALSE;							// not a valid entry
9D005310  AFC00010   SW ZERO, 16(S8)
3345:                				}
3346:                			break;
9D0052FC  0B401519   J 0x9D005464
9D005300  00000000   NOP
9D005314  0B401519   J 0x9D005464
9D005318  00000000   NOP
3347:                
3348:                		case PARAMETER_ELEVATION_DUTY_CYCLE:
3349:                			nParameterValue = (UINT16)atoi(pgcInputBuffer);		// convert input string to UIN16
9D00531C  3C02A000   LUI V0, -24576
9D005320  24440470   ADDIU A0, V0, 1136
9D005324  0F403782   JAL atoi
9D005328  00000000   NOP
9D00532C  A7C2001A   SH V0, 26(S8)
3350:                
3351:                			if (PWM_SetDutyCycle(MOTOR_ELEVATION, nParameterValue) IS_NOT TRUE)
9D005330  97C2001A   LHU V0, 26(S8)
9D005334  24040001   ADDIU A0, ZERO, 1
9D005338  00402821   ADDU A1, V0, ZERO
9D00533C  0F402671   JAL PWM_SetDutyCycle
9D005340  00000000   NOP
9D005344  00401821   ADDU V1, V0, ZERO
9D005348  24020001   ADDIU V0, ZERO, 1
9D00534C  10620041   BEQ V1, V0, 0x9D005454
9D005350  00000000   NOP
3352:                				{
3353:                				bValueValid = FALSE;							// not a valid entry
9D005354  AFC00010   SW ZERO, 16(S8)
3354:                				}
3355:                			break;
9D005358  0B401519   J 0x9D005464
9D00535C  00000000   NOP
9D005454  00000000   NOP
9D005458  0B401519   J 0x9D005464
9D00545C  00000000   NOP
3356:                
3357:                		case PARAMETER_AZIMUTH_DUTY_CYCLE:
3358:                			nParameterValue = (UINT16)atoi(pgcInputBuffer);		// convert input string to UIN16
9D005360  3C02A000   LUI V0, -24576
9D005364  24440470   ADDIU A0, V0, 1136
9D005368  0F403782   JAL atoi
9D00536C  00000000   NOP
9D005370  A7C2001A   SH V0, 26(S8)
3359:                
3360:                			if (PWM_SetDutyCycle(MOTOR_AZIMUTH, nParameterValue) IS_NOT TRUE)
9D005374  97C2001A   LHU V0, 26(S8)
9D005378  00002021   ADDU A0, ZERO, ZERO
9D00537C  00402821   ADDU A1, V0, ZERO
9D005380  0F402671   JAL PWM_SetDutyCycle
9D005384  00000000   NOP
9D005388  00401821   ADDU V1, V0, ZERO
9D00538C  24020001   ADDIU V0, ZERO, 1
9D005390  10620033   BEQ V1, V0, 0x9D005460
9D005394  00000000   NOP
3361:                				{
3362:                				bValueValid = FALSE;							// not a valid entry
9D005398  AFC00010   SW ZERO, 16(S8)
3363:                				}
3364:                			break;
9D00539C  0B401519   J 0x9D005464
9D0053A0  00000000   NOP
9D005460  00000000   NOP
3365:                
3366:                
3367:                		case PARAMETER_MOVE_DISTANCE:
3368:                			fParameterValue = atof(pgcInputBuffer);				// convert input string to float
9D0053A4  3C02A000   LUI V0, -24576
9D0053A8  24440470   ADDIU A0, V0, 1136
9D0053AC  0F4039B9   JAL atof
9D0053B0  00000000   NOP
9D0053B4  AFC20014   SW V0, 20(S8)
3369:                
3370:                			// bounds check
3371:                			if ((fParameterValue >= 0.0) AND (fParameterValue <= 90.0))
9D0053B8  24100001   ADDIU S0, ZERO, 1
9D0053BC  00002021   ADDU A0, ZERO, ZERO
9D0053C0  8FC50014   LW A1, 20(S8)
9D0053C4  0F402BA6   JAL __lesf2
9D0053C8  00000000   NOP
9D0053CC  18400002   BLEZ V0, 0x9D0053D8
9D0053D0  00000000   NOP
9D0053D4  00008021   ADDU S0, ZERO, ZERO
9D0053D8  320200FF   ANDI V0, S0, 255
9D0053DC  10400011   BEQ V0, ZERO, 0x9D005424
9D0053E0  00000000   NOP
9D0053E4  24100001   ADDIU S0, ZERO, 1
9D0053E8  3C029D00   LUI V0, -25344
9D0053EC  8FC40014   LW A0, 20(S8)
9D0053F0  8C4566F0   LW A1, 26352(V0)
9D0053F4  0F402BA6   JAL __lesf2
9D0053F8  00000000   NOP
9D0053FC  18400002   BLEZ V0, 0x9D005408
9D005400  00000000   NOP
9D005404  00008021   ADDU S0, ZERO, ZERO
9D005408  320200FF   ANDI V0, S0, 255
9D00540C  10400005   BEQ V0, ZERO, 0x9D005424
9D005410  00000000   NOP
3372:                				{
3373:                				fgfCLMoveDistance = (float)fParameterValue;
9D005414  8FC20014   LW V0, 20(S8)
9D005418  AF828100   SW V0, -32512(GP)
3374:                				}
3375:                			else
3376:                				{
3377:                				RuntimeError(MENU_FSM_ERROR_OUT_OF_RANGE_PARAMETER);
9D005424  24040038   ADDIU A0, ZERO, 56
9D005428  0F40365E   JAL _RuntimeError
9D00542C  00000000   NOP
3378:                				bValueValid = FALSE;							// not a valid entry
9D005430  AFC00010   SW ZERO, 16(S8)
3379:                				}
3380:                			break;
9D00541C  0B401519   J 0x9D005464
9D005420  00000000   NOP
9D005434  0B401519   J 0x9D005464
9D005438  00000000   NOP
3381:                
3382:                
3383:                		case PARAMETER_NONE:
3384:                		default:
3385:                			RuntimeError(MENU_FSM_ERROR_INVALID_PARAMETER);
9D00543C  24040037   ADDIU A0, ZERO, 55
9D005440  0F40365E   JAL _RuntimeError
9D005444  00000000   NOP
3386:                			bValueValid = FALSE;								// not a valid entry
9D005448  AFC00010   SW ZERO, 16(S8)
3387:                			break;
9D00544C  0B401519   J 0x9D005464
9D005450  00000000   NOP
3388:                	}
3389:                
3390:                	return(bValueValid);
9D005464  8FC20010   LW V0, 16(S8)
3391:                
3392:                }
9D005468  03C0E821   ADDU SP, S8, ZERO
9D00546C  8FBF002C   LW RA, 44(SP)
9D005470  8FBE0028   LW S8, 40(SP)
9D005474  8FB00024   LW S0, 36(SP)
9D005478  27BD0030   ADDIU SP, SP, 48
9D00547C  03E00008   JR RA
9D005480  00000000   NOP
3393:                
3394:                
3395:                
3396:                // end of MenuFSM.c
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/Debug.c  -------------------------
1:                   //*************************************************************************************************
2:                   //										D e b u g . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Debug Runtime Error Handler functions
8:                   //
9:                   //		001	15 Feb 13 <sek> created from gsf Code Base
10:                  //
11:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
12:                  //					gsf Engineering	978-927-7189
13:                  //					Beverly, MA 01915
14:                  //
15:                  //		copyright (c) 2013 gsf Engineering
16:                  //
17:                  //*************************************************************************************************
18:                  
19:                  //-----------------------------------------------------------------------------
20:                  // #include files
21:                  //-----------------------------------------------------------------------------
22:                  #include <GenericTypeDefs.h>
23:                  
24:                  // processor include file
25:                  //lint -e765					error 765: (Info -- external function could be made static)
26:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
27:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
28:                  //lint +e14
29:                  
30:                  #include "gsfstd.h"				// gsf standard #defines
31:                  
32:                  #include "Debug.h"
33:                  #include "SmartTrak.h"			// Project wide definitions
34:                  #include "HardwareProfile.h"
35:                  
36:                  //#include "init.h"				// port definitions and initialization state
37:                  #ifdef DEFINE_GLOBALS
38:                  	#error "DEFINE_GLOBALS not expected here"
39:                  #endif
40:                  
41:                  //-------------------------------------------------------------------------------------------------------
42:                  // Definitions
43:                  //-------------------------------------------------------------------------------------------------------
44:                  
45:                  enum tagDebugErrors
46:                  {
47:                  	DEBUG_ERROR_NONE = DEBUG_ERROR_BASE,// 0
48:                  	DEBUG_UNEXPECTED_TICK,				// 1 unexpected timer tick event
49:                  	DEBUG_ERROR_UNEXPECTED_EVENT,		// 2 unexpected event
50:                  	DEBUG_ERROR_INVALID_STATE,			// 3 not a valid state
51:                  	DEBUG_ERROR_INVALID_SUBSTATE,		// 4 not a valid state
52:                  	DEBUG_ERROR_INVALID_LED_SEQUENCE,	// 5 not a LED sequence number
53:                  	DEBUG_ERROR_STACK_OVERFLOW,			// 6 stack overflow
54:                  
55:                  	DEBUG_UNPROCESSED_EVENT = DEBUG_ERROR_BASE + 0x0F
56:                  };
57:                  
58:                  
59:                  //-------------------------------------------------------------------------------------------------------
60:                  // Static Variables
61:                  //-------------------------------------------------------------------------------------------------------
62:                  
63:                  #ifdef DEBUG_LEDS
64:                  	PRIVATE_INIT BYTE bDebugSequenceCtr1 = 0;			// LED sequence index
65:                  	PRIVATE_INIT BYTE bDebugSequenceCtr2 = 0;
66:                  
67:                  	PRIVATE_INIT INT32U ulDebugLED1Sequence = 0L;
68:                  	PRIVATE_INIT INT32U ulDebugLED2Sequence = 0L;
69:                  #endif	// #ifdef DEBUG_LEDS
70:                  
71:                  #ifdef APP_LEDS
72:                  	PRIVATE_INIT BYTE bAppSequenceCtr1 = 0;				// LED sequence index
73:                  	PRIVATE_INIT BYTE bAppSequenceCtr2 = 0;
74:                  
75:                  	PRIVATE_INIT INT32U ulAppLED1Sequence = 0L;
76:                  	PRIVATE_INIT INT32U ulAppLED2Sequence = 0L;
77:                  #endif	// #ifdef APP_LEDS
78:                  
79:                  
80:                  #define	LED_PATTERN_LEN		(BYTE)20				// LED patterns are 20 bits long because.. they are. 20 bits == 2 seconds
81:                  
82:                  PRIVATE_INIT FILE_GLOBAL ARRAY INT32U ulLEDTable[] =
83:                  {
84:                  
85:                  	// this sequence can display from 0 to 10 reasonably fast blinks
86:                  
87:                  	(INT32U)0x00000000,			// 0000 0000 0000 0000 0000		LED_OFF
88:                  	(INT32U)0x00000001,			// 0000 0000 0000 0000 0001		1 blink
89:                  	(INT32U)0x00000005,			// 0000 0000 0000 0000 0101		2 blinks
90:                  	(INT32U)0x00000015,			// 0000 0000 0000 0001 0101
91:                  	(INT32U)0x00000055,			// 0000 0000 0000 0101 0101
92:                  	(INT32U)0x00000155,			// 0000 0000 0001 0101 0101
93:                  	(INT32U)0x00000555,			// 0000 0000 0101 0101 0101
94:                  	(INT32U)0x00001555,			// 0000 0001 0101 0101 0101
95:                  	(INT32U)0x00005555,			// 0000 0101 0101 0101 0101
96:                  	(INT32U)0x00015555,			// 0001 0101 0101 0101 0101
97:                  	(INT32U)0x00055555,			// 0101 0101 0101 0101 0101		10 blinks
98:                  
99:                  	(INT32U)0x00000007,			// 0000 0000 0000 0000 0111		LED_QUARTER_SECOND
100:                 	(INT32U)0x00000014,			// 0000 0000 0000 0001 1111		LED_HALF_SECOND
101:                 	(INT32U)0x000003FF,			// 0000 0000 0011 1111 1111		LED_ONE_SECOND
102:                 
103:                 	(INT32U)0x00033333,			// 0011 0011 0011 0011 0011		LED_QUARTER_SECOND_BLINK
104:                 	(INT32U)0x00007C14,			// 0000 0111 1100 0001 1111		LED_HALF_SECOND_BLINK
105:                 	(INT32U)0x000003FF,			// 0000 0000 0011 1111 1111		LED_ONE_SECOND_BLINK
106:                 
107:                 	(INT32U)0x000FFFFF,			// 1111 1111 1111 1111 1111		LED_ON
108:                 
109:                 	(INT32U)0x35353535			// catch-all error value
110:                 
111:                 
112:                 	// perhaps the table could be continued with morse code?
113:                 
114:                 };
115:                 
116:                 
117:                 #define LED_DISPLAY_ERROR       (INT32U)0x35353535      // this is just a catch-all error value
118:                 
119:                 #define	REPEAT_SEQUENCE_BIT		((INT32U)0x80000000)	// marker bit to select repeating sequence
120:                 
121:                 
122:                 //-------------------------------------------------------------------------------------------------------
123:                 // External Variables
124:                 //-------------------------------------------------------------------------------------------------------
125:                 
126:                 //-------------------------------------------------------------------------------------------------------
127:                 // Static Function Prototypes
128:                 //-------------------------------------------------------------------------------------------------------
129:                 
130:                 //-------------------------------------------------------------------------------------------------------
131:                 // Function Bodies
132:                 //-------------------------------------------------------------------------------------------------------
133:                 
134:                 
135:                 //-------------------------------------------------------------------------------------------------------
136:                 //  InitializeDebug
137:                 //
138:                 //  Input: 	    none
139:                 //  Output:	    none
140:                 //  Desc:		Initializes the debug module
141:                 //-------------------------------------------------------------------------------------------------------
142:                 
143:                 void InitializeDebug(void)
144:                 {
9D00D918  27BDFFF0   ADDIU SP, SP, -16
9D00D91C  AFBE000C   SW S8, 12(SP)
9D00D920  03A0F021   ADDU S8, SP, ZERO
145:                 	BYTE	i;
146:                 
147:                 	#ifdef DEBUG_LEDS
148:                 		bDebugSequenceCtr1 = 0;			// LED sequence index
149:                 		bDebugSequenceCtr2 = 0;
150:                 
151:                 		ulDebugLED1Sequence = ulLEDTable[1];
152:                 		ulDebugLED2Sequence = ulLEDTable[2];
153:                 	#endif
154:                 
155:                 	// clear the runtime error array
156:                 	for (i = 0; i < ERROR_BUFFER_MAX_INDEX; i++)
9D00D924  A3C00000   SB ZERO, 0(S8)
9D00D928  0B403654   J 0x9D00D950
9D00D92C  00000000   NOP
9D00D944  93C20000   LBU V0, 0(S8)
9D00D948  24420001   ADDIU V0, V0, 1
9D00D94C  A3C20000   SB V0, 0(S8)
9D00D950  93C30000   LBU V1, 0(S8)
9D00D954  240200FF   ADDIU V0, ZERO, 255
9D00D958  1462FFF5   BNE V1, V0, 0x9D00D930
9D00D95C  00000000   NOP
157:                 		{
158:                 		pgbRuntimeErrorBuffer[i] = 0;
9D00D930  93C30000   LBU V1, 0(S8)
9D00D934  3C02A000   LUI V0, -24576
9D00D938  2442058C   ADDIU V0, V0, 1420
9D00D93C  00621021   ADDU V0, V1, V0
9D00D940  A0400000   SB ZERO, 0(V0)
159:                 		}
160:                 
161:                 	pgwErrorIndex = 0;					// initialize index into ring buffer
9D00D960  A7808136   SH ZERO, -32458(GP)
162:                 
163:                 }
9D00D964  03C0E821   ADDU SP, S8, ZERO
9D00D968  8FBE000C   LW S8, 12(SP)
9D00D96C  27BD0010   ADDIU SP, SP, 16
9D00D970  03E00008   JR RA
9D00D974  00000000   NOP
164:                 
165:                 
166:                 //-------------------------------------------------------------------------------------------------------
167:                 //  AppLEDsInit
168:                 //
169:                 //  Input: 	    none
170:                 //  Output:	    none
171:                 //  Desc:		Initializes Application LED sequences
172:                 //-------------------------------------------------------------------------------------------------------
173:                 
174:                 #ifdef APP_LEDS
175:                 
176:                 	void InitializeAppLEDs(void)
177:                 	{
178:                 
179:                 		bAppSequenceCtr1 = 0;			// LED sequence index
180:                 		bAppSequenceCtr2 = 0;
181:                 
182:                 		ulAppLED1Sequence = ulLEDTable[5];
183:                 		ulAppLED2Sequence = ulLEDTable[10];
184:                 
185:                 	}
186:                 #endif	// #ifdef APP_LEDS
187:                 
188:                 //-------------------------------------------------------------------------------------------------------
189:                 //  DebugLEDTick
190:                 //
191:                 //  Input: 		none
192:                 //  Output:	
193:                 //  Desc:		Update debug LEDs, etc. Called on timer tick, every 100mS
194:                 //-------------------------------------------------------------------------------------------------------
195:                 #ifdef DEBUG_LEDS
196:                 
197:                 	void DebugLEDsTick(void)
198:                 	{
199:                 
200:                 		// step LED sequence
201:                 		if (ulDebugLED1Sequence & LBITMASK(bDebugSequenceCtr1))
202:                 			DEBUG_LED1 = DEBUG_LED_ON;
203:                 		else
204:                 			DEBUG_LED1 = DEBUG_LED_OFF;
205:                 
206:                 		if (ulDebugLED2Sequence & LBITMASK(bDebugSequenceCtr2))
207:                 			DEBUG_LED2 = DEBUG_LED_ON;
208:                 		else
209:                 			DEBUG_LED2 = DEBUG_LED_OFF;
210:                 
211:                 
212:                 		// bump pattern counter, and if the pattern is complete, roll over the counter
213:                 		if (++bDebugSequenceCtr1 == LED_PATTERN_LEN)
214:                 			{
215:                 			bDebugSequenceCtr1 = 0;
216:                 
217:                 			// if the LED pattern IS_NOT specified as REPEAT_SEQUENCE, reset to LED_OFF
218:                 			if ((INT32U)(ulDebugLED1Sequence & REPEAT_SEQUENCE_BIT) IS_NOT REPEAT_SEQUENCE_BIT)
219:                 				ulDebugLED1Sequence = ulLEDTable[LED_OFF];
220:                 
221:                 			}
222:                 
223:                 		// bump pattern counter, and if the pattern is complete, roll over the counter
224:                 		if (++bDebugSequenceCtr2 == LED_PATTERN_LEN)
225:                 			{
226:                 			bDebugSequenceCtr2 = 0;
227:                 
228:                 			// if the LED pattern IS_NOT specified as REPEAT_SEQUENCE, reset to LED_OFF
229:                 			if ((INT32U)(ulDebugLED2Sequence & REPEAT_SEQUENCE_BIT) IS_NOT REPEAT_SEQUENCE_BIT)
230:                 				ulDebugLED2Sequence = ulLEDTable[LED_OFF];
231:                 
232:                 			}
233:                 
234:                 	}
235:                 
236:                 #endif 	// DEBUG_LEDS
237:                 
238:                 
239:                 //-------------------------------------------------------------------------------------------------------
240:                 //  AppLEDTick
241:                 //
242:                 //  Input: 		none
243:                 //  Output:	
244:                 //  Desc:		Update Application LEDs, etc. Called on timer tick, every 100mS
245:                 //-------------------------------------------------------------------------------------------------------
246:                 
247:                 #ifdef APP_LEDS
248:                 
249:                 	void AppLEDsTick(void)
250:                 	{
251:                 
252:                 		// step LED sequence
253:                 		if (ulAppLED1Sequence & LBITMASK(bAppSequenceCtr1))
254:                 			LED1 = APP_LED_ON;
255:                 		else
256:                 			LED1 = APP_LED_OFF;
257:                 
258:                 		if (ulAppLED2Sequence & LBITMASK(bAppSequenceCtr2))
259:                 			LED2 = APP_LED_ON;
260:                 		else
261:                 			LED2 = APP_LED_OFF;
262:                 
263:                 
264:                 		// bump pattern counter, and if the pattern is complete, roll over the counter
265:                 		if (++bAppSequenceCtr1 == LED_PATTERN_LEN)
266:                 			{
267:                 			bAppSequenceCtr1 = 0;
268:                 
269:                 			// if the LED pattern IS_NOT specified as REPEAT_SEQUENCE, reset to LED_OFF
270:                 			if ((INT32U)(ulAppLED1Sequence & REPEAT_SEQUENCE_BIT) IS_NOT REPEAT_SEQUENCE_BIT)
271:                 				ulAppLED1Sequence = ulLEDTable[LED_OFF];
272:                 
273:                 			}
274:                 
275:                 		// bump pattern counter, and if the pattern is complete, roll over the counter
276:                 		if (++bAppSequenceCtr2 == LED_PATTERN_LEN)
277:                 			{
278:                 			bAppSequenceCtr2 = 0;
279:                 
280:                 			// if the LED pattern IS_NOT specified as REPEAT_SEQUENCE, reset to LED_OFF
281:                 			if ((INT32U)(ulAppLED2Sequence & REPEAT_SEQUENCE_BIT) IS_NOT REPEAT_SEQUENCE_BIT)
282:                 				ulAppLED2Sequence = ulLEDTable[LED_OFF];
283:                 
284:                 			}
285:                 
286:                 	}
287:                 #endif	// #ifdef APP_LEDS
288:                 
289:                 
290:                 //-------------------------------------------------------------------------------------------------------
291:                 //  DebugSetLEDxValue
292:                 //
293:                 //  Input: 	    value to display on LED (index into LED display sequence table)
294:                 //  Output:	
295:                 //  Desc:		Update debug LED sequences
296:                 //
297:                 //-------------------------------------------------------------------------------------------------------
298:                 #ifdef DEBUG_LEDS
299:                 
300:                 	void DebugSetLED1Value(BYTE nLedSequenceSelection)
301:                 	{
302:                 
303:                 		if ((nLedSequenceSelection & LED_SEQUENCE_MASK) <= MAX_LED_DISPLAY_VALUE)
304:                 		{
305:                 			ulDebugLED1Sequence = ulLEDTable[nLedSequenceSelection & LED_SEQUENCE_MASK];
306:                 
307:                 			// if repeat is requested, mark repeat bit in sequence pattern
308:                 			if ((nLedSequenceSelection & REPEAT_SEQUENCE) IS REPEAT_SEQUENCE)
309:                 			{
310:                 				ulDebugLED1Sequence |= REPEAT_SEQUENCE_BIT;
311:                 			}
312:                 
313:                 		}
314:                 		else
315:                 		{
316:                 			ulDebugLED1Sequence = LED_DISPLAY_ERROR;
317:                 			RuntimeError(DEBUG_ERROR_INVALID_LED_SEQUENCE);
318:                 		}
319:                 
320:                 		// restart sequence
321:                 		bDebugSequenceCtr1 = 0;
322:                 
323:                 	}
324:                 
325:                 	void DebugSetLED2Value(BYTE nLedSequenceSelection)
326:                 	{
327:                 
328:                 		if ((nLedSequenceSelection & LED_SEQUENCE_MASK) <= MAX_LED_DISPLAY_VALUE)
329:                 		{
330:                 			ulDebugLED2Sequence = ulLEDTable[nLedSequenceSelection & LED_SEQUENCE_MASK];
331:                 
332:                 			// if repeat is requested, mark repeat bit in sequence pattern
333:                 			if ((nLedSequenceSelection & REPEAT_SEQUENCE) IS REPEAT_SEQUENCE)
334:                 			{
335:                 				ulDebugLED2Sequence |= REPEAT_SEQUENCE_BIT;
336:                 			}
337:                 		}
338:                 		else
339:                 		{
340:                 			ulDebugLED2Sequence = LED_DISPLAY_ERROR;
341:                 			RuntimeError(DEBUG_ERROR_INVALID_LED_SEQUENCE);
342:                 		}
343:                 
344:                 		// restart sequence
345:                 		bDebugSequenceCtr2 = 0;
346:                 
347:                 	}
348:                 
349:                 #endif 	// DEBUG_LEDS
350:                 
351:                 
352:                 //-------------------------------------------------------------------------------------------------------
353:                 //  AppSetLEDxValue
354:                 //
355:                 //  Input: 	    value to display on LED (index into LED display sequence table)
356:                 //  Output:	
357:                 //  Desc:		Update Application LED sequences
358:                 //
359:                 //-------------------------------------------------------------------------------------------------------
360:                 
361:                 #ifdef APP_LEDS
362:                 
363:                 	// Left, YELLOW LED
364:                 
365:                 	void AppSetLED1Value(BYTE nLedSequenceSelection)
366:                 	{
367:                 
368:                 		if ((nLedSequenceSelection & LED_SEQUENCE_MASK) <= MAX_LED_DISPLAY_VALUE)
369:                 		{
370:                 			ulAppLED1Sequence = ulLEDTable[nLedSequenceSelection & LED_SEQUENCE_MASK];
371:                 
372:                 			// if repeat is requested, mark repeat bit in sequence pattern
373:                 			if ((nLedSequenceSelection & REPEAT_SEQUENCE) IS REPEAT_SEQUENCE)
374:                 			{
375:                 				ulAppLED1Sequence |= REPEAT_SEQUENCE_BIT;
376:                 			}
377:                 
378:                 		}
379:                 		else
380:                 		{
381:                 			ulAppLED1Sequence = LED_DISPLAY_ERROR;
382:                 			RuntimeError(DEBUG_ERROR_INVALID_LED_SEQUENCE);
383:                 		}
384:                 
385:                 		// restart sequence
386:                 		bAppSequenceCtr1 = 0;
387:                 
388:                 	}
389:                 
390:                 	// Right, GREEN LED
391:                 
392:                 	void AppSetLED2Value(BYTE nLedSequenceSelection)
393:                 	{
394:                 
395:                 		if ((nLedSequenceSelection & LED_SEQUENCE_MASK) <= MAX_LED_DISPLAY_VALUE)
396:                 		{
397:                 			ulAppLED2Sequence = ulLEDTable[nLedSequenceSelection & LED_SEQUENCE_MASK];
398:                 
399:                 			// if repeat is requested, mark repeat bit in sequence pattern
400:                 			if ((nLedSequenceSelection & REPEAT_SEQUENCE) IS REPEAT_SEQUENCE)
401:                 			{
402:                 				ulAppLED2Sequence |= REPEAT_SEQUENCE_BIT;
403:                 			}
404:                 		}
405:                 		else
406:                 		{
407:                 			ulAppLED2Sequence = LED_DISPLAY_ERROR;
408:                 			RuntimeError(DEBUG_ERROR_INVALID_LED_SEQUENCE);
409:                 		}
410:                 
411:                 		// restart sequence
412:                 		bAppSequenceCtr2 = 0;
413:                 
414:                 	}
415:                 #endif	// #ifdef APP_LEDS
416:                 
417:                 
418:                 
419:                 //-------------------------------------------------------------------------------------------------------
420:                 //  RuntimeError
421:                 //
422:                 //  Input: 	    error value
423:                 //  Output:	
424:                 //  Desc:		writes all runtime error codes to a ring buffer to simplify debugging
425:                 //
426:                 //-------------------------------------------------------------------------------------------------------
427:                 
428:                 void _RuntimeError(BYTE bErrorCode)
429:                 {
9D00D978  27BDFFF8   ADDIU SP, SP, -8
9D00D97C  AFBE0004   SW S8, 4(SP)
9D00D980  03A0F021   ADDU S8, SP, ZERO
9D00D984  00801021   ADDU V0, A0, ZERO
9D00D988  A3C20008   SB V0, 8(S8)
430:                 
431:                     // write error code to ring buffer
432:                     pgbRuntimeErrorBuffer[pgwErrorIndex] = bErrorCode;
9D00D98C  97828136   LHU V0, -32458(GP)
9D00D990  00401821   ADDU V1, V0, ZERO
9D00D994  3C02A000   LUI V0, -24576
9D00D998  2442058C   ADDIU V0, V0, 1420
9D00D99C  00621021   ADDU V0, V1, V0
9D00D9A0  93C30008   LBU V1, 8(S8)
9D00D9A4  A0430000   SB V1, 0(V0)
433:                 
434:                 	// check for end of the buffer
435:                     if (pgwErrorIndex IS ERROR_BUFFER_MAX_INDEX)
9D00D9A8  97838136   LHU V1, -32458(GP)
9D00D9AC  240200FF   ADDIU V0, ZERO, 255
9D00D9B0  14620004   BNE V1, V0, 0x9D00D9C4
9D00D9B4  00000000   NOP
436:                 		{
437:                 		// we just wrote to the end of the buffer, so start over
438:                         pgwErrorIndex = 0;
9D00D9B8  A7808136   SH ZERO, -32458(GP)
9D00D9BC  0B403675   J 0x9D00D9D4
9D00D9C0  00000000   NOP
439:                 		}
440:                 	else
441:                 		{
442:                 		// bump ring buffer index for NEXT error code
443:                 		++pgwErrorIndex;
9D00D9C4  97828136   LHU V0, -32458(GP)
9D00D9C8  24420001   ADDIU V0, V0, 1
9D00D9CC  3042FFFF   ANDI V0, V0, -1
9D00D9D0  A7828136   SH V0, -32458(GP)
444:                 		}
445:                 
446:                 
447:                 	// make sure the NEXT error code is always ZERO
448:                     pgbRuntimeErrorBuffer[pgwErrorIndex] = 0;
9D00D9D4  97828136   LHU V0, -32458(GP)
9D00D9D8  00401821   ADDU V1, V0, ZERO
9D00D9DC  3C02A000   LUI V0, -24576
9D00D9E0  2442058C   ADDIU V0, V0, 1420
9D00D9E4  00621021   ADDU V0, V1, V0
9D00D9E8  A0400000   SB ZERO, 0(V0)
449:                 }
9D00D9EC  03C0E821   ADDU SP, S8, ZERO
9D00D9F0  8FBE0004   LW S8, 4(SP)
9D00D9F4  27BD0008   ADDIU SP, SP, 8
9D00D9F8  03E00008   JR RA
9D00D9FC  00000000   NOP
450:                 
451:                 
452:                 
453:                 // reset the RuntimeError buffer index
454:                 void ResetRuntimeError()
455:                 {
9D00DA00  27BDFFF8   ADDIU SP, SP, -8
9D00DA04  AFBE0004   SW S8, 4(SP)
9D00DA08  03A0F021   ADDU S8, SP, ZERO
456:                 
457:                 	pgwErrorIndex = 0;						// restart the error buffer
9D00DA0C  A7808136   SH ZERO, -32458(GP)
458:                 	pgbRuntimeErrorBuffer[0] = 0;
9D00DA10  3C02A000   LUI V0, -24576
9D00DA14  A040058C   SB ZERO, 1420(V0)
459:                 
460:                 }
9D00DA18  03C0E821   ADDU SP, S8, ZERO
9D00DA1C  8FBE0004   LW S8, 4(SP)
9D00DA20  27BD0008   ADDIU SP, SP, 8
9D00DA24  03E00008   JR RA
9D00DA28  00000000   NOP
461:                 
462:                 
463:                 // end of debug.c
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/source/AppTimer.c  ----------------------
1:                   //*************************************************************************************************
2:                   //										A p p T i m e r . c
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	Application Timer definitions
8:                   //
9:                   //		001	16 Mar 13 <sek> created from gsf Code Base
10:                  //
11:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
12:                  //					gsf Engineering	978-927-7189
13:                  //					Beverly, MA 01915
14:                  //
15:                  //		copyright (c) 2013 gsf Engineering
16:                  //
17:                  //*************************************************************************************************
18:                  
19:                  //-----------------------------------------------------------------------------
20:                  //								#include files
21:                  //-----------------------------------------------------------------------------
22:                  //-----------------------------------------------------------------------------
23:                  // #include files
24:                  //-----------------------------------------------------------------------------
25:                  
26:                  //-------------------------------------------------------------------------------------------------------
27:                  //	Include Files
28:                  //-------------------------------------------------------------------------------------------------------
29:                  #include <GenericTypeDefs.h>
30:                  
31:                  //lint -e765					error 765: (Info -- external function could be made static)
32:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
33:                  #include <plib.h>				// Microchip PIC32 peripheral library main header
34:                  //lint +e14
35:                  
36:                  #include <legacy\int_3xx_4xx_legacy.h>	// required for Input Capture interrupt handlers
37:                  
38:                  #include "gsfstd.h"				// gsf standard #defines
39:                  //#include "init.h"				// port definitions and initialization state
40:                  #include "Debug.h"
41:                  #include "SmartTrak.h"			// Project wide definitions
42:                  #include "HardwareProfile.h"
43:                  
44:                  #include "EventFlags.h"			// event flag definitions and globals
45:                  #include "AppTimer.h"			// for RS-232 timeouts, not currently implemented
46:                  
47:                  #include "Stubs.h"
48:                  
49:                  #ifdef DEFINE_GLOBALS
50:                  	#error "DEFINE_GLOBALS not expected here"
51:                  #endif
52:                  
53:                  //-------------------------------------------------------------------------------------------------------
54:                  // Definitions
55:                  //-------------------------------------------------------------------------------------------------------
56:                  
57:                  // see timer.h for enum tagTimerErrors, which is also used by Interrupt.c
58:                  
59:                  //-------------------------------------------------------------------------------------------------------
60:                  // Static and File-Local Variables
61:                  //-------------------------------------------------------------------------------------------------------
62:                  
63:                  
64:                  // Functions:
65:                  // InitializeTimers() Initialize all required timers
66:                  
67:                  
68:                  // Available timers
69:                  //	Microchip PICDEM LCD2 MC1 board, based on PIC18F87J90
70:                  //		Timer0, 8 or 16 bit, timer or counter, shuts down in SLEEP mode
71:                  //				timer: dedicated, selectable 8 bit prescaler (range /2 to /256), timer input is Fosc/4
72:                  //				counter: external input T0CKI pin
73:                  //		Timer1, 16 bit, dedicated, selectable 4 bit prescaler (range /2 to /16), timer input is Fosc/4, dedicated oscillator (int or ext) available
74:                  //				counter: external input T13CKI pin
75:                  //		Timer2, dedicated for PWM timing, prescaler, 8 bit timer and 8 bit period registers, post scaler
76:                  //		Timer3, 16 bit, dedicated, selectable 4 bit prescaler (range /2 to /16), timer input is Fosc/4, dedicated oscillator (int or ext) available
77:                  //				counter: external input T13CKI pin
78:                  //				functionally identical to Timer1
79:                  
80:                  // Counting requirements:
81:                  //		count optical wheel ticks
82:                  
83:                  // Timing requirements:
84:                  //		TMR0	5mS interrupt (basic 5mS tick) (Timer 0)
85:                  //		TMR0	25mS tick, counted from 5mS interrupt (Timer 0 ticks, counted in main loop)
86:                  //		TMR0	100mS tick, counted from 5mS tick in main loop (Timer 0 ticks, counted in main loop)
87:                  //		TMR1	motion stall timer
88:                  //		TMR2	PWM timebase, assigned by hardware
89:                  //		TMR3	motion stall timeout timer
90:                  //		TMR3	timebase for measuring optical wheel ticks, which can range from xx.xmS (max speed) to predetermined stall time (0.xxxs)
91:                  //					this can be done by reading a free-running counter on each wheel tick count interrupt
92:                  //					the math must account for the occasional counter overflow.
93:                  
94:                  //-----------------------------------------------
95:                  // For details of Oscillator configuration, see:
96:                  //	MCUConfigurationBits.h		config bits set at program time, includes details of documentation
97:                  //	Timers.h					timer initialization values
98:                  
99:                  //-----------------------------------------------
100:                 
101:                 
102:                 
103:                 #ifdef NOTDEF
104:                 
105:                 /* *********************************************************************** */
106:                 void InitializeTimers(void)
107:                 {
108:                 
109:                 	// ****************************************************
110:                 	//				Disable Interrupts
111:                 	// ****************************************************
112:                 
113:                 
114:                 	//*********************************
115:                 	//	Put Timers in Known States
116:                 	//*********************************
117:                 
118:                 
119:                 	// ****************************************************
120:                 	//	Initialize Timer 0, System timer, 5mS Interrupts
121:                 	// ****************************************************
122:                 	// Timer 0 is used to generate the basic 5mS tick that is the basis for all system timing
123:                 	// the timer is reloaded during every 5mS interrupt, so it is NOT usable as a free running clock
124:                 
125:                 
126:                 	//*********************************
127:                 	//	Initialize Timer 0 counters
128:                 	//*********************************
129:                 
130:                 	// set Timer0 counter value
131:                 	
132:                 
133:                 	// ****************************************************
134:                 	//			Initialize Timer 1, Interrupts
135:                 	// ****************************************************
136:                 	// Timer 1 is used for motion stall timing
137:                 	// Timer 1 also acts as the source for the internal RTCC (?)
138:                 
139:                 	// Clock Source ext Oscillator = 32.768kHz, 30.5uS (see T1CON)
140:                 	// The TMR1 register pair (TMR1H:TMR1L) increments from 0000h to FFFFh and rolls over to 0000h. The Timer1 interrupt, if enabled, is generated on overflow.
141:                 	// Thus, for a 1 second interrupt rate, we need to load it with (0xFFFF - 32768d)
142:                 
143:                 	
144:                 	//*********************************
145:                 	//	Initialize Timer 1 counters
146:                 	//*********************************
147:                 	
148:                 
149:                 	//*********************************
150:                 	//		Enable Timer 1 
151:                 	//*********************************
152:                 
153:                 	// enable Timer 1 overflow interrupts
154:                 
155:                 	// start Timer 1
156:                 
157:                 	// ****************************************************
158:                 	//			Initialize Timer 2, Interrupts
159:                 	// ****************************************************
160:                 	// Timer 2 is used to generate PWM timing and pulse widths
161:                 	// See PIC18F87J90 Family Datasheet DS39933C-page 143
162:                 
163:                 	// Timer 2 only counts up to the value in PR2, and is then reset by hardware, so it is not usable as a source for a free running clock for timing
164:                 
165:                 	// NOTE: initializing Timer 2 is intertwined with initialing the PWM, so it is not fully initialized or enabled here.
166:                 
167:                 	//*********************************
168:                 	//	Initialize Timer 2 counters
169:                 	//*********************************
170:                 	// Fosc = 4MHz (selected by MCU configuration bits, see MCUConfigurationBits.h)
171:                 	// PLL = x4, see MCUConfigurationBits.h
172:                 	// Despite the documentation stating that the counter input is Fosc/4, it is actually Fpll/4,
173:                 	// so the counter input is 4Mhz
174:                 
175:                 	// NOTE: Postscaler does NOT affect clock provided to CCP/PWM modules
176:                 
177:                 	// T2CON: TIMER2 CONTROL REGISTER
178:                 	//------------------------------------------------------------------------
179:                 	// b7	Unimplemented:	x Read as ï¿½0ï¿½
180:                 	// b6-3 T2OUTPS<3:0>:	0000 Timer2 Output Postscale Select bits, 0000 = 1:1 Postscale, only affects TMR2IF
181:                 	// b2	TMR2ON:			0 Timer2 On bit, 0 = Timer2 is off
182:                 	// b1-0 T2CKPS<1:0>:	01 Timer2 Clock Prescale Select bits, 01 = Prescaler is 4
183:                 
184:                 	#if (TMR2_PRESCALE != 4)
185:                 		#error Timer 2 Prescale value and setting do not match
186:                 	#endif
187:                 	
188:                 	// 0000 0001
189:                 	T2CON = 0x01;
190:                 
191:                 	// NOTE: we could concievably use postscaled output as a PWM-change clock - changing the PWM every 16 output pulses..
192:                 
193:                 	TMR2 = 0;									// clear timer counter; does this actually do anything?
194:                 
195:                 	PIR1bits.TMR2IF = 0;						// clear any pending Timer 2 match interrupts
196:                 	PIE1bits.TMR2IE = 0;						// disable Timer 2 match interrupts
197:                 
198:                 
199:                 	// PIC18F87J90 Family Datasheet DS39933C-page 173
200:                 	// ((PR2) + 1) ï¿½ 4 ï¿½ TOSC ï¿½ (TMR2 Prescale Value)
201:                 
202:                 	// timer 2 counts up from 00h until the value matches the Period Register PR2
203:                 		
204:                 	// for a 8KHz PWM clock rate (4E6 / 4K)/ 8E3 = 125
205:                 ////	PR2 = (unsigned char)(0x00FF & TMR2_PERIOD_CNT);
206:                 
207:                 	//*********************************
208:                 	//		Timer 2 Interrupts
209:                 	//*********************************
210:                 
211:                 	// disable Timer 2 interrupts, we are only using it for PWM
212:                 
213:                 	// for testing purposes, enable Timer 2 interrupts, to allow measuring interrupt rate  WARNING: THIS WILL BASICALLY KILL THE SYSTEM, and will generate many TIMER_ERROR_5MS_TICK_OVERRUN errors
214:                 
215:                 	// see MotorPWM.c:PWM_Init() for code to actually enable Timer 2
216:                 
217:                 	// start Timer 2
218:                 
219:                 	// ****************************************************
220:                 	//			Initialize Timer 3, Interrupts
221:                 	// ****************************************************
222:                 	// Timer 3 is most similar to and closely related to Timer 1, but note: the control registers are NOT identical. See details below!
223:                 
224:                 	
225:                 
226:                 	//*********************************
227:                 	//	Initialize Timer 3 counters
228:                 	//*********************************
229:                 	
230:                 
231:                 	//*********************************
232:                 	//		Enable Timer 3 
233:                 	//*********************************
234:                 
235:                 	// Timer 3 overflow interrupts disabled above
236:                 
237:                 	// start Timer 3
238:                 	
239:                 
240:                 	// Global Interrupts and Peripheral Interrupts are enabled by caller (application main())
241:                 
242:                 
243:                 }
244:                 
245:                 #endif
246:                 /* *********************************************************************** */
247:                 //					Motion Stall Timer (Timer 1)
248:                 /* *********************************************************************** */
249:                 
250:                 // Motion Stall Timer: Timer 1, 32.768KHz
251:                 
252:                 // start the Motion Stall timer - this is called on each MSI tick to restart the timer
253:                 // The counter counts UP from this initial value.
254:                 // if the counter overflows, it generates an interrupt, which is interpreted as a motion stall
255:                 
256:                 void SetMotionStallCtr(enum tagMotors eMotor, unsigned int wNewCount)
257:                 {
9D00CCC8  27BDFFF0   ADDIU SP, SP, -16
9D00CCCC  AFBE000C   SW S8, 12(SP)
9D00CCD0  03A0F021   ADDU S8, SP, ZERO
9D00CCD4  AFC40010   SW A0, 16(S8)
9D00CCD8  AFC50014   SW A1, 20(S8)
258:                 	// calculate counter value for counting UP to rollover
259:                 	WORD	wCounterValue = (WORD)(0xFFFF - wNewCount);		// calculate new counter value for counting up to overflow
9D00CCDC  8FC20014   LW V0, 20(S8)
9D00CCE0  3042FFFF   ANDI V0, V0, -1
9D00CCE4  00021027   NOR V0, ZERO, V0
9D00CCE8  A7C20000   SH V0, 0(S8)
260:                 
261:                 	pgwLastMotionStallTimer[eMotor] = wNewCount;			// keep a copy of last stall timer value
9D00CCEC  8FC20014   LW V0, 20(S8)
9D00CCF0  3043FFFF   ANDI V1, V0, -1
9D00CCF4  3C02A000   LUI V0, -24576
9D00CCF8  8FC40010   LW A0, 16(S8)
9D00CCFC  00042040   SLL A0, A0, 1
9D00CD00  244202C0   ADDIU V0, V0, 704
9D00CD04  00821021   ADDU V0, A0, V0
9D00CD08  A4430000   SH V1, 0(V0)
262:                 
263:                 #ifdef NOTDEF
264:                 	//*********************************
265:                 	//	Initialize Timer 1 counters
266:                 	//*********************************
267:                 	// from PIC18F87J90 Family Datasheet DS39933C-page 139
268:                 	// A write to the high byte of Timer1 must also take place through the TMR1H Buffer register. 
269:                 	// The Timer1 high byte is updated with the contents of TMR1H when a write occurs to TMR1L.
270:                 
271:                 	// thus, the write order is HIGH, LOW
272:                 	TMR1H = (unsigned char)((0xFF00 & wCounterValue) >> 8);
273:                 	TMR1L = (unsigned char)(0x00FF & wCounterValue);
274:                 
275:                 	BITCLEAR(efMotionEvents, EF_MOTION_STALLED);		// Motion cannot be STALLED
276:                 
277:                 	//*********************************
278:                 	//	Enable Timer and Interrupts
279:                 	//*********************************
280:                 	// enable Timer 1 overflow interrupts
281:                 	PIE1bits.TMR1IE = 1;
282:                 
283:                 	// start Timer 1
284:                 	T1CONbits.TMR1ON = 1;
285:                 
286:                 #endif
287:                 
288:                 }
9D00CD0C  03C0E821   ADDU SP, S8, ZERO
9D00CD10  8FBE000C   LW S8, 12(SP)
9D00CD14  27BD0010   ADDIU SP, SP, 16
9D00CD18  03E00008   JR RA
9D00CD1C  00000000   NOP
289:                 
290:                 
291:                 void ClearMotionStallTimer(enum tagMotors eMotor)
292:                 {
9D00CD20  27BDFFF8   ADDIU SP, SP, -8
9D00CD24  AFBE0004   SW S8, 4(SP)
9D00CD28  03A0F021   ADDU S8, SP, ZERO
9D00CD2C  AFC40008   SW A0, 8(S8)
293:                 #ifdef NOTDEF
294:                 
295:                 	// thus, the write order is HIGH, LOW
296:                 	TMR1H = (unsigned char)(0x00);
297:                 	TMR1L = (unsigned char)(0x00);
298:                 
299:                 #endif
300:                 
301:                 }
9D00CD30  03C0E821   ADDU SP, S8, ZERO
9D00CD34  8FBE0004   LW S8, 4(SP)
9D00CD38  27BD0008   ADDIU SP, SP, 8
9D00CD3C  03E00008   JR RA
9D00CD40  00000000   NOP
302:                 
303:                 void StopMotionStallCtr(enum tagMotors eMotor)
304:                 {
9D00CD44  27BDFFF8   ADDIU SP, SP, -8
9D00CD48  AFBE0004   SW S8, 4(SP)
9D00CD4C  03A0F021   ADDU S8, SP, ZERO
9D00CD50  AFC40008   SW A0, 8(S8)
305:                 #ifdef NOTDEF
306:                 
307:                 	//*********************************
308:                 	//	Disable Timer and Interrupts
309:                 	//*********************************
310:                 	// disable Timer 1 overflow interrupts
311:                 	PIE1bits.TMR1IE = 0;
312:                 
313:                 	// stop Timer 1
314:                 	T1CONbits.TMR1ON = 0;
315:                 
316:                 #endif
317:                 
318:                 }
9D00CD54  03C0E821   ADDU SP, S8, ZERO
9D00CD58  8FBE0004   LW S8, 4(SP)
9D00CD5C  27BD0008   ADDIU SP, SP, 8
9D00CD60  03E00008   JR RA
9D00CD64  00000000   NOP
319:                 
320:                 
321:                 //************************************************************************
322:                 //				Mostion Sensor Interrupt Timing (Timer 3)
323:                 //************************************************************************
324:                 
325:                 // Motion Measurement Timer: Timer 3, 32.768KHz
326:                 // This timer is setup for free running, and is cleared ONLY at the beginning of a move
327:                 // Called from MotionFSM() to track motion phase timing; really only used for Serial Menu output
328:                 
329:                 // NOTE: the Timer used for OWI timing is setup for 16 bit reads (see Timer.c:InitializeTimers(), above), so we do NOT need to disable interrupts during timer reads
330:                 
331:                 // read the current state of the Optical Wheel Interrupt (OWI) Timer, used to:
332:                 //		measure time between ticks
333:                 //		track speed
334:                 //		detect motion stalls
335:                 
336:                 /*capture5_isr  â€“ â€œvoid __ISR( _INPUT_CAPTURE_5_VECTOR, ipl3) Capture5(void)â€?
337:                 a.  Declare an input capture buffer â€“ â€œstatic unsigned int con_buf[32]â€?
338:                 b.  Declare three time capture variables:
339:                 i.  static unsigned short int time1;    // Most recent captured time
340:                 ii.  static unsigned short int time2 = 0;  // Previous time captured
341:                 iii.  static unsigned short int time_diff = 0;  // Time between captures
342:                 c.  Toggles LEDC on each input capture interrupt.
343:                 d.  Reads current capture time
344:                 i.  ReadCapture5(con_buf);  // Read captures into buffer
345:                 ii.  time1 = con_buf[0];    // Save time of event
346:                 e.  Subtracts previous capture time to determine period
347:                 i.   time_diff = time1-time2;
348:                 f.  Save time1 as time 2:
349:                 i.  time 2 = time1;
350:                 g.  Computes motor speed in RPS (revolutions per second)
351:                 i.  Equation to be worked out by student
352:                 h.  Clears interrupt flag
353:                 i.  mIC5ClearIntFlag();
354:                 */
355:                 
356:                 
357:                 WORD ReadMSITimer(enum tagAxis eAxis)
358:                 {
9D00CD68  27BDFFE0   ADDIU SP, SP, -32
9D00CD6C  AFBF001C   SW RA, 28(SP)
9D00CD70  AFBE0018   SW S8, 24(SP)
9D00CD74  03A0F021   ADDU S8, SP, ZERO
9D00CD78  AFC40020   SW A0, 32(S8)
359:                 	// NOTE: we are NOT using the peripheral library function ReadCapture1() because it can return more than one value
360:                 	//		AND the documentation is WRONG, it says that ReadCapture1() will 'wait for data', which is WRONG
361:                 
362:                 	WORD wRetVal = 0;
9D00CD7C  A7C00010   SH ZERO, 16(S8)
363:                 
364:                 	switch(eAxis)
9D00CD80  8FC20020   LW V0, 32(S8)
9D00CD84  10400006   BEQ V0, ZERO, 0x9D00CDA0
9D00CD88  00000000   NOP
9D00CD8C  24030001   ADDIU V1, ZERO, 1
9D00CD90  10430031   BEQ V0, V1, 0x9D00CE58
9D00CD94  00000000   NOP
9D00CD98  0B4033C4   J 0x9D00CF10
9D00CD9C  00000000   NOP
365:                 	{
366:                 		case AXIS_AZIMUTH:
367:                 			if (IC1CONbits.ICBNE)				// make sure data is available
9D00CDA0  3C02BF80   LUI V0, -16512
9D00CDA4  8C422000   LW V0, 8192(V0)
9D00CDA8  30420008   ANDI V0, V0, 8
9D00CDAC  10400004   BEQ V0, ZERO, 0x9D00CDC0
9D00CDB0  00000000   NOP
368:                 			{
369:                 				wRetVal = IC1BUF;				/* reads the input capture buffer */
9D00CDB4  3C02BF80   LUI V0, -16512
9D00CDB8  8C422010   LW V0, 8208(V0)
9D00CDBC  A7C20010   SH V0, 16(S8)
370:                 			}
371:                 
372:                 			if (IC1CONbits.ICBNE)				// check for more data available
9D00CDC0  3C02BF80   LUI V0, -16512
9D00CDC4  8C422000   LW V0, 8192(V0)
9D00CDC8  30420008   ANDI V0, V0, 8
9D00CDCC  1040000E   BEQ V0, ZERO, 0x9D00CE08
9D00CDD0  00000000   NOP
373:                 			{
374:                 				RuntimeError(TIMER_ERROR_MTN_SENSOR_TICK_OVERRUN);
9D00CDD4  240400CC   ADDIU A0, ZERO, 204
9D00CDD8  0F40365E   JAL _RuntimeError
9D00CDDC  00000000   NOP
375:                 				while (IC1CONbits.ICBNE)		// clear overrun by reading all available data
9D00CDE0  0B40337D   J 0x9D00CDF4
9D00CDE4  00000000   NOP
9D00CDF4  3C02BF80   LUI V0, -16512
9D00CDF8  8C422000   LW V0, 8192(V0)
9D00CDFC  30420008   ANDI V0, V0, 8
9D00CE00  1440FFF9   BNE V0, ZERO, 0x9D00CDE8
9D00CE04  00000000   NOP
376:                 					wRetVal = IC1BUF;			/* reads the input capture buffer */
9D00CDE8  3C02BF80   LUI V0, -16512
9D00CDEC  8C422010   LW V0, 8208(V0)
9D00CDF0  A7C20010   SH V0, 16(S8)
377:                 			}
378:                 
379:                 			if (IC1CONbits.ICOV)				// check for FIFO overflow
9D00CE08  3C02BF80   LUI V0, -16512
9D00CE0C  8C422000   LW V0, 8192(V0)
9D00CE10  30420010   ANDI V0, V0, 16
9D00CE14  10400043   BEQ V0, ZERO, 0x9D00CF24
9D00CE18  00000000   NOP
380:                 			{
381:                 				RuntimeError(TIMER_ERROR_MTN_SENSOR_FIFO_OVERRUN);
9D00CE1C  240400CD   ADDIU A0, ZERO, 205
9D00CE20  0F40365E   JAL _RuntimeError
9D00CE24  00000000   NOP
382:                 
383:                 				while (IC1CONbits.ICBNE)		// clear overrun by reading all available data
9D00CE28  0B40338F   J 0x9D00CE3C
9D00CE2C  00000000   NOP
9D00CE3C  3C02BF80   LUI V0, -16512
9D00CE40  8C422000   LW V0, 8192(V0)
9D00CE44  30420008   ANDI V0, V0, 8
9D00CE48  1440FFF9   BNE V0, ZERO, 0x9D00CE30
9D00CE4C  00000000   NOP
384:                 					wRetVal = IC1BUF;			/* reads the input capture buffer */
9D00CE30  3C02BF80   LUI V0, -16512
9D00CE34  8C422010   LW V0, 8208(V0)
9D00CE38  A7C20010   SH V0, 16(S8)
385:                 			}
386:                 
387:                 			break;
9D00CE50  0B4033CD   J 0x9D00CF34
9D00CE54  00000000   NOP
9D00CF24  00000000   NOP
9D00CF28  0B4033CD   J 0x9D00CF34
9D00CF2C  00000000   NOP
388:                 
389:                 		case AXIS_ELEVATION:
390:                 			if (IC2CONbits.ICBNE)				// check for more data available
9D00CE58  3C02BF80   LUI V0, -16512
9D00CE5C  8C422200   LW V0, 8704(V0)
9D00CE60  30420008   ANDI V0, V0, 8
9D00CE64  10400004   BEQ V0, ZERO, 0x9D00CE78
9D00CE68  00000000   NOP
391:                 			{
392:                 				wRetVal = IC2BUF;				/* reads the input capture buffer */
9D00CE6C  3C02BF80   LUI V0, -16512
9D00CE70  8C422210   LW V0, 8720(V0)
9D00CE74  A7C20010   SH V0, 16(S8)
393:                 			}
394:                 
395:                 			if (IC2CONbits.ICBNE)				// check for more data available
9D00CE78  3C02BF80   LUI V0, -16512
9D00CE7C  8C422200   LW V0, 8704(V0)
9D00CE80  30420008   ANDI V0, V0, 8
9D00CE84  1040000E   BEQ V0, ZERO, 0x9D00CEC0
9D00CE88  00000000   NOP
396:                 			{
397:                 				RuntimeError(TIMER_ERROR_MTN_SENSOR_TICK_OVERRUN);
9D00CE8C  240400CC   ADDIU A0, ZERO, 204
9D00CE90  0F40365E   JAL _RuntimeError
9D00CE94  00000000   NOP
398:                 				while (IC2CONbits.ICBNE)		// clear overrun by reading all available data
9D00CE98  0B4033AB   J 0x9D00CEAC
9D00CE9C  00000000   NOP
9D00CEAC  3C02BF80   LUI V0, -16512
9D00CEB0  8C422200   LW V0, 8704(V0)
9D00CEB4  30420008   ANDI V0, V0, 8
9D00CEB8  1440FFF9   BNE V0, ZERO, 0x9D00CEA0
9D00CEBC  00000000   NOP
399:                 					wRetVal = IC2BUF;			/* reads the input capture buffer */
9D00CEA0  3C02BF80   LUI V0, -16512
9D00CEA4  8C422210   LW V0, 8720(V0)
9D00CEA8  A7C20010   SH V0, 16(S8)
400:                 			}
401:                 
402:                 			if (IC2CONbits.ICOV)				// check for FIFO overflow
9D00CEC0  3C02BF80   LUI V0, -16512
9D00CEC4  8C422200   LW V0, 8704(V0)
9D00CEC8  30420010   ANDI V0, V0, 16
9D00CECC  10400018   BEQ V0, ZERO, 0x9D00CF30
9D00CED0  00000000   NOP
403:                 			{
404:                 				RuntimeError(TIMER_ERROR_MTN_SENSOR_FIFO_OVERRUN);
9D00CED4  240400CD   ADDIU A0, ZERO, 205
9D00CED8  0F40365E   JAL _RuntimeError
9D00CEDC  00000000   NOP
405:                 
406:                 				while (IC2CONbits.ICBNE)		// clear overrun by reading all available data
9D00CEE0  0B4033BD   J 0x9D00CEF4
9D00CEE4  00000000   NOP
9D00CEF4  3C02BF80   LUI V0, -16512
9D00CEF8  8C422200   LW V0, 8704(V0)
9D00CEFC  30420008   ANDI V0, V0, 8
9D00CF00  1440FFF9   BNE V0, ZERO, 0x9D00CEE8
9D00CF04  00000000   NOP
407:                 					wRetVal = IC2BUF;			/* reads the input capture buffer */
9D00CEE8  3C02BF80   LUI V0, -16512
9D00CEEC  8C422210   LW V0, 8720(V0)
9D00CEF0  A7C20010   SH V0, 16(S8)
408:                 			}
409:                 
410:                 			break;
9D00CF08  0B4033CD   J 0x9D00CF34
9D00CF0C  00000000   NOP
9D00CF30  00000000   NOP
411:                 
412:                 		default:
413:                 			RuntimeError(TIMER_ERROR_INVALID_AXIS);
9D00CF10  240400CB   ADDIU A0, ZERO, 203
9D00CF14  0F40365E   JAL _RuntimeError
9D00CF18  00000000   NOP
414:                 			break;
9D00CF1C  0B4033CD   J 0x9D00CF34
9D00CF20  00000000   NOP
415:                 	}
416:                 
417:                 	return wRetVal;
9D00CF34  97C20010   LHU V0, 16(S8)
418:                 
419:                 }
9D00CF38  03C0E821   ADDU SP, S8, ZERO
9D00CF3C  8FBF001C   LW RA, 28(SP)
9D00CF40  8FBE0018   LW S8, 24(SP)
9D00CF44  27BD0020   ADDIU SP, SP, 32
9D00CF48  03E00008   JR RA
9D00CF4C  00000000   NOP
420:                 
421:                 
422:                 // clear the Optical Wheel Interrupt (OWI) timer
423:                 // Called ONLY at tbe beginning of a move
424:                 void ClearMSITimer(enum tagAxis eAxis)
425:                 {
9D00CF50  27BDFFE0   ADDIU SP, SP, -32
9D00CF54  AFBF001C   SW RA, 28(SP)
9D00CF58  AFBE0018   SW S8, 24(SP)
9D00CF5C  03A0F021   ADDU S8, SP, ZERO
9D00CF60  AFC40020   SW A0, 32(S8)
426:                 
427:                 	WORD wDummy = 0;
9D00CF64  A7C00010   SH ZERO, 16(S8)
428:                 
429:                 	//*********************************
430:                 	//	Clear Motion Capture Data
431:                 	//*********************************
432:                 	switch(eAxis)
9D00CF68  8FC20020   LW V0, 32(S8)
9D00CF6C  1040000B   BEQ V0, ZERO, 0x9D00CF9C
9D00CF70  00000000   NOP
9D00CF74  24030001   ADDIU V1, ZERO, 1
9D00CF78  10430015   BEQ V0, V1, 0x9D00CFD0
9D00CF7C  00000000   NOP
9D00CF80  0B4033FC   J 0x9D00CFF0
9D00CF84  00000000   NOP
433:                 	{
434:                 		case AXIS_AZIMUTH:
435:                 
436:                 			while (IC1CONbits.ICBNE)			// clear overrun by reading all available data
9D00CF9C  00000000   NOP
9D00CFA0  3C02BF80   LUI V0, -16512
9D00CFA4  8C422000   LW V0, 8192(V0)
9D00CFA8  30420008   ANDI V0, V0, 8
9D00CFAC  1440FFF6   BNE V0, ZERO, 0x9D00CF88
9D00CFB0  00000000   NOP
437:                 				wDummy = IC1BUF;			/* reads the input capture buffer */
9D00CF88  3C02BF80   LUI V0, -16512
9D00CF8C  8C422010   LW V0, 8208(V0)
9D00CF90  A7C20010   SH V0, 16(S8)
9D00CF94  0B4033E8   J 0x9D00CFA0
9D00CF98  00000000   NOP
438:                 
439:                 			break;
9D00CFB4  0B403400   J 0x9D00D000
9D00CFB8  00000000   NOP
440:                 
441:                 		case AXIS_ELEVATION:
442:                 
443:                 			while (IC2CONbits.ICBNE)		// clear overrun by reading all available data
9D00CFD0  00000000   NOP
9D00CFD4  3C02BF80   LUI V0, -16512
9D00CFD8  8C422200   LW V0, 8704(V0)
9D00CFDC  30420008   ANDI V0, V0, 8
9D00CFE0  1440FFF6   BNE V0, ZERO, 0x9D00CFBC
9D00CFE4  00000000   NOP
444:                 				wDummy = IC2BUF;			/* reads the input capture buffer */
9D00CFBC  3C02BF80   LUI V0, -16512
9D00CFC0  8C422210   LW V0, 8720(V0)
9D00CFC4  A7C20010   SH V0, 16(S8)
9D00CFC8  0B4033F5   J 0x9D00CFD4
9D00CFCC  00000000   NOP
445:                 
446:                 			break;
9D00CFE8  0B403400   J 0x9D00D000
9D00CFEC  00000000   NOP
447:                 
448:                 		default:
449:                 			RuntimeError(TIMER_ERROR_INVALID_AXIS);
9D00CFF0  240400CB   ADDIU A0, ZERO, 203
9D00CFF4  0F40365E   JAL _RuntimeError
9D00CFF8  00000000   NOP
450:                 			break;
9D00CFFC  00000000   NOP
451:                 	}
452:                 
453:                 	//*********************************
454:                 	//		Clear Timer 3 counter
455:                 	//*********************************
456:                 //	TMR3 = 0x0000;
457:                 
458:                 }
9D00D000  03C0E821   ADDU SP, S8, ZERO
9D00D004  8FBF001C   LW RA, 28(SP)
9D00D008  8FBE0018   LW S8, 24(SP)
9D00D00C  27BD0020   ADDIU SP, SP, 32
9D00D010  03E00008   JR RA
9D00D014  00000000   NOP
459:                 
460:                 
461:                 
462:                 
463:                 //************************************************************************
464:                 //							Debris?
465:                 //************************************************************************
466:                 
467:                 //void InitializeSubSecTimers(void);
468:                 
469:                 #ifdef NOTDEF
470:                 	//==============================================
471:                 	unsigned int ReadSubSecTimerValue(unsigned char ucTimerIndex)
472:                 	{
473:                 		return(uisSubSecTimer[ucTimerIndex]);
474:                 	}
475:                 
476:                 
477:                 	//==============================================
478:                 	void WriteSubSecTimerValue(unsigned char ucTimerIndex, unsigned int uiTimerValue)
479:                 	{
480:                 		uisSubSecTimer[ucTimerIndex] = uiTimerValue;
481:                 	}
482:                 #endif
483:                 
484:                 // these functions are taken from RHU code, and resemble the RF Stamp code
485:                 
486:                 /* *********************************************************************** */
487:                 #ifdef SERIAL_TIMEOUT_TIMERS
488:                 
489:                 	unsigned int ReadSubSecTimerValue(unsigned char ucTimerIndex)
490:                 	{
491:                 		unsigned int uiTemp;
492:                 
493:                 		INTCON &= ~0x80;   //disable global int
494:                 
495:                 		uiTemp = uisSubSecTimer[ucTimerIndex];
496:                 
497:                 		INTCON |= 0x80;   //enable global int
498:                 		return(uiTemp);
499:                 	}
500:                 
501:                 
502:                 	/* *********************************************************************** */
503:                 	void WriteSubSecTimerValue(unsigned char ucTimerIndex, unsigned int uiTimerValue)
504:                 	{
505:                 		INTCON &= ~0x80;   //disable global int
506:                 
507:                 		uisSubSecTimer[ucTimerIndex] = uiTimerValue;
508:                 
509:                 		INTCON |= 0x80;   //enable global int
510:                 	}
511:                 #endif
512:                 
513:                 
514:                 // end of AppTimer.c
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/BSP/SerialPort.c  -----------------------
1:                   //*************************************************************************************************
2:                   //										S e r i a l P o r t . C
3:                   //*************************************************************************************************
4:                   //
5:                   //		Project:	SmartTrak Solar Panel Controller
6:                   //
7:                   //		Contains:	PIC32MX360F512L MCU Serial Port initialization functions
8:                   //
9:                   //		001	15 Feb 13 <sek> created from gsf Code Base
10:                  //		002	24 Feb 13 <sek> replaced Pointer with correct Index, enabled Rx interrupts
11:                  //		003	26 Feb 13 <sek> BOOL return values
12:                  //
13:                  //		AUTHOR:	    Steve Kranish	skranish@verizon.net
14:                  //					gsf Engineering	978-927-7189
15:                  //					Beverly, MA 01915
16:                  //
17:                  //		copyright (c) 2013 gsf Engineering
18:                  //
19:                  //*************************************************************************************************
20:                  
21:                  // These functions are NOT register level. They call into the PIC32 Peripheral library to
22:                  // handle most register access, especially initialization
23:                  
24:                  // See PIC32 Family Reference Manual, Sect. 21 UART 61107G.pdf for details of serial async setup and operation
25:                  
26:                  #ifndef __32MX360F512L__
27:                  	#error	Incorrect Processor Type Selected; code is for PIC32MX360F512L
28:                  #endif
29:                  
30:                  // This code is setup for 9600,n,8,1 on ESUART1
31:                  
32:                  //-----------------------------------------------------------------------------
33:                  //								#include files
34:                  //-----------------------------------------------------------------------------
35:                  
36:                  //lint -e765					error 765: (Info -- external function could be made static)
37:                  //lint -e14						error 14: (Error -- Symbol 'foo' previously defined (line moo, file yoo.c, module goo.c))
38:                  #include <plib.h>						// Microchip PIC32 peripheral library main header
39:                  //lint +e14
40:                  
41:                  #include "gsfstd.h"						// gsf standard #defines
42:                  #include "Debug.h"
43:                  #include "SmartTrak.h"					// Project wide definitions
44:                  #include "HardwareProfile.h"
45:                  #include "SerialPort.h"
46:                  #include "EventFlags.h"					// event flag definitions and globals
47:                  //#include "Timer.h"					// for RS-232 timeouts, not currently implemented
48:                  
49:                  #ifdef DEFINE_GLOBALS
50:                  	#error "DEFINE_GLOBALS not expected here"
51:                  #endif
52:                  //-----------------------------------------------------------------------------
53:                  //								Definitions
54:                  //-----------------------------------------------------------------------------
55:                  
56:                  enum tagSerialFSMErrors
57:                  {
58:                  	SER_FSM_ERROR_NONE = SER_FSM_ERROR_BASE,
59:                  	SER_FSM_ERROR_UNEXPECTED_TICK,			// 1 unexpected timer tick event
60:                  	SER_FSM_ERROR_UNEXPECTED_EVENT,			// 2 unexpected timer tick event
61:                  	SER_FSM_ERROR_INVALID_STATE,			// 3 not a valid state
62:                  	SER_FSM_ERROR_INVALID_SUBSTATE,			// 4 not a valid state
63:                  	SER_FSM_ERROR_UNEXPECTED_RX_INT,		// 5
64:                  	SER_FSM_ERROR_UNEXPECTED_TX_INT,		// 6
65:                  	SER_FSM_ERROR_TRANSMIT_TIMEOUT,			// 7
66:                  	SER_FSM_ERROR_NO_TX_DATA_AVAILABLE,		// 8 no packet data available
67:                  	SER_FSM_ERROR_NO_RX_DATA_AVAILABLE,		// 8 no packet data available
68:                  	SER_FSM_ERROR_BUFFER_OVERFLOW,			// 9 receive buffer overflow
69:                  	SER_FSM_ERROR_RX_FRAMING_ERROR,			// A low level framing error
70:                  	SER_FSM_ERROR_RX_OVERRUN_ERROR,			// B low level data overrun error
71:                  	SER_FSM_ERROR_TX_BUFFER_FULL,			// C transmit buffer full
72:                  
73:                  	SER_FSM_ERROR_UNPROCESSED_EVENT = SER_FSM_ERROR_BASE + 0x0F		// F
74:                  };
75:                  
76:                  
77:                  
78:                  //*****************************************************************************
79:                  //						Initialize Serial Port
80:                  //*****************************************************************************
81:                  
82:                  void InitializeSerialPort(UART_MODULE UARTid, UINT32 lBaudRate)
83:                  {
9D008AE4  27BDFFE8   ADDIU SP, SP, -24
9D008AE8  AFBF0014   SW RA, 20(SP)
9D008AEC  AFBE0010   SW S8, 16(SP)
9D008AF0  03A0F021   ADDU S8, SP, ZERO
9D008AF4  AFC40018   SW A0, 24(S8)
9D008AF8  AFC5001C   SW A1, 28(S8)
84:                  
85:                  	//*********************************
86:                  	//		Serial Control
87:                  	//*********************************
88:                  	// This initialization assumes 36MHz Fpb clock.
89:                  	// If it changes, you will have to modify baud rate initializer.
90:                      UARTConfigure(UARTid, UART_ENABLE_PINS_TX_RX_ONLY);					// note that we are NOT setting high speed mode
9D008AFC  8FC40018   LW A0, 24(S8)
9D008B00  00002821   ADDU A1, ZERO, ZERO
9D008B04  0F4038A5   JAL UARTConfigure
9D008B08  00000000   NOP
91:                      //UARTSetFifoMode(UARTid, UART_INTERRUPT_ON_TX_NOT_FULL | UART_INTERRUPT_ON_RX_NOT_EMPTY);
92:                  	//UART_INTERRUPT_ON_TX_DONE, UART_INTERRUPT_ON_TX_BUFFER_EMPTY
93:                      UARTSetFifoMode(UARTid, UART_INTERRUPT_ON_TX_BUFFER_EMPTY | UART_INTERRUPT_ON_RX_NOT_EMPTY);
9D008B0C  8FC40018   LW A0, 24(S8)
9D008B10  34058000   ORI A1, ZERO, -32768
9D008B14  0F40396A   JAL UARTSetFifoMode
9D008B18  00000000   NOP
94:                      UARTSetLineControl(UARTid, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
9D008B1C  8FC40018   LW A0, 24(S8)
9D008B20  00002821   ADDU A1, ZERO, ZERO
9D008B24  0F403974   JAL UARTSetLineControl
9D008B28  00000000   NOP
95:                      UARTSetDataRate(UARTid, GetPeripheralClock(), lBaudRate);
9D008B2C  3C02BF81   LUI V0, -16511
9D008B30  8C42F000   LW V0, -4096(V0)
9D008B34  7C420CC0   EXT V0, V0, 19, 2
9D008B38  304200FF   ANDI V0, V0, 255
9D008B3C  3C0304C4   LUI V1, 1220
9D008B40  3463B400   ORI V1, V1, -19456
9D008B44  00431006   SRLV V0, V1, V0
9D008B48  8FC40018   LW A0, 24(S8)
9D008B4C  00402821   ADDU A1, V0, ZERO
9D008B50  8FC6001C   LW A2, 28(S8)
9D008B54  0F403806   JAL UARTSetDataRate
9D008B58  00000000   NOP
96:                      UARTEnable(UARTid, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D008B5C  8FC40018   LW A0, 24(S8)
9D008B60  24050087   ADDIU A1, ZERO, 135
9D008B64  0F4037CC   JAL UARTEnable
9D008B68  00000000   NOP
97:                  
98:                  	//*********************************
99:                  	//		Interrupt Control
100:                 	//*********************************
101:                 	// Configure UART RX Interrupt
102:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_ENABLED);
9D008B6C  8FC20018   LW V0, 24(S8)
9D008B70  24420022   ADDIU V0, V0, 34
9D008B74  00402021   ADDU A0, V0, ZERO
9D008B78  24050001   ADDIU A1, ZERO, 1
9D008B7C  0F403832   JAL INTEnable
9D008B80  00000000   NOP
103:                 	// Tx Interrupt enabled only when there is data to Tx
104:                     INTSetVectorPriority(INT_VECTOR_UART(UARTid), INT_PRIORITY_LEVEL_2);
9D008B84  8FC20018   LW V0, 24(S8)
9D008B88  24420019   ADDIU V0, V0, 25
9D008B8C  00402021   ADDU A0, V0, ZERO
9D008B90  24050002   ADDIU A1, ZERO, 2
9D008B94  0F4038D1   JAL INTSetVectorPriority
9D008B98  00000000   NOP
105:                     INTSetVectorSubPriority(INT_VECTOR_UART(UARTid), INT_SUB_PRIORITY_LEVEL_0);
9D008B9C  8FC20018   LW V0, 24(S8)
9D008BA0  24420019   ADDIU V0, V0, 25
9D008BA4  00402021   ADDU A0, V0, ZERO
9D008BA8  00002821   ADDU A1, ZERO, ZERO
9D008BAC  0F4038DF   JAL INTSetVectorSubPriority
9D008BB0  00000000   NOP
106:                 
107:                 	// interrupts are enabled by the caller (application main())
108:                 
109:                 	// note that we do NOT enable Tx (transmit) interrupts here
110:                 	// TX interrupts should ONLY be enabled when there is data available to transmit
111:                 }
9D008BB4  03C0E821   ADDU SP, S8, ZERO
9D008BB8  8FBF0014   LW RA, 20(SP)
9D008BBC  8FBE0010   LW S8, 16(SP)
9D008BC0  27BD0018   ADDIU SP, SP, 24
9D008BC4  03E00008   JR RA
9D008BC8  00000000   NOP
112:                 
113:                 
114:                 //*****************************************************************************
115:                 //								Serial Receive
116:                 //*****************************************************************************
117:                 
118:                 //*********************************************************
119:                 //						StartRx
120:                 //*********************************************************
121:                 
122:                 // this is an interrupt driven, NON blocking receive function
123:                 int StartRx(UART_MODULE UARTid)
124:                 	{
9D008BCC  27BDFFE8   ADDIU SP, SP, -24
9D008BD0  AFBF0014   SW RA, 20(SP)
9D008BD4  AFBE0010   SW S8, 16(SP)
9D008BD8  03A0F021   ADDU S8, SP, ZERO
9D008BDC  AFC40018   SW A0, 24(S8)
125:                 
126:                 	unsigned char bTemp;
127:                 
128:                 	// disable RX interrupts while setting up for RX
129:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_DISABLED);
9D008BE0  8FC20018   LW V0, 24(S8)
9D008BE4  24420022   ADDIU V0, V0, 34
9D008BE8  00402021   ADDU A0, V0, ZERO
9D008BEC  00002821   ADDU A1, ZERO, ZERO
9D008BF0  0F403832   JAL INTEnable
9D008BF4  00000000   NOP
130:                 
131:                 	// initialize ring buffer indicies
132:                 	ucsRxdInIndex[UARTid] = 0;
9D008BF8  3C02A000   LUI V0, -24576
9D008BFC  24430244   ADDIU V1, V0, 580
9D008C00  8FC20018   LW V0, 24(S8)
9D008C04  00621021   ADDU V0, V1, V0
9D008C08  A0400000   SB ZERO, 0(V0)
133:                 	ucsRxdOutIndex[UARTid] = 0;
9D008C0C  3C02A000   LUI V0, -24576
9D008C10  24430248   ADDIU V1, V0, 584
9D008C14  8FC20018   LW V0, 24(S8)
9D008C18  00621021   ADDU V0, V1, V0
9D008C1C  A0400000   SB ZERO, 0(V0)
134:                 
135:                 	// initialize the start of the receive buffer, so it will not be interpreted as useful!
136:                 	ucsRxdData[UARTid][ucsRxdInIndex[UARTid]] = '\0';
9D008C20  3C02A000   LUI V0, -24576
9D008C24  24430244   ADDIU V1, V0, 580
9D008C28  8FC20018   LW V0, 24(S8)
9D008C2C  00621021   ADDU V0, V1, V0
9D008C30  90420000   LBU V0, 0(V0)
9D008C34  304200FF   ANDI V0, V0, 255
9D008C38  00401821   ADDU V1, V0, ZERO
9D008C3C  3C02A000   LUI V0, -24576
9D008C40  8FC50018   LW A1, 24(S8)
9D008C44  24040041   ADDIU A0, ZERO, 65
9D008C48  70A42002   MUL A0, A1, A0
9D008C4C  00831821   ADDU V1, A0, V1
9D008C50  24420334   ADDIU V0, V0, 820
9D008C54  00621021   ADDU V0, V1, V0
9D008C58  A0400000   SB ZERO, 0(V0)
137:                 
138:                 	// read receive register to clear any pending receive interrupts (read clears xxxx)
139:                 
140:                 	// enable RX interrupts
141:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_ENABLED);
9D008C5C  8FC20018   LW V0, 24(S8)
9D008C60  24420022   ADDIU V0, V0, 34
9D008C64  00402021   ADDU A0, V0, ZERO
9D008C68  24050001   ADDIU A1, ZERO, 1
9D008C6C  0F403832   JAL INTEnable
9D008C70  00000000   NOP
142:                 
143:                 	return TRUE;
9D008C74  24020001   ADDIU V0, ZERO, 1
144:                 	}
9D008C78  03C0E821   ADDU SP, S8, ZERO
9D008C7C  8FBF0014   LW RA, 20(SP)
9D008C80  8FBE0010   LW S8, 16(SP)
9D008C84  27BD0018   ADDIU SP, SP, 24
9D008C88  03E00008   JR RA
9D008C8C  00000000   NOP
145:                 
146:                 
147:                 //*********************************************************
148:                 //					AnyRxDataAvailable
149:                 //*********************************************************
150:                 
151:                 //  indicates if there is data in the serial I/O receive buffer. Does NOT actually remove data.
152:                 //	returns: bYES or bNO
153:                 //	does NOT pull any data from the receive buffer and does NOT change buffer indicies
154:                 
155:                 // ==> is there really any need to disable interrupts here? This function has to be called repeatedly,
156:                 // and the only change that can occur as a result of an interrupt if from NO data to SOME data available..
157:                 
158:                 BOOL AnyRxDataAvailable(UART_MODULE UARTid)
159:                 {
9D008C90  27BDFFE0   ADDIU SP, SP, -32
9D008C94  AFBF001C   SW RA, 28(SP)
9D008C98  AFBE0018   SW S8, 24(SP)
9D008C9C  03A0F021   ADDU S8, SP, ZERO
9D008CA0  AFC40020   SW A0, 32(S8)
160:                 	BOOL bTemp = bYES;
9D008CA4  24020001   ADDIU V0, ZERO, 1
9D008CA8  AFC20010   SW V0, 16(S8)
161:                 	unsigned char ucInt;
162:                 
163:                 	// save interrupt state?
164:                 	// disable RX interrupts while checking status
165:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_DISABLED);
9D008CAC  8FC20020   LW V0, 32(S8)
9D008CB0  24420022   ADDIU V0, V0, 34
9D008CB4  00402021   ADDU A0, V0, ZERO
9D008CB8  00002821   ADDU A1, ZERO, ZERO
9D008CBC  0F403832   JAL INTEnable
9D008CC0  00000000   NOP
166:                 
167:                 	// if the receive IN buffer index is the same as the receive OUT buffer index, there is no new data available
168:                 	if(ucsRxdInIndex[UARTid] == ucsRxdOutIndex[UARTid])
9D008CC4  3C02A000   LUI V0, -24576
9D008CC8  24430244   ADDIU V1, V0, 580
9D008CCC  8FC20020   LW V0, 32(S8)
9D008CD0  00621021   ADDU V0, V1, V0
9D008CD4  90420000   LBU V0, 0(V0)
9D008CD8  304300FF   ANDI V1, V0, 255
9D008CDC  3C02A000   LUI V0, -24576
9D008CE0  24440248   ADDIU A0, V0, 584
9D008CE4  8FC20020   LW V0, 32(S8)
9D008CE8  00821021   ADDU V0, A0, V0
9D008CEC  90420000   LBU V0, 0(V0)
9D008CF0  304200FF   ANDI V0, V0, 255
9D008CF4  14620002   BNE V1, V0, 0x9D008D00
9D008CF8  00000000   NOP
169:                 		bTemp = bNO;
9D008CFC  AFC00010   SW ZERO, 16(S8)
170:                 
171:                 	// re-enable RX interrupts
172:                 	// ==>> this should only be enabled if the interrupts were enabled upon entry..
173:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_ENABLED);
9D008D00  8FC20020   LW V0, 32(S8)
9D008D04  24420022   ADDIU V0, V0, 34
9D008D08  00402021   ADDU A0, V0, ZERO
9D008D0C  24050001   ADDIU A1, ZERO, 1
9D008D10  0F403832   JAL INTEnable
9D008D14  00000000   NOP
174:                 
175:                 	return(bTemp);
9D008D18  8FC20010   LW V0, 16(S8)
176:                 }
9D008D1C  03C0E821   ADDU SP, S8, ZERO
9D008D20  8FBF001C   LW RA, 28(SP)
9D008D24  8FBE0018   LW S8, 24(SP)
9D008D28  27BD0020   ADDIU SP, SP, 32
9D008D2C  03E00008   JR RA
9D008D30  00000000   NOP
177:                 
178:                 
179:                 //*********************************************************
180:                 //					Read Rx Data
181:                 //*********************************************************
182:                 
183:                 // returns a single byte of data from the ring buffer, and bumps the read index
184:                 // NOTE: there is no error return, the caller must check AnyRxDataAvailable() becore calling ReadRxdData()
185:                 
186:                 unsigned char ReadRxdData(UART_MODULE UARTid)
187:                 {
9D008D34  27BDFFE0   ADDIU SP, SP, -32
9D008D38  AFBF001C   SW RA, 28(SP)
9D008D3C  AFBE0018   SW S8, 24(SP)
9D008D40  03A0F021   ADDU S8, SP, ZERO
9D008D44  AFC40020   SW A0, 32(S8)
188:                 	unsigned char ucTemp;
189:                 	unsigned char ucInt;
190:                 
191:                 	// disable RX interrupts while setting reading Rx data
192:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_DISABLED);
9D008D48  8FC20020   LW V0, 32(S8)
9D008D4C  24420022   ADDIU V0, V0, 34
9D008D50  00402021   ADDU A0, V0, ZERO
9D008D54  00002821   ADDU A1, ZERO, ZERO
9D008D58  0F403832   JAL INTEnable
9D008D5C  00000000   NOP
193:                 
194:                 	ucTemp = ucsRxdData[UARTid][ucsRxdOutIndex[UARTid]];	// read byte from ring buffer
9D008D60  3C02A000   LUI V0, -24576
9D008D64  24430248   ADDIU V1, V0, 584
9D008D68  8FC20020   LW V0, 32(S8)
9D008D6C  00621021   ADDU V0, V1, V0
9D008D70  90420000   LBU V0, 0(V0)
9D008D74  304200FF   ANDI V0, V0, 255
9D008D78  00401821   ADDU V1, V0, ZERO
9D008D7C  3C02A000   LUI V0, -24576
9D008D80  8FC50020   LW A1, 32(S8)
9D008D84  24040041   ADDIU A0, ZERO, 65
9D008D88  70A42002   MUL A0, A1, A0
9D008D8C  00831821   ADDU V1, A0, V1
9D008D90  24420334   ADDIU V0, V0, 820
9D008D94  00621021   ADDU V0, V1, V0
9D008D98  90420000   LBU V0, 0(V0)
9D008D9C  A3C20010   SB V0, 16(S8)
195:                 
196:                 	if(++ucsRxdOutIndex[UARTid] > MAX_BUFFER_INDEX)		// bump copy of receive buffer OUT index and check for ring buffer wrap
9D008DA0  3C02A000   LUI V0, -24576
9D008DA4  24430248   ADDIU V1, V0, 584
9D008DA8  8FC20020   LW V0, 32(S8)
9D008DAC  00621021   ADDU V0, V1, V0
9D008DB0  90420000   LBU V0, 0(V0)
9D008DB4  304200FF   ANDI V0, V0, 255
9D008DB8  24420001   ADDIU V0, V0, 1
9D008DBC  304300FF   ANDI V1, V0, 255
9D008DC0  3C02A000   LUI V0, -24576
9D008DC4  24440248   ADDIU A0, V0, 584
9D008DC8  8FC20020   LW V0, 32(S8)
9D008DCC  00821021   ADDU V0, A0, V0
9D008DD0  A0430000   SB V1, 0(V0)
9D008DD4  3C02A000   LUI V0, -24576
9D008DD8  24430248   ADDIU V1, V0, 584
9D008DDC  8FC20020   LW V0, 32(S8)
9D008DE0  00621021   ADDU V0, V1, V0
9D008DE4  90420000   LBU V0, 0(V0)
9D008DE8  304200FF   ANDI V0, V0, 255
9D008DEC  2C420041   SLTIU V0, V0, 65
9D008DF0  14400006   BNE V0, ZERO, 0x9D008E0C
9D008DF4  00000000   NOP
197:                 	    ucsRxdOutIndex[UARTid] = 0;						// reset ring buffer index
9D008DF8  3C02A000   LUI V0, -24576
9D008DFC  24430248   ADDIU V1, V0, 584
9D008E00  8FC20020   LW V0, 32(S8)
9D008E04  00621021   ADDU V0, V1, V0
9D008E08  A0400000   SB ZERO, 0(V0)
198:                 
199:                 	// enable RX interrupts
200:                 	INTEnable(INT_SOURCE_UART_RX(UARTid), INT_ENABLED);
9D008E0C  8FC20020   LW V0, 32(S8)
9D008E10  24420022   ADDIU V0, V0, 34
9D008E14  00402021   ADDU A0, V0, ZERO
9D008E18  24050001   ADDIU A1, ZERO, 1
9D008E1C  0F403832   JAL INTEnable
9D008E20  00000000   NOP
201:                 
202:                 	return(ucTemp);									// return received byte
9D008E24  93C20010   LBU V0, 16(S8)
203:                 }
9D008E28  03C0E821   ADDU SP, S8, ZERO
9D008E2C  8FBF001C   LW RA, 28(SP)
9D008E30  8FBE0018   LW S8, 24(SP)
9D008E34  27BD0020   ADDIU SP, SP, 32
9D008E38  03E00008   JR RA
9D008E3C  00000000   NOP
204:                 
205:                 
206:                 
207:                 //*****************************************************************************
208:                 //								Serial Transmit
209:                 //*****************************************************************************
210:                 
211:                 
212:                 //*********************************************************
213:                 //					IsTransmitComplete
214:                 //*********************************************************
215:                 //  indicates if there is data in the serial I/O transmit buffer.
216:                 //	returns: bYES or bNO
217:                 
218:                 // ==> is there really any need to disable interrupts here? This function has to be called repeatedly,
219:                 // and the only change that can occur as a result of an interrupt if from NO data to SOME data available..
220:                 
221:                 // this function code was derived from the revised RFStamp:interrupt.c code
222:                 
223:                 unsigned char IsTransmitComplete(UART_MODULE UARTid)
224:                 {
9D008E40  27BDFFE0   ADDIU SP, SP, -32
9D008E44  AFBF001C   SW RA, 28(SP)
9D008E48  AFBE0018   SW S8, 24(SP)
9D008E4C  03A0F021   ADDU S8, SP, ZERO
9D008E50  AFC40020   SW A0, 32(S8)
225:                 	unsigned char ucTemp = bNO;
9D008E54  A3C00010   SB ZERO, 16(S8)
226:                 
227:                 	// disable Transmit Interrupts while checking status
228:                 	INTEnable(INT_SOURCE_UART_TX(UARTid), INT_DISABLED);
9D008E58  8FC20020   LW V0, 32(S8)
9D008E5C  24420024   ADDIU V0, V0, 36
9D008E60  00402021   ADDU A0, V0, ZERO
9D008E64  00002821   ADDU A1, ZERO, ZERO
9D008E68  0F403832   JAL INTEnable
9D008E6C  00000000   NOP
229:                 
230:                 	// if the Transmit IN buffer index is the same as the Transmit OUT buffer index, all data has been transmitted .. or at least transferred to the MCU FIFO
231:                 	// check the MCU to make sure all data in the TX FIFO has been sent
232:                 	if ((bTxDone[UARTid] IS TRUE) AND (UARTTransmissionHasCompleted(UARTid) IS TRUE))
9D008E70  3C02A000   LUI V0, -24576
9D008E74  8FC30020   LW V1, 32(S8)
9D008E78  00031880   SLL V1, V1, 2
9D008E7C  24420254   ADDIU V0, V0, 596
9D008E80  00621021   ADDU V0, V1, V0
9D008E84  8C430000   LW V1, 0(V0)
9D008E88  24020001   ADDIU V0, ZERO, 1
9D008E8C  14620017   BNE V1, V0, 0x9D008EEC
9D008E90  00000000   NOP
9D008E94  8FC20020   LW V0, 32(S8)
9D008E98  AFC20014   SW V0, 20(S8)
9D008ED4  00401821   ADDU V1, V0, ZERO
233:                 		ucTemp = bYES;
9D008EE4  24020001   ADDIU V0, ZERO, 1
9D008EE8  A3C20010   SB V0, 16(S8)
234:                 
235:                 	// done, enable Transmit Interrupts
236:                 	INTEnable(INT_SOURCE_UART_TX(UARTid), INT_ENABLED);
9D008EEC  8FC20020   LW V0, 32(S8)
9D008EF0  24420024   ADDIU V0, V0, 36
9D008EF4  00402021   ADDU A0, V0, ZERO
9D008EF8  24050001   ADDIU A1, ZERO, 1
9D008EFC  0F403832   JAL INTEnable
9D008F00  00000000   NOP
237:                 
238:                 	return(ucTemp);
9D008F04  93C20010   LBU V0, 16(S8)
239:                 }
9D008F08  03C0E821   ADDU SP, S8, ZERO
9D008F0C  8FBF001C   LW RA, 28(SP)
9D008F10  8FBE0018   LW S8, 24(SP)
9D008F14  27BD0020   ADDIU SP, SP, 32
9D008F18  03E00008   JR RA
9D008F1C  00000000   NOP
240:                 
241:                 
242:                 
243:                 //*********************************************************
244:                 //				StartTransmitString
245:                 //*********************************************************
246:                 
247:                 // this DOES work, but it is wasteful because the entire string is copied from ROM to RAM
248:                 
249:                 void StartTransmitString(UART_MODULE UARTid, const char *pstrString)
250:                 {
9D008F20  27BDFFE0   ADDIU SP, SP, -32
9D008F24  AFBF001C   SW RA, 28(SP)
9D008F28  AFBE0018   SW S8, 24(SP)
9D008F2C  03A0F021   ADDU S8, SP, ZERO
9D008F30  AFC40020   SW A0, 32(S8)
9D008F34  AFC50024   SW A1, 36(S8)
251:                 
252:                 	// disable Transmit Interrupts while setting up transmit string
253:                 	INTEnable(INT_SOURCE_UART_TX(UARTid), INT_DISABLED);
9D008F38  8FC20020   LW V0, 32(S8)
9D008F3C  24420024   ADDIU V0, V0, 36
9D008F40  00402021   ADDU A0, V0, ZERO
9D008F44  00002821   ADDU A1, ZERO, ZERO
9D008F48  0F403832   JAL INTEnable
9D008F4C  00000000   NOP
254:                 
255:                 	// set pointer to string to transmit
256:                 	// string is NOT copied to an output buffer, so it must remain intact until it has been transmitted
257:                 	// caller must check for completion by calling IsTransmitComplete() before transmitting another string
258:                 	(pISRTxData[UARTid]) = (char *)pstrString;
9D008F50  8FC30024   LW V1, 36(S8)
9D008F54  3C02A000   LUI V0, -24576
9D008F58  8FC40020   LW A0, 32(S8)
9D008F5C  00042080   SLL A0, A0, 2
9D008F60  2442024C   ADDIU V0, V0, 588
9D008F64  00821021   ADDU V0, A0, V0
9D008F68  AC430000   SW V1, 0(V0)
259:                 
260:                 	bTxDone[UARTid] = FALSE;								// mark as NOT done
9D008F6C  3C02A000   LUI V0, -24576
9D008F70  8FC30020   LW V1, 32(S8)
9D008F74  00031880   SLL V1, V1, 2
9D008F78  24420254   ADDIU V0, V0, 596
9D008F7C  00621021   ADDU V0, V1, V0
9D008F80  AC400000   SW ZERO, 0(V0)
261:                 
262:                 	// write a byte to the TX FIFO, to 'prime' the process
263:                 	UARTSendDataByte(UART2, *(pISRTxData[UARTid]));		// write data to transmit FIFO
9D008F84  3C02A000   LUI V0, -24576
9D008F88  8FC30020   LW V1, 32(S8)
9D008F8C  00031880   SLL V1, V1, 2
9D008F90  2442024C   ADDIU V0, V0, 588
9D008F94  00621021   ADDU V0, V1, V0
9D008F98  8C420000   LW V0, 0(V0)
9D008F9C  90420000   LBU V0, 0(V0)
9D008FA0  7C021420   SEB V0, V0
9D008FA4  304200FF   ANDI V0, V0, 255
9D008FA8  24030001   ADDIU V1, ZERO, 1
9D008FAC  AFC30010   SW V1, 16(S8)
9D008FB0  A3C20014   SB V0, 20(S8)
264:                 
265:                 	++(pISRTxData[UARTid]);								// bump data index
9D008FD4  3C02A000   LUI V0, -24576
9D008FD8  8FC30020   LW V1, 32(S8)
9D008FDC  00031880   SLL V1, V1, 2
9D008FE0  2442024C   ADDIU V0, V0, 588
9D008FE4  00621021   ADDU V0, V1, V0
9D008FE8  8C420000   LW V0, 0(V0)
9D008FEC  24430001   ADDIU V1, V0, 1
9D008FF0  3C02A000   LUI V0, -24576
9D008FF4  8FC40020   LW A0, 32(S8)
9D008FF8  00042080   SLL A0, A0, 2
9D008FFC  2442024C   ADDIU V0, V0, 588
9D009000  00821021   ADDU V0, A0, V0
9D009004  AC430000   SW V1, 0(V0)
266:                 
267:                 	// enable Transmit Interrupts
268:                 	INTEnable(INT_SOURCE_UART_TX(UARTid), INT_ENABLED);
9D009008  8FC20020   LW V0, 32(S8)
9D00900C  24420024   ADDIU V0, V0, 36
9D009010  00402021   ADDU A0, V0, ZERO
9D009014  24050001   ADDIU A1, ZERO, 1
9D009018  0F403832   JAL INTEnable
9D00901C  00000000   NOP
269:                 
270:                 	// wait for the entire string to be transmitted (enabled only for debugging and testing)
271:                 //	while (IsTransmitComplete(UARTid) IS bNO)
272:                 //		;
273:                 
274:                 }
9D009020  03C0E821   ADDU SP, S8, ZERO
9D009024  8FBF001C   LW RA, 28(SP)
9D009028  8FBE0018   LW S8, 24(SP)
9D00902C  27BD0020   ADDIU SP, SP, 32
9D009030  03E00008   JR RA
9D009034  00000000   NOP
275:                 
276:                 
277:                 //*************************************************************************************************
278:                 //									Interrupt Handlers
279:                 //*************************************************************************************************
280:                 
281:                 // UART 2 interrupt handler
282:                 // it is set at priority level 2
283:                 void __ISR(_UART2_VECTOR, ipl2) IntUart2Handler(void)
284:                 {
9D009038  415DE800   RDPGPR SP, SP
9D00903C  401A7000   MFC0 K0, EPC
9D009040  401B6000   MFC0 K1, Status
9D009044  27BDFF70   ADDIU SP, SP, -144
9D009048  AFBA008C   SW K0, 140(SP)
9D00904C  AFBB0088   SW K1, 136(SP)
9D009050  7C1B7844   INS K1, ZERO, 1, 15
9D009054  377B0800   ORI K1, K1, 2048
9D009058  409B6000   MTC0 K1, Status
9D00905C  AFBF007C   SW RA, 124(SP)
9D009060  AFBE0078   SW S8, 120(SP)
9D009064  AFB90074   SW T9, 116(SP)
9D009068  AFB80070   SW T8, 112(SP)
9D00906C  AFAF006C   SW T7, 108(SP)
9D009070  AFAE0068   SW T6, 104(SP)
9D009074  AFAD0064   SW T5, 100(SP)
9D009078  AFAC0060   SW T4, 96(SP)
9D00907C  AFAB005C   SW T3, 92(SP)
9D009080  AFAA0058   SW T2, 88(SP)
9D009084  AFA90054   SW T1, 84(SP)
9D009088  AFA80050   SW T0, 80(SP)
9D00908C  AFA7004C   SW A3, 76(SP)
9D009090  AFA60048   SW A2, 72(SP)
9D009094  AFA50044   SW A1, 68(SP)
9D009098  AFA40040   SW A0, 64(SP)
9D00909C  AFA3003C   SW V1, 60(SP)
9D0090A0  AFA20038   SW V0, 56(SP)
9D0090A4  AFA10034   SW AT, 52(SP)
9D0090A8  00001012   MFLO V0
9D0090AC  AFA20084   SW V0, 132(SP)
9D0090B0  00001810   MFHI V1
9D0090B4  AFA30080   SW V1, 128(SP)
9D0090B8  03A0F021   ADDU S8, SP, ZERO
285:                 
286:                 	if(INTGetFlag(INT_SOURCE_UART_RX(UART2)))
9D0090BC  24040023   ADDIU A0, ZERO, 35
9D0090C0  0F403956   JAL INTGetFlag
9D0090C4  00000000   NOP
9D0090C8  10400055   BEQ V0, ZERO, 0x9D009220
9D0090CC  00000000   NOP
287:                 	{
288:                 		//*********************************
289:                 		//		Serial Receive Int
290:                 		//*********************************
291:                 		UART_LINE_STATUS lineStatus;
292:                 
293:                 		// Clear the RX interrupt Flag
294:                 		INTClearFlag(INT_SOURCE_UART_RX(UART2));
9D0090D0  24040023   ADDIU A0, ZERO, 35
9D0090D4  0F403942   JAL INTClearFlag
9D0090D8  00000000   NOP
9D0090DC  24020001   ADDIU V0, ZERO, 1
9D0090E0  AFC20014   SW V0, 20(S8)
295:                 
296:                 		// Echo what we just received.
297:                 		//PutCharacter(UARTGetDataByte(UART2));
298:                 
299:                 		// Toggle LED to indicate UART activity
300:                 		//mPORTAToggleBits(BIT_7);
301:                 
302:                 		// check for receive error(s)
303:                 		lineStatus = UARTGetLineStatus(UART2);					// get line status to check for errors
9D009104  AFC20010   SW V0, 16(S8)
304:                 
305:                 		if(lineStatus & UART_FRAMING_ERROR)						// check for Framing errors
9D009108  8FC20010   LW V0, 16(S8)
9D00910C  30420004   ANDI V0, V0, 4
9D009110  10400004   BEQ V0, ZERO, 0x9D009124
9D009114  00000000   NOP
306:                 		{
307:                 			RuntimeError(SER_FSM_ERROR_RX_FRAMING_ERROR);
9D009118  240400AB   ADDIU A0, ZERO, 171
9D00911C  0F40365E   JAL _RuntimeError
9D009120  00000000   NOP
308:                 			// FERR bit will be cleared when RCREG1 is read below
309:                 		}
310:                 
311:                 		if(lineStatus & UART_OVERRUN_ERROR)						// check for Overrun errors
9D009124  8FC20010   LW V0, 16(S8)
9D009128  30420002   ANDI V0, V0, 2
9D00912C  10400004   BEQ V0, ZERO, 0x9D009140
9D009130  00000000   NOP
312:                 		{
313:                 			RuntimeError(SER_FSM_ERROR_RX_OVERRUN_ERROR);
9D009134  240400AC   ADDIU A0, ZERO, 172
9D009138  0F40365E   JAL _RuntimeError
9D00913C  00000000   NOP
9D009140  24020001   ADDIU V0, ZERO, 1
9D009144  AFC20018   SW V0, 24(S8)
314:                 			//RCSTAbits.CREN = 0;								// clear OERR bit
315:                 			//RCSTAbits.CREN = 1;								// re-enable receiver
316:                 		}
317:                 
318:                 		// we are not using parity, so we cannot check for parity errors
319:                 
320:                 		// copy a single byte from the Serial Receive REGISTER to the Rx ring buffer
321:                 		if (UARTReceivedDataIsAvailable(UART2))
9D009168  10400017   BEQ V0, ZERO, 0x9D0091C8
9D00916C  00000000   NOP
322:                 		{
323:                 			ucsRxdData[UART2][ucsRxdInIndex[UART2]] = UARTGetDataByte(UART2);	// read Rx register into Rx ring buffer
9D009170  3C02A000   LUI V0, -24576
9D009174  24420244   ADDIU V0, V0, 580
9D009178  90420001   LBU V0, 1(V0)
9D00917C  304200FF   ANDI V0, V0, 255
9D009180  00402021   ADDU A0, V0, ZERO
9D009184  24020001   ADDIU V0, ZERO, 1
9D009188  AFC2001C   SW V0, 28(S8)
9D0091AC  00401821   ADDU V1, V0, ZERO
324:                 		}
325:                 		else
326:                 		{
327:                 			RuntimeError(SER_FSM_ERROR_NO_RX_DATA_AVAILABLE);
9D0091C8  240400A9   ADDIU A0, ZERO, 169
9D0091CC  0F40365E   JAL _RuntimeError
9D0091D0  00000000   NOP
328:                 		}
329:                 		// bump Rx ring buffer IN index, and check for Rx ring buffer wrap
330:                 		if(++ucsRxdInIndex[UART2] > MAX_BUFFER_INDEX)
9D0091D4  3C02A000   LUI V0, -24576
9D0091D8  24420244   ADDIU V0, V0, 580
9D0091DC  90420001   LBU V0, 1(V0)
9D0091E0  304200FF   ANDI V0, V0, 255
9D0091E4  24420001   ADDIU V0, V0, 1
9D0091E8  304300FF   ANDI V1, V0, 255
9D0091EC  3C02A000   LUI V0, -24576
9D0091F0  24420244   ADDIU V0, V0, 580
9D0091F4  A0430001   SB V1, 1(V0)
9D0091F8  3C02A000   LUI V0, -24576
9D0091FC  24420244   ADDIU V0, V0, 580
9D009200  90420001   LBU V0, 1(V0)
9D009204  304200FF   ANDI V0, V0, 255
9D009208  2C420041   SLTIU V0, V0, 65
9D00920C  14400004   BNE V0, ZERO, 0x9D009220
9D009210  00000000   NOP
331:                 		{
332:                 			ucsRxdInIndex[UART2] = 0;						// wrap Rx ring buffer IN index
9D009214  3C02A000   LUI V0, -24576
9D009218  24420244   ADDIU V0, V0, 580
9D00921C  A0400001   SB ZERO, 1(V0)
333:                 		}
334:                 	}
335:                 
336:                 
337:                 	if ( INTGetFlag(INT_SOURCE_UART_TX(UART2)) )
9D009220  24040025   ADDIU A0, ZERO, 37
9D009224  0F403956   JAL INTGetFlag
9D009228  00000000   NOP
9D00922C  10400066   BEQ V0, ZERO, 0x9D0093C8
9D009230  00000000   NOP
338:                 	{
339:                 		//*********************************
340:                 		//		Serial Transmit Int
341:                 		//*********************************
342:                 		INTClearFlag(INT_SOURCE_UART_TX(UART2));						// clear the calling flag
9D009234  24040025   ADDIU A0, ZERO, 37
9D009238  0F403942   JAL INTClearFlag
9D00923C  00000000   NOP
9D009240  24020001   ADDIU V0, ZERO, 1
9D009244  AFC20020   SW V0, 32(S8)
343:                 
344:                 		if (UARTTransmitterIsReady(UART2))								// check for Transmit FIFO empty, TRUE == able to accept data
9D009280  10400051   BEQ V0, ZERO, 0x9D0093C8
9D009284  00000000   NOP
345:                 		////if (( PIR1bits.TX1IF == 1) AND (PIE1bits.TX1IE == 1))		// interrupt source TXIF AND Transmit Register Empty Interrupt Enabled? Transmit register EMPTY
346:                 		{
347:                 			// check for already done with serial transmit
348:                 			if (bTxDone[UART2] IS TRUE)
9D009288  3C02A000   LUI V0, -24576
9D00928C  24420254   ADDIU V0, V0, 596
9D009290  8C430004   LW V1, 4(V0)
9D009294  24020001   ADDIU V0, ZERO, 1
9D009298  14620010   BNE V1, V0, 0x9D0092DC
9D00929C  00000000   NOP
9D0092A0  24020001   ADDIU V0, ZERO, 1
9D0092A4  AFC20024   SW V0, 36(S8)
349:                 			{
350:                 				// we have already written the last byte to the transmit register, but it may NOT have been fully transmitted YET
351:                 				if (UARTTransmissionHasCompleted(UART2) IS TRUE)
352:                 				{
353:                 					// the transmit FIFO is empty, so we should not be here
354:                 //					RuntimeError(SER_FSM_ERROR_UNEXPECTED_TX_INT);
355:                 
356:                 					// here we have a bit of a conundrum.. we would like to clear the calling flag PIR1bits.TX1IF, which is done by writing to TXREG1.
357:                 					// but writing to TXREG1 means there is ANOTHER byte to transmit, which will result in yet another interrupt..
358:                 					// and clearing PIE1bits.TX1IE = 0  does NOT appear to prevent the interrupt from being handled!
359:                 					//TXREG1 = 'w';								// write data to transmit register ONLY to clear calling interrupt bit PIR1bits.TX1IF
360:                 				}
361:                 
362:                 				// disable Transmit Interrupts (should be redundant at this point)
363:                 				INTEnable(INT_SOURCE_UART_TX(UART2), INT_DISABLED);
9D0092C4  24040025   ADDIU A0, ZERO, 37
9D0092C8  00002821   ADDU A1, ZERO, ZERO
9D0092CC  0F403832   JAL INTEnable
9D0092D0  00000000   NOP
9D0092D4  0B4024F2   J 0x9D0093C8
9D0092D8  00000000   NOP
364:                 			}
365:                 			else			// if there is still a character in the transmit register, we are not done transmitting the last character of the string
366:                 			{
367:                 				// previous interrupt was NOT the last byte of the string
368:                 				// check for string overrun
369:                 				if (*(pISRTxData[UART2]) IS '\0')					// check for end of string
9D0092DC  3C02A000   LUI V0, -24576
9D0092E0  2442024C   ADDIU V0, V0, 588
9D0092E4  8C420004   LW V0, 4(V0)
9D0092E8  90420000   LBU V0, 0(V0)
9D0092EC  7C021420   SEB V0, V0
9D0092F0  1440000E   BNE V0, ZERO, 0x9D00932C
9D0092F4  00000000   NOP
370:                 				{
371:                 					// we should never get a 0 byte at this point
372:                 					RuntimeError(SER_FSM_ERROR_NO_TX_DATA_AVAILABLE);
9D0092F8  240400A8   ADDIU A0, ZERO, 168
9D0092FC  0F40365E   JAL _RuntimeError
9D009300  00000000   NOP
373:                 					bTxDone[UART2] = TRUE;
9D009304  3C02A000   LUI V0, -24576
9D009308  24420254   ADDIU V0, V0, 596
9D00930C  24030001   ADDIU V1, ZERO, 1
9D009310  AC430004   SW V1, 4(V0)
374:                 
375:                 					// disable Transmit Interrupts
376:                 					INTEnable(INT_SOURCE_UART_TX(UART2), INT_DISABLED);
9D009314  24040025   ADDIU A0, ZERO, 37
9D009318  00002821   ADDU A1, ZERO, ZERO
9D00931C  0F403832   JAL INTEnable
9D009320  00000000   NOP
9D009324  0B4024F2   J 0x9D0093C8
9D009328  00000000   NOP
377:                 
378:                 					//TXREG = 'y';							// write data to transmit register ONLY to clear calling interrupt bit PIR1bits.TX1IF
379:                 				}
380:                 				else
381:                 				{
382:                 					// write data to transmit register
383:                 					//while (UARTTransmitterIsReady(UART2))
384:                 					//{
385:                 					//	UARTSendData(UART1, data);
386:                 					//}
387:                 
388:                 					UARTSendDataByte(UART2, *(pISRTxData[UART2]));		// write data to transmit FIFO
9D00932C  3C02A000   LUI V0, -24576
9D009330  2442024C   ADDIU V0, V0, 588
9D009334  8C420004   LW V0, 4(V0)
9D009338  90420000   LBU V0, 0(V0)
9D00933C  7C021420   SEB V0, V0
9D009340  304200FF   ANDI V0, V0, 255
9D009344  24030001   ADDIU V1, ZERO, 1
9D009348  AFC30028   SW V1, 40(S8)
9D00934C  A3C2002C   SB V0, 44(S8)
389:                 
390:                 					++(pISRTxData[UART2]);								// bump data pointer
9D009370  3C02A000   LUI V0, -24576
9D009374  2442024C   ADDIU V0, V0, 588
9D009378  8C420004   LW V0, 4(V0)
9D00937C  24430001   ADDIU V1, V0, 1
9D009380  3C02A000   LUI V0, -24576
9D009384  2442024C   ADDIU V0, V0, 588
9D009388  AC430004   SW V1, 4(V0)
391:                 
392:                 					// check for end of string
393:                 					if (*(pISRTxData[UART2]) IS '\0')
9D00938C  3C02A000   LUI V0, -24576
9D009390  2442024C   ADDIU V0, V0, 588
9D009394  8C420004   LW V0, 4(V0)
9D009398  90420000   LBU V0, 0(V0)
9D00939C  7C021420   SEB V0, V0
9D0093A0  14400009   BNE V0, ZERO, 0x9D0093C8
9D0093A4  00000000   NOP
394:                 					{
395:                 						// we have reached the end of the string
396:                 						bTxDone[UART2] = TRUE;
9D0093A8  3C02A000   LUI V0, -24576
9D0093AC  24420254   ADDIU V0, V0, 596
9D0093B0  24030001   ADDIU V1, ZERO, 1
9D0093B4  AC430004   SW V1, 4(V0)
397:                 						// disable Transmit Interrupts
398:                 						INTEnable(INT_SOURCE_UART_TX(UART2), INT_DISABLED);
9D0093B8  24040025   ADDIU A0, ZERO, 37
9D0093BC  00002821   ADDU A1, ZERO, ZERO
9D0093C0  0F403832   JAL INTEnable
9D0093C4  00000000   NOP
399:                 					}
400:                 				}
401:                 
402:                 			}		// end if NOT (bTxDone[UART2] IS TRUE)
403:                 
404:                 		}		// end if (UARTTransmitterIsReady(UART2))
405:                 
406:                 	}		// end if ( INTGetFlag(INT_SOURCE_UART_TX(UART2)) )
407:                 }
9D0093C8  03C0E821   ADDU SP, S8, ZERO
9D0093CC  8FA20084   LW V0, 132(SP)
9D0093D0  00400013   MTLO V0
9D0093D4  8FA30080   LW V1, 128(SP)
9D0093D8  00600011   MTHI V1
9D0093DC  8FBF007C   LW RA, 124(SP)
9D0093E0  8FBE0078   LW S8, 120(SP)
9D0093E4  8FB90074   LW T9, 116(SP)
9D0093E8  8FB80070   LW T8, 112(SP)
9D0093EC  8FAF006C   LW T7, 108(SP)
9D0093F0  8FAE0068   LW T6, 104(SP)
9D0093F4  8FAD0064   LW T5, 100(SP)
9D0093F8  8FAC0060   LW T4, 96(SP)
9D0093FC  8FAB005C   LW T3, 92(SP)
9D009400  8FAA0058   LW T2, 88(SP)
9D009404  8FA90054   LW T1, 84(SP)
9D009408  8FA80050   LW T0, 80(SP)
9D00940C  8FA7004C   LW A3, 76(SP)
9D009410  8FA60048   LW A2, 72(SP)
9D009414  8FA50044   LW A1, 68(SP)
9D009418  8FA40040   LW A0, 64(SP)
9D00941C  8FA3003C   LW V1, 60(SP)
9D009420  8FA20038   LW V0, 56(SP)
9D009424  8FA10034   LW AT, 52(SP)
9D009428  41606000   DI ZERO
9D00942C  000000C0   EHB
9D009430  8FBA008C   LW K0, 140(SP)
9D009434  8FBB0088   LW K1, 136(SP)
9D009438  409A7000   MTC0 K0, EPC
9D00943C  27BD0090   ADDIU SP, SP, 144
9D009440  41DDE800   WRPGPR SP, SP
9D009444  409B6000   MTC0 K1, Status
9D009448  42000018   ERET
408:                 
409:                 
410:                 #ifdef NOTDEF
411:                 	// *****************************************************************************
412:                 	// void UARTTxBuffer(char *buffer, UINT32 size)
413:                 	// *****************************************************************************
414:                 	void SendDataBuffer(const char *buffer, UINT32 size)
415:                 	{
416:                 		while(size)
417:                 		{
418:                 			while(!UARTTransmitterIsReady(UART2))
419:                 				;
420:                 
421:                 			UARTSendDataByte(UART2, *buffer);
422:                 
423:                 			buffer++;
424:                 			size--;
425:                 		}
426:                 
427:                 		while(!UARTTransmissionHasCompleted(UART2))
428:                 			;
429:                 	}
430:                 	// *****************************************************************************
431:                 	// UINT32 GetDataBuffer(char *buffer, UINT32 max_size)
432:                 	// *****************************************************************************
433:                 	UINT32 GetDataBuffer(char *buffer, UINT32 max_size)
434:                 	{
435:                 		UINT32 num_char;
436:                 
437:                 		num_char = 0;
438:                 
439:                 		while(num_char < max_size)
440:                 		{
441:                 			UINT8 character;
442:                 
443:                 			while(!UARTReceivedDataIsAvailable(UART2))
444:                 				;
445:                 
446:                 			character = UARTGetDataByte(UART2);
447:                 
448:                 			if(character == '\r')
449:                 				break;
450:                 
451:                 			*buffer = character;
452:                 
453:                 			buffer++;
454:                 			num_char++;
455:                 		}
456:                 
457:                 		return num_char;
458:                 	}
459:                 	// *****************************************************************************
460:                 	// UINT32 GetMenuChoice(void)
461:                 	// *****************************************************************************
462:                 	UINT32 GetMenuChoice(void)
463:                 	{
464:                 		UINT8  menu_item;
465:                 
466:                 		while(!UARTReceivedDataIsAvailable(UART2))
467:                 			;
468:                 
469:                 		menu_item = UARTGetDataByte(UART2);
470:                 
471:                 		menu_item -= '0';
472:                 
473:                 		return (UINT32)menu_item;
474:                 	}
475:                 #endif
476:                 
477:                 // end of SerialPort.c
478:                 
---  F:/Smarttrak/Microchip_PIC32MX/SmartTrak_2_Axis_Controller/BSP/SST25VF016.c  -----------------------
1:                   /*****************************************************************************
2:                    *
3:                    * Basic access to SPI Flash SST25VF016 located on 
4:                    * Graphics LCD Controller PICtail Plus SSD1926 Board.
5:                    *
6:                    *****************************************************************************
7:                    * FileName:        SST25VF016.c
8:                    * Dependencies:    SST25VF016.h
9:                    * Processor:       PIC24F, PIC24H, dsPIC, PIC32
10:                   * Compiler:       	MPLAB C30 V3.00, MPLAB C32
11:                   * Linker:          MPLAB LINK30, MPLAB LINK32
12:                   * Company:         Microchip Technology Incorporated
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright ï¿½ 2008 Microchip Technology Inc.  All rights reserved.
17:                   * Microchip licenses to you the right to use, modify, copy and distribute
18:                   * Software only when embedded on a Microchip microcontroller or digital
19:                   * signal controller, which is integrated into your product or third party
20:                   * product (pursuant to the sublicense terms in the accompanying license
21:                   * agreement).  
22:                   *
23:                   * You should refer to the license agreement accompanying this Software
24:                   * for additional information regarding your rights and obligations.
25:                   *
26:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED ï¿½AS ISï¿½ WITHOUT WARRANTY OF ANY
27:                   * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
28:                   * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
29:                   * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
30:                   * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
31:                   * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
32:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
33:                   * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
34:                   * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
35:                   * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
36:                   * OR OTHER SIMILAR COSTS.
37:                   *
38:                   * Author               Date        Comment
39:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
40:                   * Anton Alkhimenok		01/07/09	...
41:                   * 12 Feb 13 <sek> modified SST25Init() for PICTail+ SPI Flash board with SST25VF016, cooments, removed unused code
42:                   * 26 Feb 13 <sek> SST25ReadID()
43:                  
44:                   *****************************************************************************/
45:                  #include <GenericTypeDefs.h>
46:                  #include "..\HardwareProfile.h"
47:                  
48:                  #include "gsfstd.h"						// gsf standard #defines
49:                  
50:                  #include "SST25VF016.h"
51:                  
52:                  #ifndef __PIC32MX__
53:                  	#error	"SST25VF016.C only supports PIC32MX SPI Implementation"
54:                  #endif
55:                  
56:                  
57:                  /************************************************************************
58:                  * Function: SST25Init                                                  
59:                  *                                                                       
60:                  * Overview: this function setup SPI and IOs connected to SST25
61:                  *                                                                       
62:                  * Input: none                                                          
63:                  *                                                                       
64:                  * Output: none
65:                  *                                                                       
66:                  ************************************************************************/
67:                  void SST25Init(void)
68:                  {
9D007624  27BDFFE8   ADDIU SP, SP, -24
9D007628  AFBF0014   SW RA, 20(SP)
9D00762C  AFBE0010   SW S8, 16(SP)
9D007630  03A0F021   ADDU S8, SP, ZERO
69:                  
70:                      /************************************************************************
71:                      * For Explorer 16 RD12 is connected to EEPROM chip select.
72:                      * To prevent a conflict between this EEPROM and SST25 flash
73:                      * RD12 should be pulled up.
74:                      ************************************************************************/
75:                      // Initialize SPI
76:                  	SST25_SPISTAT = 0;				// clear all status bits (not all can be written)
9D007634  3C02BF80   LUI V0, -16512
9D007638  AC405810   SW ZERO, 22544(V0)
77:                  	SST25_SPIBRG = 0;				// clear Baud Rate Divisor bits
9D00763C  3C02BF80   LUI V0, -16512
9D007640  AC405830   SW ZERO, 22576(V0)
78:                  
79:                  	SST25_SPICON = 0;				// initialize all SPI1CON bits to 0, no framed support
9D007644  3C02BF80   LUI V0, -16512
9D007648  AC405800   SW ZERO, 22528(V0)
80:                  									// MCLKSEL:Master Clock Select bit, 0= PBCLK is used by the Baud Rate Generator
81:                  									// ENHBUF: Enhanced Buffer Enable bit, 0= Enhanced Buffer mode is disabled
82:                  									// SIDL: Stop in Idle Mode bit, 0= Continue operation in Idle mode
83:                  									// DISSDO: Disable SDOx pin bit, 0= SDOx pin is controlled by the module
84:                  									// MODE<32,16>: 32/16-bit Communication Select bits, there is no AUDEN bit in this MCU, so assume 0
85:                  									//		When AUDEN = 0, 0 : 8-bit
86:                  									// DISSDI: Disable SDI bit, 0= SDIx pin is controlled by the SPI module
87:                  
88:                  	SST25_SPICONbits.MSTEN = 1;		// Master Mode Enable bit, 1 = Master mode
9D00764C  3C03BF80   LUI V1, -16512
9D007650  8C625800   LW V0, 22528(V1)
9D007654  24040001   ADDIU A0, ZERO, 1
9D007658  7C822944   INS V0, A0, 5, 1
9D00765C  AC625800   SW V0, 22528(V1)
89:                  	SST25_SPICONbits.CKP = 0;		// Clock Polarity Select bit, 0 = Idle state for clock is a low level; active state is a high level
9D007660  3C03BF80   LUI V1, -16512
9D007664  8C625800   LW V0, 22528(V1)
9D007668  7C023184   INS V0, ZERO, 6, 1
9D00766C  AC625800   SW V0, 22528(V1)
90:                  	SST25_SPICONbits.CKE = 1;		// SPI Clock Edge Select bit, 1 = Serial output data changes on transition from active clock state to idle clock state (see CKP bit)
9D007670  3C03BF80   LUI V1, -16512
9D007674  8C625800   LW V0, 22528(V1)
9D007678  24040001   ADDIU A0, ZERO, 1
9D00767C  7C824204   INS V0, A0, 8, 1
9D007680  AC625800   SW V0, 22528(V1)
91:                  	SST25_SPICONbits.SMP = 1;		// SPI Data Input Sample Phase bit, Master mode (MSTEN = 1): 1= Input data sampled at end of data output time
9D007684  3C03BF80   LUI V1, -16512
9D007688  8C625800   LW V0, 22528(V1)
9D00768C  24040001   ADDIU A0, ZERO, 1
9D007690  7C824A44   INS V0, A0, 9, 1
9D007694  AC625800   SW V0, 22528(V1)
92:                  
93:                  	SST25_SPIBRG = 1;				// bit 12-0 BRG<12:0>: Baud Rate Divisor bits
9D007698  3C02BF80   LUI V0, -16512
9D00769C  24030001   ADDIU V1, ZERO, 1
9D0076A0  AC435830   SW V1, 22576(V0)
94:                  	SST25_SPICONbits.ON = 1;		// ON: SPI Peripheral On bit, 1= SPI Peripheral is enabled
9D0076A4  3C03BF80   LUI V1, -16512
9D0076A8  8C625800   LW V0, 22528(V1)
9D0076AC  24040001   ADDIU A0, ZERO, 1
9D0076B0  7C827BC4   INS V0, A0, 15, 1
9D0076B4  AC625800   SW V0, 22528(V1)
95:                  
96:                  
97:                  	// Set IOs directions for SST25 SPI
98:                      SST25_CS_LAT = 1;					// /CS is initially NOT selected
9D0076B8  3C03BF88   LUI V1, -16504
9D0076BC  8C626160   LW V0, 24928(V1)
9D0076C0  24040001   ADDIU A0, ZERO, 1
9D0076C4  7C821084   INS V0, A0, 2, 1
9D0076C8  AC626160   SW V0, 24928(V1)
99:                      SST25_CS_TRIS = 0;					// set /CS to OUTPUT
9D0076CC  3C03BF88   LUI V1, -16504
9D0076D0  8C626140   LW V0, 24896(V1)
9D0076D4  7C021084   INS V0, ZERO, 2, 1
9D0076D8  AC626140   SW V0, 24896(V1)
100:                 
101:                 	// /HOLD, change RA6 to RF1
102:                     SST25_HOLD_LAT = 1;					// /HOLD is initially NOT selected
9D0076DC  3C03BF88   LUI V1, -16504
9D0076E0  8C626160   LW V0, 24928(V1)
9D0076E4  24040001   ADDIU A0, ZERO, 1
9D0076E8  7C820844   INS V0, A0, 1, 1
9D0076EC  AC626160   SW V0, 24928(V1)
103:                     SST25_HOLD_TRIS = 0;				// set /HOLD to OUTPUT
9D0076F0  3C03BF88   LUI V1, -16504
9D0076F4  8C626140   LW V0, 24896(V1)
9D0076F8  7C020844   INS V0, ZERO, 1, 1
9D0076FC  AC626140   SW V0, 24896(V1)
104:                 
105:                     SST25ResetWriteProtection();
9D007700  0F401FCA   JAL SST25ResetWriteProtection
9D007704  00000000   NOP
106:                 }
9D007708  03C0E821   ADDU SP, S8, ZERO
9D00770C  8FBF0014   LW RA, 20(SP)
9D007710  8FBE0010   LW S8, 16(SP)
9D007714  27BD0018   ADDIU SP, SP, 24
9D007718  03E00008   JR RA
9D00771C  00000000   NOP
107:                 
108:                 /************************************************************************
109:                 * Function SPIPut(BYTE data)
110:                 *
111:                 * Overview:  this function sends a byte
112:                 *
113:                 * Input: byte to be sent
114:                 *
115:                 * Output: none
116:                 *
117:                 ************************************************************************/
118:                 void SPIPut(BYTE data)
119:                 {
9D007720  27BDFFF8   ADDIU SP, SP, -8
9D007724  AFBE0004   SW S8, 4(SP)
9D007728  03A0F021   ADDU S8, SP, ZERO
9D00772C  00801021   ADDU V0, A0, ZERO
9D007730  A3C20008   SB V0, 8(S8)
120:                 
121:                     // Wait for free buffer
122:                     while(!SST25_SPISTATbits.SPITBE)
9D007734  00000000   NOP
9D007738  3C02BF80   LUI V0, -16512
9D00773C  8C425810   LW V0, 22544(V0)
9D007740  30420008   ANDI V0, V0, 8
9D007744  1040FFFC   BEQ V0, ZERO, 0x9D007738
9D007748  00000000   NOP
123:                 		;
124:                     SST25_SPIBUF = data;
9D00774C  93C30008   LBU V1, 8(S8)
9D007750  3C02BF80   LUI V0, -16512
9D007754  AC435820   SW V1, 22560(V0)
125:                 
126:                     // Wait for data byte
127:                     while(!SST25_SPISTATbits.SPIRBF)
9D007758  00000000   NOP
9D00775C  3C02BF80   LUI V0, -16512
9D007760  8C425810   LW V0, 22544(V0)
9D007764  30420001   ANDI V0, V0, 1
9D007768  1040FFFC   BEQ V0, ZERO, 0x9D00775C
9D00776C  00000000   NOP
128:                 		;
129:                 }
9D007770  03C0E821   ADDU SP, S8, ZERO
9D007774  8FBE0004   LW S8, 4(SP)
9D007778  27BD0008   ADDIU SP, SP, 8
9D00777C  03E00008   JR RA
9D007780  00000000   NOP
130:                 
131:                 /************************************************************************
132:                 * Macros SPIGet()
133:                 *
134:                 * Overview:  this macros gets a byte from SPI
135:                 *
136:                 * Input: none
137:                 *
138:                 * Output: none
139:                 *
140:                 ************************************************************************/
141:                 #define SPIGet()     SST25_SPIBUF
142:                 
143:                 
144:                 /************************************************************************
145:                 * Function: SST25ReadID()
146:                 *
147:                 * Overview: this function reads JEDEC ID, Manufacturer, Device Type
148:                 *
149:                 * Input: none
150:                 *
151:                 * Output: TRUE is as expected, otherwise FALSE
152:                 
153:                 * See SST25VF016 datasheet Page 20
154:                 *
155:                 ************************************************************************/
156:                 BOOL SST25ReadID(BYTE *pData)
157:                 {
9D007784  27BDFFE0   ADDIU SP, SP, -32
9D007788  AFBF001C   SW RA, 28(SP)
9D00778C  AFBE0018   SW S8, 24(SP)
9D007790  03A0F021   ADDU S8, SP, ZERO
9D007794  AFC40020   SW A0, 32(S8)
158:                 	BOOL	bRetVal = TRUE;
9D007798  24020001   ADDIU V0, ZERO, 1
9D00779C  AFC20010   SW V0, 16(S8)
159:                     SST25CSLow();
9D0077A0  3C03BF88   LUI V1, -16504
9D0077A4  8C626160   LW V0, 24928(V1)
9D0077A8  7C021084   INS V0, ZERO, 2, 1
9D0077AC  AC626160   SW V0, 24928(V1)
160:                 
161:                     SPIPut(SST25_CMD_RD_JEDEC_ID);			// command to read JEDEC ID, clocks in received data
9D0077B0  2404009F   ADDIU A0, ZERO, 159
9D0077B4  0F401DC8   JAL SPIPut
9D0077B8  00000000   NOP
162:                     SPIGet();								// dummy read to clear SPI Rx register
9D0077BC  3C02BF80   LUI V0, -16512
9D0077C0  8C425820   LW V0, 22560(V0)
163:                 
164:                 	//**************************************
165:                 	SPIPut(0);								// dummy write to clock in 1st ID byte
9D0077C4  00002021   ADDU A0, ZERO, ZERO
9D0077C8  0F401DC8   JAL SPIPut
9D0077CC  00000000   NOP
166:                 	*pData = SPIGet();						// get a byte
9D0077D0  3C02BF80   LUI V0, -16512
9D0077D4  8C425820   LW V0, 22560(V0)
9D0077D8  304300FF   ANDI V1, V0, 255
9D0077DC  8FC20020   LW V0, 32(S8)
9D0077E0  A0430000   SB V1, 0(V0)
167:                 
168:                 	if (*pData IS_NOT ID_JEDEC_SST)			// verify JEDEC Manufacturer ID
9D0077E4  8FC20020   LW V0, 32(S8)
9D0077E8  90430000   LBU V1, 0(V0)
9D0077EC  240200BF   ADDIU V0, ZERO, 191
9D0077F0  10620002   BEQ V1, V0, 0x9D0077FC
9D0077F4  00000000   NOP
169:                 		bRetVal = FALSE;
9D0077F8  AFC00010   SW ZERO, 16(S8)
170:                 
171:                 	pData++;								// bump output buffer
9D0077FC  8FC20020   LW V0, 32(S8)
9D007800  24420001   ADDIU V0, V0, 1
9D007804  AFC20020   SW V0, 32(S8)
172:                 
173:                 	//**************************************
174:                 	SPIPut(0);								// dummy write to clock in 1st ID byte
9D007808  00002021   ADDU A0, ZERO, ZERO
9D00780C  0F401DC8   JAL SPIPut
9D007810  00000000   NOP
175:                 	*pData = SPIGet();						// get a byte
9D007814  3C02BF80   LUI V0, -16512
9D007818  8C425820   LW V0, 22560(V0)
9D00781C  304300FF   ANDI V1, V0, 255
9D007820  8FC20020   LW V0, 32(S8)
9D007824  A0430000   SB V1, 0(V0)
176:                 
177:                 	if (*pData IS_NOT ID_SPI_FLASH)			// verify device format
9D007828  8FC20020   LW V0, 32(S8)
9D00782C  90430000   LBU V1, 0(V0)
9D007830  24020025   ADDIU V0, ZERO, 37
9D007834  10620002   BEQ V1, V0, 0x9D007840
9D007838  00000000   NOP
178:                 		bRetVal = FALSE;
9D00783C  AFC00010   SW ZERO, 16(S8)
179:                 
180:                 	pData++;								// bump output buffer
9D007840  8FC20020   LW V0, 32(S8)
9D007844  24420001   ADDIU V0, V0, 1
9D007848  AFC20020   SW V0, 32(S8)
181:                 
182:                 	//**************************************
183:                 	SPIPut(0);								// dummy write to clock in 1st ID byte
9D00784C  00002021   ADDU A0, ZERO, ZERO
9D007850  0F401DC8   JAL SPIPut
9D007854  00000000   NOP
184:                 	*pData = SPIGet();						// get a byte
9D007858  3C02BF80   LUI V0, -16512
9D00785C  8C425820   LW V0, 22560(V0)
9D007860  304300FF   ANDI V1, V0, 255
9D007864  8FC20020   LW V0, 32(S8)
9D007868  A0430000   SB V1, 0(V0)
185:                 
186:                 	if (*pData IS_NOT ID_SST25VF016)		// verify specific device type
9D00786C  8FC20020   LW V0, 32(S8)
9D007870  90430000   LBU V1, 0(V0)
9D007874  24020041   ADDIU V0, ZERO, 65
9D007878  10620002   BEQ V1, V0, 0x9D007884
9D00787C  00000000   NOP
187:                 		bRetVal = FALSE;
9D007880  AFC00010   SW ZERO, 16(S8)
188:                 
189:                 
190:                     SST25CSHigh();
9D007884  3C03BF88   LUI V1, -16504
9D007888  8C626160   LW V0, 24928(V1)
9D00788C  24040001   ADDIU A0, ZERO, 1
9D007890  7C821084   INS V0, A0, 2, 1
9D007894  AC626160   SW V0, 24928(V1)
191:                 
192:                 	return bRetVal;
9D007898  8FC20010   LW V0, 16(S8)
193:                 }
9D00789C  03C0E821   ADDU SP, S8, ZERO
9D0078A0  8FBF001C   LW RA, 28(SP)
9D0078A4  8FBE0018   LW S8, 24(SP)
9D0078A8  27BD0020   ADDIU SP, SP, 32
9D0078AC  03E00008   JR RA
9D0078B0  00000000   NOP
194:                 
195:                 /************************************************************************
196:                 * Function: void SST25WriteByte(BYTE data, DWORD address)                                           
197:                 *                                                                       
198:                 * Overview: this function writes a byte to the address specified
199:                 *                                                                       
200:                 * Input: data to be written and address
201:                 *                                                                       
202:                 * Output: none                                 
203:                 *                                                                       
204:                 ************************************************************************/
205:                 void SST25WriteByte(BYTE data, DWORD address)
206:                 {
9D0078B4  27BDFFE8   ADDIU SP, SP, -24
9D0078B8  AFBF0014   SW RA, 20(SP)
9D0078BC  AFBE0010   SW S8, 16(SP)
9D0078C0  03A0F021   ADDU S8, SP, ZERO
9D0078C4  00801021   ADDU V0, A0, ZERO
9D0078C8  AFC5001C   SW A1, 28(S8)
9D0078CC  A3C20018   SB V0, 24(S8)
207:                     SST25WriteEnable();
9D0078D0  0F401EDE   JAL SST25WriteEnable
9D0078D4  00000000   NOP
208:                     SST25CSLow();
9D0078D8  3C03BF88   LUI V1, -16504
9D0078DC  8C626160   LW V0, 24928(V1)
9D0078E0  7C021084   INS V0, ZERO, 2, 1
9D0078E4  AC626160   SW V0, 24928(V1)
209:                 
210:                     SPIPut(SST25_CMD_BYTE_WRITE);			// <sek> was SST25_CMD_WRITE
9D0078E8  24040002   ADDIU A0, ZERO, 2
9D0078EC  0F401DC8   JAL SPIPut
9D0078F0  00000000   NOP
211:                     SPIGet();
9D0078F4  3C02BF80   LUI V0, -16512
9D0078F8  8C425820   LW V0, 22560(V0)
212:                 
213:                     SPIPut(((DWORD_VAL) address).v[2]);
9D0078FC  00001021   ADDU V0, ZERO, ZERO
9D007900  8FC2001C   LW V0, 28(S8)
9D007904  7C423C00   EXT V0, V0, 16, 8
9D007908  304200FF   ANDI V0, V0, 255
9D00790C  00402021   ADDU A0, V0, ZERO
9D007910  0F401DC8   JAL SPIPut
9D007914  00000000   NOP
214:                     SPIGet();
9D007918  3C02BF80   LUI V0, -16512
9D00791C  8C425820   LW V0, 22560(V0)
215:                 
216:                     SPIPut(((DWORD_VAL) address).v[1]);
9D007920  00001021   ADDU V0, ZERO, ZERO
9D007924  8FC2001C   LW V0, 28(S8)
9D007928  7C423A00   EXT V0, V0, 8, 8
9D00792C  304200FF   ANDI V0, V0, 255
9D007930  00402021   ADDU A0, V0, ZERO
9D007934  0F401DC8   JAL SPIPut
9D007938  00000000   NOP
217:                     SPIGet();
9D00793C  3C02BF80   LUI V0, -16512
9D007940  8C425820   LW V0, 22560(V0)
218:                 
219:                     SPIPut(((DWORD_VAL) address).v[0]);
9D007944  00001021   ADDU V0, ZERO, ZERO
9D007948  8FC2001C   LW V0, 28(S8)
9D00794C  304200FF   ANDI V0, V0, 255
9D007950  00402021   ADDU A0, V0, ZERO
9D007954  0F401DC8   JAL SPIPut
9D007958  00000000   NOP
220:                     SPIGet();
9D00795C  3C02BF80   LUI V0, -16512
9D007960  8C425820   LW V0, 22560(V0)
221:                 
222:                     SPIPut(data);
9D007964  93C20018   LBU V0, 24(S8)
9D007968  00402021   ADDU A0, V0, ZERO
9D00796C  0F401DC8   JAL SPIPut
9D007970  00000000   NOP
223:                     SPIGet();
9D007974  3C02BF80   LUI V0, -16512
9D007978  8C425820   LW V0, 22560(V0)
224:                 
225:                     SST25CSHigh();
9D00797C  3C03BF88   LUI V1, -16504
9D007980  8C626160   LW V0, 24928(V1)
9D007984  24040001   ADDIU A0, ZERO, 1
9D007988  7C821084   INS V0, A0, 2, 1
9D00798C  AC626160   SW V0, 24928(V1)
226:                 
227:                     // Wait for write end
228:                     while(SST25IsWriteBusy())
9D007990  00000000   NOP
9D007994  0F401EF6   JAL SST25IsWriteBusy
9D007998  00000000   NOP
9D00799C  1440FFFD   BNE V0, ZERO, 0x9D007994
9D0079A0  00000000   NOP
229:                 		;
230:                 }
9D0079A4  03C0E821   ADDU SP, S8, ZERO
9D0079A8  8FBF0014   LW RA, 20(SP)
9D0079AC  8FBE0010   LW S8, 16(SP)
9D0079B0  27BD0018   ADDIU SP, SP, 24
9D0079B4  03E00008   JR RA
9D0079B8  00000000   NOP
231:                 
232:                 /************************************************************************
233:                 * Function: BYTE SST25ReadByte(DWORD address)             
234:                 *                                                                       
235:                 * Overview: this function reads a byte from the address specified         
236:                 *                                                                       
237:                 * Input: address                                                     
238:                 *                                                                       
239:                 * Output: data read
240:                 *                                                                       
241:                 ************************************************************************/
242:                 BYTE SST25ReadByte(DWORD address)
243:                 {
9D0079BC  27BDFFE0   ADDIU SP, SP, -32
9D0079C0  AFBF001C   SW RA, 28(SP)
9D0079C4  AFBE0018   SW S8, 24(SP)
9D0079C8  03A0F021   ADDU S8, SP, ZERO
9D0079CC  AFC40020   SW A0, 32(S8)
244:                     BYTE    temp;
245:                     SST25CSLow();
9D0079D0  3C03BF88   LUI V1, -16504
9D0079D4  8C626160   LW V0, 24928(V1)
9D0079D8  7C021084   INS V0, ZERO, 2, 1
9D0079DC  AC626160   SW V0, 24928(V1)
246:                 
247:                     SPIPut(SST25_CMD_READ);
9D0079E0  24040003   ADDIU A0, ZERO, 3
9D0079E4  0F401DC8   JAL SPIPut
9D0079E8  00000000   NOP
248:                     SPIGet();
9D0079EC  3C02BF80   LUI V0, -16512
9D0079F0  8C425820   LW V0, 22560(V0)
249:                 
250:                     SPIPut(((DWORD_VAL) address).v[2]);
9D0079F4  00001021   ADDU V0, ZERO, ZERO
9D0079F8  8FC20020   LW V0, 32(S8)
9D0079FC  7C423C00   EXT V0, V0, 16, 8
9D007A00  304200FF   ANDI V0, V0, 255
9D007A04  00402021   ADDU A0, V0, ZERO
9D007A08  0F401DC8   JAL SPIPut
9D007A0C  00000000   NOP
251:                     SPIGet();
9D007A10  3C02BF80   LUI V0, -16512
9D007A14  8C425820   LW V0, 22560(V0)
252:                 
253:                     SPIPut(((DWORD_VAL) address).v[1]);
9D007A18  00001021   ADDU V0, ZERO, ZERO
9D007A1C  8FC20020   LW V0, 32(S8)
9D007A20  7C423A00   EXT V0, V0, 8, 8
9D007A24  304200FF   ANDI V0, V0, 255
9D007A28  00402021   ADDU A0, V0, ZERO
9D007A2C  0F401DC8   JAL SPIPut
9D007A30  00000000   NOP
254:                     SPIGet();
9D007A34  3C02BF80   LUI V0, -16512
9D007A38  8C425820   LW V0, 22560(V0)
255:                 
256:                     SPIPut(((DWORD_VAL) address).v[0]);
9D007A3C  00001021   ADDU V0, ZERO, ZERO
9D007A40  8FC20020   LW V0, 32(S8)
9D007A44  304200FF   ANDI V0, V0, 255
9D007A48  00402021   ADDU A0, V0, ZERO
9D007A4C  0F401DC8   JAL SPIPut
9D007A50  00000000   NOP
257:                     SPIGet();
9D007A54  3C02BF80   LUI V0, -16512
9D007A58  8C425820   LW V0, 22560(V0)
258:                 
259:                     SPIPut(0);
9D007A5C  00002021   ADDU A0, ZERO, ZERO
9D007A60  0F401DC8   JAL SPIPut
9D007A64  00000000   NOP
260:                     temp = SPIGet();
9D007A68  3C02BF80   LUI V0, -16512
9D007A6C  8C425820   LW V0, 22560(V0)
9D007A70  A3C20010   SB V0, 16(S8)
261:                 
262:                     SST25CSHigh();
9D007A74  3C03BF88   LUI V1, -16504
9D007A78  8C626160   LW V0, 24928(V1)
9D007A7C  24040001   ADDIU A0, ZERO, 1
9D007A80  7C821084   INS V0, A0, 2, 1
9D007A84  AC626160   SW V0, 24928(V1)
263:                     return (temp);
9D007A88  93C20010   LBU V0, 16(S8)
264:                 }
9D007A8C  03C0E821   ADDU SP, S8, ZERO
9D007A90  8FBF001C   LW RA, 28(SP)
9D007A94  8FBE0018   LW S8, 24(SP)
9D007A98  27BD0020   ADDIU SP, SP, 32
9D007A9C  03E00008   JR RA
9D007AA0  00000000   NOP
265:                 
266:                 /************************************************************************
267:                 * Function: void SST25WriteWord(WODR data, DWORD address)                                           
268:                 *                                                                       
269:                 * Overview: this function writes a 16-bit word to the address specified
270:                 *                                                                       
271:                 * Input: data to be written and address
272:                 *                                                                       
273:                 * Output: none                                                         
274:                 *                                                                       
275:                 ************************************************************************/
276:                 void SST25WriteWord(WORD data, DWORD address)
277:                 {
9D007AA4  27BDFFE8   ADDIU SP, SP, -24
9D007AA8  AFBF0014   SW RA, 20(SP)
9D007AAC  AFBE0010   SW S8, 16(SP)
9D007AB0  03A0F021   ADDU S8, SP, ZERO
9D007AB4  00801021   ADDU V0, A0, ZERO
9D007AB8  AFC5001C   SW A1, 28(S8)
9D007ABC  A7C20018   SH V0, 24(S8)
278:                     SST25WriteByte(((WORD_VAL) data).v[0], address);
9D007AC0  00001021   ADDU V0, ZERO, ZERO
9D007AC4  97C20018   LHU V0, 24(S8)
9D007AC8  304200FF   ANDI V0, V0, 255
9D007ACC  00402021   ADDU A0, V0, ZERO
9D007AD0  8FC5001C   LW A1, 28(S8)
9D007AD4  0F401E2D   JAL SST25WriteByte
9D007AD8  00000000   NOP
279:                     SST25WriteByte(((WORD_VAL) data).v[1], address + 1);
9D007ADC  00001021   ADDU V0, ZERO, ZERO
9D007AE0  97C20018   LHU V0, 24(S8)
9D007AE4  7C423A00   EXT V0, V0, 8, 8
9D007AE8  304200FF   ANDI V0, V0, 255
9D007AEC  00401821   ADDU V1, V0, ZERO
9D007AF0  8FC2001C   LW V0, 28(S8)
9D007AF4  24420001   ADDIU V0, V0, 1
9D007AF8  00602021   ADDU A0, V1, ZERO
9D007AFC  00402821   ADDU A1, V0, ZERO
9D007B00  0F401E2D   JAL SST25WriteByte
9D007B04  00000000   NOP
280:                 }
9D007B08  03C0E821   ADDU SP, S8, ZERO
9D007B0C  8FBF0014   LW RA, 20(SP)
9D007B10  8FBE0010   LW S8, 16(SP)
9D007B14  27BD0018   ADDIU SP, SP, 24
9D007B18  03E00008   JR RA
9D007B1C  00000000   NOP
281:                 
282:                 /************************************************************************
283:                 * Function: WORD SST25ReadWord(DWORD address)             
284:                 *                                                                       
285:                 * Overview: this function reads a 16-bit word from the address specified         
286:                 *                                                                       
287:                 * Input: address                                                     
288:                 *                                                                       
289:                 * Output: data read
290:                 *                                                                       
291:                 ************************************************************************/
292:                 WORD SST25ReadWord(DWORD address)
293:                 {
9D007B20  27BDFFE0   ADDIU SP, SP, -32
9D007B24  AFBF001C   SW RA, 28(SP)
9D007B28  AFBE0018   SW S8, 24(SP)
9D007B2C  03A0F021   ADDU S8, SP, ZERO
9D007B30  AFC40020   SW A0, 32(S8)
294:                     WORD_VAL    temp;
295:                 
296:                     temp.v[0] = SST25ReadByte(address);
9D007B34  8FC40020   LW A0, 32(S8)
9D007B38  0F401E6F   JAL SST25ReadByte
9D007B3C  00000000   NOP
9D007B40  A3C20010   SB V0, 16(S8)
297:                     temp.v[1] = SST25ReadByte(address + 1);
9D007B44  8FC20020   LW V0, 32(S8)
9D007B48  24420001   ADDIU V0, V0, 1
9D007B4C  00402021   ADDU A0, V0, ZERO
9D007B50  0F401E6F   JAL SST25ReadByte
9D007B54  00000000   NOP
9D007B58  A3C20011   SB V0, 17(S8)
298:                 
299:                     return (temp.Val);
9D007B5C  97C20010   LHU V0, 16(S8)
300:                 }
9D007B60  03C0E821   ADDU SP, S8, ZERO
9D007B64  8FBF001C   LW RA, 28(SP)
9D007B68  8FBE0018   LW S8, 24(SP)
9D007B6C  27BD0020   ADDIU SP, SP, 32
9D007B70  03E00008   JR RA
9D007B74  00000000   NOP
301:                 
302:                 /************************************************************************
303:                 * Function: SST25WriteEnable()                                         
304:                 *                                                                       
305:                 * Overview: this function allows write/erase SST25. Must be called  
306:                 * before every write/erase command.                                         
307:                 *                                                                       
308:                 * Input: none                                                          
309:                 *                                                                       
310:                 * Output: none                                 
311:                 *                                                                       
312:                 ************************************************************************/
313:                 void SST25WriteEnable(void)
314:                 {
9D007B78  27BDFFE8   ADDIU SP, SP, -24
9D007B7C  AFBF0014   SW RA, 20(SP)
9D007B80  AFBE0010   SW S8, 16(SP)
9D007B84  03A0F021   ADDU S8, SP, ZERO
315:                     SST25CSLow();
9D007B88  3C03BF88   LUI V1, -16504
9D007B8C  8C626160   LW V0, 24928(V1)
9D007B90  7C021084   INS V0, ZERO, 2, 1
9D007B94  AC626160   SW V0, 24928(V1)
316:                     SPIPut(SST25_CMD_WR_EN);				// <sek> was SST25_CMD_WREN
9D007B98  24040006   ADDIU A0, ZERO, 6
9D007B9C  0F401DC8   JAL SPIPut
9D007BA0  00000000   NOP
317:                     SPIGet();
9D007BA4  3C02BF80   LUI V0, -16512
9D007BA8  8C425820   LW V0, 22560(V0)
318:                     SST25CSHigh();
9D007BAC  3C03BF88   LUI V1, -16504
9D007BB0  8C626160   LW V0, 24928(V1)
9D007BB4  24040001   ADDIU A0, ZERO, 1
9D007BB8  7C821084   INS V0, A0, 2, 1
9D007BBC  AC626160   SW V0, 24928(V1)
319:                 }
9D007BC0  03C0E821   ADDU SP, S8, ZERO
9D007BC4  8FBF0014   LW RA, 20(SP)
9D007BC8  8FBE0010   LW S8, 16(SP)
9D007BCC  27BD0018   ADDIU SP, SP, 24
9D007BD0  03E00008   JR RA
9D007BD4  00000000   NOP
320:                 
321:                 /************************************************************************
322:                 * Function: BYTE SST25IsWriteBusy(void)  
323:                 *                                                                       
324:                 * Overview: this function reads status register and chek BUSY bit for write operation
325:                 *                                                                       
326:                 * Input: none                                                          
327:                 *                                                                       
328:                 * Output: non zero if busy
329:                 *                                                                       
330:                 ************************************************************************/
331:                 BYTE SST25IsWriteBusy(void)
332:                 {
9D007BD8  27BDFFE0   ADDIU SP, SP, -32
9D007BDC  AFBF001C   SW RA, 28(SP)
9D007BE0  AFBE0018   SW S8, 24(SP)
9D007BE4  03A0F021   ADDU S8, SP, ZERO
333:                     BYTE    temp;
334:                 
335:                     SST25CSLow();
9D007BE8  3C03BF88   LUI V1, -16504
9D007BEC  8C626160   LW V0, 24928(V1)
9D007BF0  7C021084   INS V0, ZERO, 2, 1
9D007BF4  AC626160   SW V0, 24928(V1)
336:                     SPIPut(SST25_CMD_RD_STATUS_REG);		// <sek> was SST25_CMD_RDSR
9D007BF8  24040005   ADDIU A0, ZERO, 5
9D007BFC  0F401DC8   JAL SPIPut
9D007C00  00000000   NOP
337:                     SPIGet();
9D007C04  3C02BF80   LUI V0, -16512
9D007C08  8C425820   LW V0, 22560(V0)
338:                 
339:                     SPIPut(0);
9D007C0C  00002021   ADDU A0, ZERO, ZERO
9D007C10  0F401DC8   JAL SPIPut
9D007C14  00000000   NOP
340:                     temp = SPIGet();
9D007C18  3C02BF80   LUI V0, -16512
9D007C1C  8C425820   LW V0, 22560(V0)
9D007C20  A3C20010   SB V0, 16(S8)
341:                     SST25CSHigh();
9D007C24  3C03BF88   LUI V1, -16504
9D007C28  8C626160   LW V0, 24928(V1)
9D007C2C  24040001   ADDIU A0, ZERO, 1
9D007C30  7C821084   INS V0, A0, 2, 1
9D007C34  AC626160   SW V0, 24928(V1)
342:                 
343:                     return (temp & 0x01);
9D007C38  93C20010   LBU V0, 16(S8)
9D007C3C  30420001   ANDI V0, V0, 1
9D007C40  304200FF   ANDI V0, V0, 255
344:                 }
9D007C44  03C0E821   ADDU SP, S8, ZERO
9D007C48  8FBF001C   LW RA, 28(SP)
9D007C4C  8FBE0018   LW S8, 24(SP)
9D007C50  27BD0020   ADDIU SP, SP, 32
9D007C54  03E00008   JR RA
9D007C58  00000000   NOP
345:                 
346:                 /************************************************************************
347:                 * Function: BYTE SST25WriteArray(DWORD address, BYTE* pData, nCount)
348:                 *                                                                       
349:                 * Overview: this function writes a data array at the address specified
350:                 *                                                                       
351:                 * Input: flash memory address, pointer to the data array, data number
352:                 *                                                                       
353:                 * Output: return 1 if the operation was successfull
354:                 *                                                                     
355:                 ************************************************************************/
356:                 BYTE SST25WriteArray(DWORD address, BYTE *pData, WORD nCount)
357:                 {
9D007C5C  27BDFFD0   ADDIU SP, SP, -48
9D007C60  AFBF002C   SW RA, 44(SP)
9D007C64  AFBE0028   SW S8, 40(SP)
9D007C68  AFB00024   SW S0, 36(SP)
9D007C6C  03A0F021   ADDU S8, SP, ZERO
9D007C70  AFC40030   SW A0, 48(S8)
9D007C74  AFC50034   SW A1, 52(S8)
9D007C78  00C01021   ADDU V0, A2, ZERO
9D007C7C  A7C20038   SH V0, 56(S8)
358:                     DWORD   addr;
359:                     BYTE    *pD;
360:                     WORD    counter;
361:                 
362:                     addr = address;
9D007C80  8FC20030   LW V0, 48(S8)
9D007C84  AFC20010   SW V0, 16(S8)
363:                     pD = pData;
9D007C88  8FC20034   LW V0, 52(S8)
9D007C8C  AFC20014   SW V0, 20(S8)
364:                 
365:                     // WRITE
366:                     for(counter = 0; counter < nCount; counter++)
9D007C90  A7C00018   SH ZERO, 24(S8)
9D007C94  0B401F38   J 0x9D007CE0
9D007C98  00000000   NOP
9D007CD4  97C20018   LHU V0, 24(S8)
9D007CD8  24420001   ADDIU V0, V0, 1
9D007CDC  A7C20018   SH V0, 24(S8)
9D007CE0  97C30018   LHU V1, 24(S8)
9D007CE4  97C20038   LHU V0, 56(S8)
9D007CE8  0062102B   SLTU V0, V1, V0
9D007CEC  1440FFEB   BNE V0, ZERO, 0x9D007C9C
9D007CF0  00000000   NOP
367:                     {
368:                         SST25WriteByte(*pD++, addr++);
9D007C9C  8FC20014   LW V0, 20(S8)
9D007CA0  90420000   LBU V0, 0(V0)
9D007CA4  00401821   ADDU V1, V0, ZERO
9D007CA8  8FC20014   LW V0, 20(S8)
9D007CAC  24420001   ADDIU V0, V0, 1
9D007CB0  AFC20014   SW V0, 20(S8)
9D007CB4  8FC20010   LW V0, 16(S8)
9D007CB8  8FC40010   LW A0, 16(S8)
9D007CBC  24840001   ADDIU A0, A0, 1
9D007CC0  AFC40010   SW A0, 16(S8)
9D007CC4  00602021   ADDU A0, V1, ZERO
9D007CC8  00402821   ADDU A1, V0, ZERO
9D007CCC  0F401E2D   JAL SST25WriteByte
9D007CD0  00000000   NOP
369:                     }
370:                 
371:                     // VERIFY
372:                     for(counter = 0; counter < nCount; counter++)
9D007CF4  A7C00018   SH ZERO, 24(S8)
9D007CF8  0B401F53   J 0x9D007D4C
9D007CFC  00000000   NOP
9D007D40  97C20018   LHU V0, 24(S8)
9D007D44  24420001   ADDIU V0, V0, 1
9D007D48  A7C20018   SH V0, 24(S8)
9D007D4C  97C30018   LHU V1, 24(S8)
9D007D50  97C20038   LHU V0, 56(S8)
9D007D54  0062102B   SLTU V0, V1, V0
9D007D58  1440FFE9   BNE V0, ZERO, 0x9D007D00
9D007D5C  00000000   NOP
373:                     {
374:                         if(*pData != SST25ReadByte(address))
9D007D00  8FC20034   LW V0, 52(S8)
9D007D04  90500000   LBU S0, 0(V0)
9D007D08  8FC40030   LW A0, 48(S8)
9D007D0C  0F401E6F   JAL SST25ReadByte
9D007D10  00000000   NOP
9D007D14  12020004   BEQ S0, V0, 0x9D007D28
9D007D18  00000000   NOP
375:                             return (0);
9D007D1C  00001021   ADDU V0, ZERO, ZERO
9D007D20  0B401F59   J 0x9D007D64
9D007D24  00000000   NOP
376:                         pData++;
9D007D28  8FC20034   LW V0, 52(S8)
9D007D2C  24420001   ADDIU V0, V0, 1
9D007D30  AFC20034   SW V0, 52(S8)
377:                         address++;
9D007D34  8FC20030   LW V0, 48(S8)
9D007D38  24420001   ADDIU V0, V0, 1
9D007D3C  AFC20030   SW V0, 48(S8)
378:                     }
379:                 
380:                     return (1);
9D007D60  24020001   ADDIU V0, ZERO, 1
381:                 }
9D007D64  03C0E821   ADDU SP, S8, ZERO
9D007D68  8FBF002C   LW RA, 44(SP)
9D007D6C  8FBE0028   LW S8, 40(SP)
9D007D70  8FB00024   LW S0, 36(SP)
9D007D74  27BD0030   ADDIU SP, SP, 48
9D007D78  03E00008   JR RA
9D007D7C  00000000   NOP
382:                 
383:                 /************************************************************************
384:                 * Function: void SST25ReadArray(DWORD address, BYTE* pData, nCount)
385:                 *                                                                       
386:                 * Overview: this function reads data into buffer specified
387:                 *                                                                       
388:                 * Input: flash memory address, pointer to the data buffer, data number
389:                 *                                                                       
390:                 ************************************************************************/
391:                 void SST25ReadArray(DWORD address, BYTE *pData, WORD nCount)
392:                 {
9D007D80  27BDFFE8   ADDIU SP, SP, -24
9D007D84  AFBF0014   SW RA, 20(SP)
9D007D88  AFBE0010   SW S8, 16(SP)
9D007D8C  03A0F021   ADDU S8, SP, ZERO
9D007D90  AFC40018   SW A0, 24(S8)
9D007D94  AFC5001C   SW A1, 28(S8)
9D007D98  00C01021   ADDU V0, A2, ZERO
9D007D9C  A7C20020   SH V0, 32(S8)
393:                     SST25CSLow();
9D007DA0  3C03BF88   LUI V1, -16504
9D007DA4  8C626160   LW V0, 24928(V1)
9D007DA8  7C021084   INS V0, ZERO, 2, 1
9D007DAC  AC626160   SW V0, 24928(V1)
394:                 
395:                     SPIPut(SST25_CMD_READ);
9D007DB0  24040003   ADDIU A0, ZERO, 3
9D007DB4  0F401DC8   JAL SPIPut
9D007DB8  00000000   NOP
396:                     SPIGet();
9D007DBC  3C02BF80   LUI V0, -16512
9D007DC0  8C425820   LW V0, 22560(V0)
397:                 
398:                     SPIPut(((DWORD_VAL) address).v[2]);
9D007DC4  00001021   ADDU V0, ZERO, ZERO
9D007DC8  8FC20018   LW V0, 24(S8)
9D007DCC  7C423C00   EXT V0, V0, 16, 8
9D007DD0  304200FF   ANDI V0, V0, 255
9D007DD4  00402021   ADDU A0, V0, ZERO
9D007DD8  0F401DC8   JAL SPIPut
9D007DDC  00000000   NOP
399:                     SPIGet();
9D007DE0  3C02BF80   LUI V0, -16512
9D007DE4  8C425820   LW V0, 22560(V0)
400:                 
401:                     SPIPut(((DWORD_VAL) address).v[1]);
9D007DE8  00001021   ADDU V0, ZERO, ZERO
9D007DEC  8FC20018   LW V0, 24(S8)
9D007DF0  7C423A00   EXT V0, V0, 8, 8
9D007DF4  304200FF   ANDI V0, V0, 255
9D007DF8  00402021   ADDU A0, V0, ZERO
9D007DFC  0F401DC8   JAL SPIPut
9D007E00  00000000   NOP
402:                     SPIGet();
9D007E04  3C02BF80   LUI V0, -16512
9D007E08  8C425820   LW V0, 22560(V0)
403:                 
404:                     SPIPut(((DWORD_VAL) address).v[0]);
9D007E0C  00001021   ADDU V0, ZERO, ZERO
9D007E10  8FC20018   LW V0, 24(S8)
9D007E14  304200FF   ANDI V0, V0, 255
9D007E18  00402021   ADDU A0, V0, ZERO
9D007E1C  0F401DC8   JAL SPIPut
9D007E20  00000000   NOP
405:                     SPIGet();
9D007E24  3C02BF80   LUI V0, -16512
9D007E28  8C425820   LW V0, 22560(V0)
406:                 
407:                     while(nCount--)
9D007E2C  0B401F98   J 0x9D007E60
9D007E30  00000000   NOP
9D007E60  97C20020   LHU V0, 32(S8)
9D007E64  0002102B   SLTU V0, ZERO, V0
9D007E68  304200FF   ANDI V0, V0, 255
9D007E6C  97C30020   LHU V1, 32(S8)
9D007E70  2463FFFF   ADDIU V1, V1, -1
9D007E74  A7C30020   SH V1, 32(S8)
9D007E78  1440FFEE   BNE V0, ZERO, 0x9D007E34
9D007E7C  00000000   NOP
408:                     {
409:                         SPIPut(0);
9D007E34  00002021   ADDU A0, ZERO, ZERO
9D007E38  0F401DC8   JAL SPIPut
9D007E3C  00000000   NOP
410:                         *pData++ = SPIGet();
9D007E40  3C02BF80   LUI V0, -16512
9D007E44  8C425820   LW V0, 22560(V0)
9D007E48  304300FF   ANDI V1, V0, 255
9D007E4C  8FC2001C   LW V0, 28(S8)
9D007E50  A0430000   SB V1, 0(V0)
9D007E54  8FC2001C   LW V0, 28(S8)
9D007E58  24420001   ADDIU V0, V0, 1
9D007E5C  AFC2001C   SW V0, 28(S8)
411:                     }
412:                 
413:                     SST25CSHigh();
9D007E80  3C03BF88   LUI V1, -16504
9D007E84  8C626160   LW V0, 24928(V1)
9D007E88  24040001   ADDIU A0, ZERO, 1
9D007E8C  7C821084   INS V0, A0, 2, 1
9D007E90  AC626160   SW V0, 24928(V1)
414:                 }
9D007E94  03C0E821   ADDU SP, S8, ZERO
9D007E98  8FBF0014   LW RA, 20(SP)
9D007E9C  8FBE0010   LW S8, 16(SP)
9D007EA0  27BD0018   ADDIU SP, SP, 24
9D007EA4  03E00008   JR RA
9D007EA8  00000000   NOP
415:                 
416:                 /************************************************************************
417:                 * Function: void SST25ChipErase(void)
418:                 *                                                                       
419:                 * Overview: chip erase
420:                 *                                                                       
421:                 * Input: none
422:                 *                                                                       
423:                 ************************************************************************/
424:                 void SST25ChipErase(void)
425:                 {
9D007EAC  27BDFFE8   ADDIU SP, SP, -24
9D007EB0  AFBF0014   SW RA, 20(SP)
9D007EB4  AFBE0010   SW S8, 16(SP)
9D007EB8  03A0F021   ADDU S8, SP, ZERO
426:                     SST25WriteEnable();
9D007EBC  0F401EDE   JAL SST25WriteEnable
9D007EC0  00000000   NOP
427:                 
428:                     SST25CSLow();
9D007EC4  3C03BF88   LUI V1, -16504
9D007EC8  8C626160   LW V0, 24928(V1)
9D007ECC  7C021084   INS V0, ZERO, 2, 1
9D007ED0  AC626160   SW V0, 24928(V1)
429:                 
430:                     SPIPut(SST25_CMD_CHIP_ERASE);		// <sek> was SST25_CMD_ERASE
9D007ED4  24040060   ADDIU A0, ZERO, 96
9D007ED8  0F401DC8   JAL SPIPut
9D007EDC  00000000   NOP
431:                     SPIGet();
9D007EE0  3C02BF80   LUI V0, -16512
9D007EE4  8C425820   LW V0, 22560(V0)
432:                 
433:                     SST25CSHigh();
9D007EE8  3C03BF88   LUI V1, -16504
9D007EEC  8C626160   LW V0, 24928(V1)
9D007EF0  24040001   ADDIU A0, ZERO, 1
9D007EF4  7C821084   INS V0, A0, 2, 1
9D007EF8  AC626160   SW V0, 24928(V1)
434:                 
435:                     // Wait for write end
436:                     while(SST25IsWriteBusy())
9D007EFC  00000000   NOP
9D007F00  0F401EF6   JAL SST25IsWriteBusy
9D007F04  00000000   NOP
9D007F08  1440FFFD   BNE V0, ZERO, 0x9D007F00
9D007F0C  00000000   NOP
437:                 		;
438:                 }
9D007F10  03C0E821   ADDU SP, S8, ZERO
9D007F14  8FBF0014   LW RA, 20(SP)
9D007F18  8FBE0010   LW S8, 16(SP)
9D007F1C  27BD0018   ADDIU SP, SP, 24
9D007F20  03E00008   JR RA
9D007F24  00000000   NOP
439:                 
440:                 /************************************************************************
441:                 * Function: void SST25ResetWriteProtection()
442:                 *                                                                       
443:                 * Overview: this function reset write protection bits
444:                 *                                                                       
445:                 * Input: none                                                     
446:                 *                                                                       
447:                 * Output: none
448:                 *                                                                       
449:                 ************************************************************************/
450:                 void SST25ResetWriteProtection(void)
451:                 {
9D007F28  27BDFFE8   ADDIU SP, SP, -24
9D007F2C  AFBF0014   SW RA, 20(SP)
9D007F30  AFBE0010   SW S8, 16(SP)
9D007F34  03A0F021   ADDU S8, SP, ZERO
452:                     SST25CSLow();
9D007F38  3C03BF88   LUI V1, -16504
9D007F3C  8C626160   LW V0, 24928(V1)
9D007F40  7C021084   INS V0, ZERO, 2, 1
9D007F44  AC626160   SW V0, 24928(V1)
453:                 
454:                     SPIPut(SST25_CMD_EN_WR_STATUS_REG);		// <sek> was SST25_CMD_EWSR
9D007F48  24040050   ADDIU A0, ZERO, 80
9D007F4C  0F401DC8   JAL SPIPut
9D007F50  00000000   NOP
455:                     SPIGet();
9D007F54  3C02BF80   LUI V0, -16512
9D007F58  8C425820   LW V0, 22560(V0)
456:                 
457:                     SST25CSHigh();
9D007F5C  3C03BF88   LUI V1, -16504
9D007F60  8C626160   LW V0, 24928(V1)
9D007F64  24040001   ADDIU A0, ZERO, 1
9D007F68  7C821084   INS V0, A0, 2, 1
9D007F6C  AC626160   SW V0, 24928(V1)
458:                 
459:                     SST25CSLow();
9D007F70  3C03BF88   LUI V1, -16504
9D007F74  8C626160   LW V0, 24928(V1)
9D007F78  7C021084   INS V0, ZERO, 2, 1
9D007F7C  AC626160   SW V0, 24928(V1)
460:                 
461:                     SPIPut(SST25_CMD_WR_STATUS_REG);		// <sek> was SST25_CMD_WRSR
9D007F80  24040001   ADDIU A0, ZERO, 1
9D007F84  0F401DC8   JAL SPIPut
9D007F88  00000000   NOP
462:                     SPIGet();
9D007F8C  3C02BF80   LUI V0, -16512
9D007F90  8C425820   LW V0, 22560(V0)
463:                 
464:                     SPIPut(0);
9D007F94  00002021   ADDU A0, ZERO, ZERO
9D007F98  0F401DC8   JAL SPIPut
9D007F9C  00000000   NOP
465:                     SPIGet();
9D007FA0  3C02BF80   LUI V0, -16512
9D007FA4  8C425820   LW V0, 22560(V0)
466:                 
467:                     SST25CSHigh();
9D007FA8  3C03BF88   LUI V1, -16504
9D007FAC  8C626160   LW V0, 24928(V1)
9D007FB0  24040001   ADDIU A0, ZERO, 1
9D007FB4  7C821084   INS V0, A0, 2, 1
9D007FB8  AC626160   SW V0, 24928(V1)
468:                 }
9D007FBC  03C0E821   ADDU SP, S8, ZERO
9D007FC0  8FBF0014   LW RA, 20(SP)
9D007FC4  8FBE0010   LW S8, 16(SP)
9D007FC8  27BD0018   ADDIU SP, SP, 24
9D007FCC  03E00008   JR RA
9D007FD0  00000000   NOP
469:                 
470:                 /************************************************************************
471:                 * Function: void SST25SectorErase(DWORD address)                                           
472:                 *                                                                       
473:                 * Overview: this function erases a 4Kb sector
474:                 *                                                                       
475:                 * Input: address within sector to be erased
476:                 *                                                                       
477:                 * Output: none                                 
478:                 *                                                                       
479:                 ************************************************************************/
480:                 void SST25SectorErase(DWORD address)
481:                 {
9D007FD4  27BDFFE8   ADDIU SP, SP, -24
9D007FD8  AFBF0014   SW RA, 20(SP)
9D007FDC  AFBE0010   SW S8, 16(SP)
9D007FE0  03A0F021   ADDU S8, SP, ZERO
9D007FE4  AFC40018   SW A0, 24(S8)
482:                     SST25WriteEnable();
9D007FE8  0F401EDE   JAL SST25WriteEnable
9D007FEC  00000000   NOP
483:                     SST25CSLow();
9D007FF0  3C03BF88   LUI V1, -16504
9D007FF4  8C626160   LW V0, 24928(V1)
9D007FF8  7C021084   INS V0, ZERO, 2, 1
9D007FFC  AC626160   SW V0, 24928(V1)
484:                 
485:                     SPIPut(SST25_CMD_4K_ERASE);			// <sek> was SST25_CMD_SER
9D008000  24040020   ADDIU A0, ZERO, 32
9D008004  0F401DC8   JAL SPIPut
9D008008  00000000   NOP
486:                     SPIGet();
9D00800C  3C02BF80   LUI V0, -16512
9D008010  8C425820   LW V0, 22560(V0)
487:                 
488:                     SPIPut(((DWORD_VAL) address).v[2]);
9D008014  00001021   ADDU V0, ZERO, ZERO
9D008018  8FC20018   LW V0, 24(S8)
9D00801C  7C423C00   EXT V0, V0, 16, 8
9D008020  304200FF   ANDI V0, V0, 255
9D008024  00402021   ADDU A0, V0, ZERO
9D008028  0F401DC8   JAL SPIPut
9D00802C  00000000   NOP
489:                     SPIGet();
9D008030  3C02BF80   LUI V0, -16512
9D008034  8C425820   LW V0, 22560(V0)
490:                 
491:                     SPIPut(((DWORD_VAL) address).v[1]);
9D008038  00001021   ADDU V0, ZERO, ZERO
9D00803C  8FC20018   LW V0, 24(S8)
9D008040  7C423A00   EXT V0, V0, 8, 8
9D008044  304200FF   ANDI V0, V0, 255
9D008048  00402021   ADDU A0, V0, ZERO
9D00804C  0F401DC8   JAL SPIPut
9D008050  00000000   NOP
492:                     SPIGet();
9D008054  3C02BF80   LUI V0, -16512
9D008058  8C425820   LW V0, 22560(V0)
493:                 
494:                     SPIPut(((DWORD_VAL) address).v[0]);
9D00805C  00001021   ADDU V0, ZERO, ZERO
9D008060  8FC20018   LW V0, 24(S8)
9D008064  304200FF   ANDI V0, V0, 255
9D008068  00402021   ADDU A0, V0, ZERO
9D00806C  0F401DC8   JAL SPIPut
9D008070  00000000   NOP
495:                     SPIGet();
9D008074  3C02BF80   LUI V0, -16512
9D008078  8C425820   LW V0, 22560(V0)
496:                 
497:                     SST25CSHigh();
9D00807C  3C03BF88   LUI V1, -16504
9D008080  8C626160   LW V0, 24928(V1)
9D008084  24040001   ADDIU A0, ZERO, 1
9D008088  7C821084   INS V0, A0, 2, 1
9D00808C  AC626160   SW V0, 24928(V1)
498:                 
499:                     // Wait for write end
500:                     DelayMs(100);
9D008090  24040064   ADDIU A0, ZERO, 100
9D008094  0F4036A6   JAL DelayMs
9D008098  00000000   NOP
501:                     while(SST25IsWriteBusy())
9D00809C  00000000   NOP
9D0080A0  0F401EF6   JAL SST25IsWriteBusy
9D0080A4  00000000   NOP
9D0080A8  1440FFFD   BNE V0, ZERO, 0x9D0080A0
9D0080AC  00000000   NOP
502:                 		;
503:                 }
9D0080B0  03C0E821   ADDU SP, S8, ZERO
9D0080B4  8FBF0014   LW RA, 20(SP)
9D0080B8  8FBE0010   LW S8, 16(SP)
9D0080BC  27BD0018   ADDIU SP, SP, 24
9D0080C0  03E00008   JR RA
9D0080C4  00000000   NOP
504:                 
---  ../Include/BSP/HardwareProfile_PIC32_STK.h  --------------------------------------------------------
9D009460  24040004   ADDIU A0, ZERO, 4
9D009464  24050010   ADDIU A1, ZERO, 16
9D009468  0F403987   JAL PORTClearBits
9D00946C  00000000   NOP
9D009470  24040004   ADDIU A0, ZERO, 4
9D009474  24050010   ADDIU A1, ZERO, 16
9D009478  0F403896   JAL PORTSetPinsDigitalOut
9D00947C  00000000   NOP
9D0095DC  24040004   ADDIU A0, ZERO, 4
9D0095E0  24050010   ADDIU A1, ZERO, 16
9D0095E4  0F403990   JAL PORTSetBits
9D0095E8  00000000   NOP
9D006764  24040003   ADDIU A0, ZERO, 3
9D006768  24050300   ADDIU A1, ZERO, 768
9D00676C  0F403987   JAL PORTClearBits
9D006770  00000000   NOP
9D006774  24040003   ADDIU A0, ZERO, 3
9D006778  24050300   ADDIU A1, ZERO, 768
9D00677C  0F403887   JAL PORTSetPinsDigitalIn
9D006780  00000000   NOP
9D006CA0  24040003   ADDIU A0, ZERO, 3
9D006CA4  24050300   ADDIU A1, ZERO, 768
9D006CA8  0F40397E   JAL PORTReadBits
9D006CAC  00000000   NOP
9D006CB0  3042FFFF   ANDI V0, V0, -1
